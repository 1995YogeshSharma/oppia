from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/collection/CollectionPlaythroughObjectFactory.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating and mutating instances of frontend\n * collection playthrough domain objects.\n */\n\noppia.factory(\'CollectionPlaythroughObjectFactory\', [function() {\n  // TODO(bhenning): Add setters for some of these properties. Setters allow\n  // the collection editor to setup specifically configured playthrough\n  // sessions of the collection player through this object (for example, the\n  // editor would be able to fake which explorations were completed to see how\n  // that particular configuration would look for a learner).\n\n  // Stores information about a current playthrough of a collection for a\n  // user.\n  var CollectionPlaythrough = function(\n      nextExplorationId, completedExplorationIds) {\n    this._nextExplorationId = nextExplorationId;\n    this._completedExplorationIds = completedExplorationIds;\n  };\n\n  // Returns the upcoming exploration ID. Changes to this are not\n  // reflected in the collection.\n  CollectionPlaythrough.prototype.getNextExplorationId = function() {\n    return this._nextExplorationId;\n  };\n\n  CollectionPlaythrough.prototype.getNextRecommendedCollectionNodeCount =\n    function() {\n      // As the collection is linear, only a single node would be available,\n      // after any node.\n      return 1;\n    };\n\n  CollectionPlaythrough.hasFinishedCollection = function() {\n    return this._nextExplorationId === null;\n  };\n\n  // Returns a list of explorations completed that are related to this\n  // collection. Changes to this list are not reflected in this collection.\n  CollectionPlaythrough.prototype.getCompletedExplorationIds = function() {\n    return angular.copy(this._completedExplorationIds);\n  };\n\n  CollectionPlaythrough.prototype.getCompletedExplorationNodeCount =\n    function() {\n      return this._completedExplorationIds.length;\n    };\n\n  CollectionPlaythrough.prototype.hasStartedCollection = function() {\n    return this._completedExplorationIds.length !== 0;\n  };\n\n  // Static class methods. Note that "this" is not available in static\n  // contexts. This function takes a JSON object which represents a backend\n  // collection playthrough python dict.\n  CollectionPlaythrough.createFromBackendObject = function(\n      collectionPlaythroughBackendObject) {\n    return new CollectionPlaythrough(\n      collectionPlaythroughBackendObject.next_exploration_id,\n      collectionPlaythroughBackendObject.completed_exploration_ids);\n  };\n\n  CollectionPlaythrough.create = function(\n      nextExplorationId, completedExplorationIds) {\n    return new CollectionPlaythrough(\n      nextExplorationId, angular.copy(completedExplorationIds));\n  };\n\n  return CollectionPlaythrough;\n}]);'

blocks = {}
debug_info = ''
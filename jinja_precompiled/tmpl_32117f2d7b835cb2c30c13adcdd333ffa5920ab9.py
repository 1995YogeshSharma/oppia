from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/StateGraphVisualizationDirective.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directive for the state graph visualization.\n */\n\n/* eslint-disable angular/directive-restrict */\noppia.directive(\'stateGraphViz\', [\n  \'UrlInterpolationService\', function(UrlInterpolationService) {\n    return {\n      // Note: This directive is used as attribute because pannability does not\n      //    work when directive is used as element. (Convention in the codebase\n      //    is to use directive as element.)\n      restrict: \'A\',\n      scope: {\n        allowPanning: \'@\',\n        centerAtCurrentState: \'@\',\n        currentStateId: \'&\',\n        // A function returning an object with these keys:\n        //  - \'nodes\': An object whose keys are node ids and whose values are\n        //             node labels\n        //  - \'links\': A list of objects with keys:\n        //            \'source\': id of source node\n        //            \'target\': id of target node\n        //            \'linkProperty\': property of link which determines how\n        //              it is styled (styles in linkPropertyMapping). If\n        //              linkProperty or corresponding linkPropertyMatching\n        //              is undefined, link style defaults to the gray arrow.\n        //  - \'initStateId\': The initial state id\n        //  - \'finalStateIds\': The list of ids corresponding to terminal states\n        //             (i.e., those whose interactions are terminal).\n        graphData: \'&\',\n        // Object whose keys are ids of nodes to display a warning tooltip over\n        highlightStates: \'=\',\n        // Id of a second initial state, which will be styled as an initial\n        // state\n        initStateId2: \'=\',\n        isEditable: \'=\',\n        // Object which maps linkProperty to a style\n        linkPropertyMapping: \'=\',\n        // Object whose keys are node ids and whose values are node colors\n        getNodeColors: \'&nodeColors\',\n        // A value which is the color of all nodes\n        nodeFill: \'@\',\n        // Object whose keys are node ids with secondary labels and whose\n        // values are secondary labels. If this is undefined, it means no nodes\n        // have secondary labels.\n        nodeSecondaryLabels: \'=\',\n        // Function called when node is clicked. Should take a parameter\n        // node.id.\n        onClickFunction: \'=\',\n        onDeleteFunction: \'=\',\n        onMaximizeFunction: \'=\',\n        // Object whose keys are ids of nodes, and whose values are the\n        // corresponding node opacities.\n        opacityMap: \'=\',\n        showWarningSign: \'@\',\n        showTranslationWarnings: \'@\'\n      },\n      templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n        \'/pages/exploration_editor/editor_tab/\' +\n        \'state_graph_visualization_directive.html\'),\n      controller: [\n        \'$element\', \'$filter\', \'$scope\', \'$timeout\',\n        \'ExplorationWarningsService\', \'StateGraphLayoutService\',\n        \'TranslationStatusService\', \'MAX_NODES_PER_ROW\',\n        \'MAX_NODE_LABEL_LENGTH\',\n        function(\n            $element, $filter, $scope, $timeout,\n            ExplorationWarningsService, StateGraphLayoutService,\n            TranslationStatusService, MAX_NODES_PER_ROW,\n            MAX_NODE_LABEL_LENGTH) {\n          var redrawGraph = function() {\n            if ($scope.graphData()) {\n              $scope.graphLoaded = false;\n              $scope.drawGraph(\n                $scope.graphData().nodes, $scope.graphData().links,\n                $scope.graphData().initStateId, $scope.graphData().finalStateIds\n              );\n\n              // Wait for the graph to finish loading before showing it again.\n              $timeout(function() {\n                $scope.graphLoaded = true;\n              });\n            }\n          };\n\n          $scope.$on(\'redrawGraph\', function() {\n            redrawGraph();\n          });\n\n          $scope.$watch(\'graphData()\', redrawGraph, true);\n          $scope.$watch(\'currentStateId()\', redrawGraph);\n          $scope.$watch(\'getNodeColors()\', redrawGraph, true);\n          // If statistics for a different version of the exploration are\n          // loaded, this may change the opacities of the nodes.\n          $scope.$watch(\'opacityMap\', redrawGraph);\n          $(window).resize(redrawGraph);\n\n          var getElementDimensions = function() {\n            return {\n              h: $element.height(),\n              w: $element.width()\n            };\n          };\n\n          // Returns the closest number to `value` in the range\n          // [bound1, bound2].\n          var clamp = function(value, bound1, bound2) {\n            var minValue = Math.min(bound1, bound2);\n            var maxValue = Math.max(bound1, bound2);\n            return Math.min(Math.max(value, minValue), maxValue);\n          };\n\n          $scope.getGraphHeightInPixels = function() {\n            return Math.max($scope.GRAPH_HEIGHT, 300);\n          };\n\n          $scope.drawGraph = function(\n              nodes, originalLinks, initStateId, finalStateIds) {\n            $scope.finalStateIds = finalStateIds;\n            var links = angular.copy(originalLinks);\n\n            var nodeData = StateGraphLayoutService.computeLayout(\n              nodes, links, initStateId, angular.copy(finalStateIds));\n\n            $scope.GRAPH_WIDTH = StateGraphLayoutService.getGraphWidth(\n              MAX_NODES_PER_ROW, MAX_NODE_LABEL_LENGTH);\n            $scope.GRAPH_HEIGHT = StateGraphLayoutService.getGraphHeight(\n              nodeData);\n\n            nodeData = StateGraphLayoutService.modifyPositionValues(\n              nodeData, $scope.GRAPH_WIDTH, $scope.GRAPH_HEIGHT);\n\n            // These constants correspond to the rectangle that, when clicked\n            // and dragged, translates the graph. Its height, width, and x and\n            // y offsets are set to arbitrary large values so that the\n            // draggable area extends beyond the graph.\n            $scope.VIEWPORT_WIDTH = Math.max(10000, $scope.GRAPH_WIDTH * 5);\n            $scope.VIEWPORT_HEIGHT = Math.max(10000, $scope.GRAPH_HEIGHT * 5);\n            $scope.VIEWPORT_X = -Math.max(1000, $scope.GRAPH_WIDTH * 2);\n            $scope.VIEWPORT_Y = -Math.max(1000, $scope.GRAPH_HEIGHT * 2);\n\n            var graphBounds = StateGraphLayoutService.getGraphBoundaries(\n              nodeData);\n\n            $scope.augmentedLinks = StateGraphLayoutService.getAugmentedLinks(\n              nodeData, links);\n\n            for (var i = 0; i < $scope.augmentedLinks.length; i++) {\n              // Style links if link properties and style mappings are\n              // provided\n              if (links[i].hasOwnProperty(\'linkProperty\') &&\n                  $scope.linkPropertyMapping) {\n                if ($scope.linkPropertyMapping.hasOwnProperty(\n                  links[i].linkProperty)) {\n                  $scope.augmentedLinks[i].style = (\n                    $scope.linkPropertyMapping[links[i].linkProperty]);\n                }\n              }\n            }\n\n            var getNodeStrokeWidth = function(nodeId) {\n              var currentNodeIsTerminal = (\n                $scope.finalStateIds.indexOf(nodeId) !== -1);\n              return (\n                nodeId === $scope.currentStateId() ? \'3\' :\n                (nodeId === $scope.initStateId2 || currentNodeIsTerminal) ?\n                  \'2\' : \'1\');\n            };\n\n            var getNodeFillOpacity = function(nodeId) {\n              return $scope.opacityMap ? $scope.opacityMap[nodeId] : 0.5;\n            };\n\n            $scope.isStateFlagged = function(nodeId) {\n              return $scope.highlightStates &&\n                $scope.highlightStates.hasOwnProperty(nodeId);\n            };\n\n            $scope.getNodeTitle = function(node) {\n              var warning = \'\';\n              if (node.reachable === false) {\n                warning = \'Warning: this state is unreachable.\';\n              } else if (node.reachableFromEnd === false) {\n                warning = (\n                  \'Warning: there is no path from this state to the END state.\'\n                );\n              }\n\n              var tooltip = node.label;\n\n              if (node.hasOwnProperty(\'secondaryLabel\')) {\n                tooltip += \' \' + node.secondaryLabel;\n              }\n\n              if (warning) {\n                tooltip += \' (\' + warning + \')\';\n              }\n              return tooltip;\n            };\n\n            $scope.onNodeDeletionClick = function(nodeId) {\n              if (nodeId !== initStateId) {\n                $scope.onDeleteFunction(nodeId);\n              }\n            };\n\n            $scope.getHighlightTransform = function(x0, y0) {\n              return \'rotate(-10,\' + (x0 - 10) + \',\' + (y0 - 5) + \')\';\n            };\n\n            $scope.getHighlightTextTransform = function(x0, y0) {\n              return \'rotate(-10,\' + x0 + \',\' + (y0 - 4) + \')\';\n            };\n\n            $scope.canNavigateToNode = function(nodeId) {\n              return nodeId !== $scope.currentStateId();\n            };\n\n            $scope.getTruncatedLabel = function(nodeLabel) {\n              return $filter(\'truncate\')(nodeLabel, MAX_NODE_LABEL_LENGTH);\n            };\n\n            // Update the nodes.\n            $scope.nodeList = [];\n            for (var nodeId in nodeData) {\n              nodeData[nodeId].style = (\n                \'stroke-width: \' + getNodeStrokeWidth(nodeId) + \'; \' +\n                \'fill-opacity: \' + getNodeFillOpacity(nodeId) + \';\');\n\n              if ($scope.nodeFill) {\n                nodeData[nodeId].style += (\'fill: \' + $scope.nodeFill + \'; \');\n              }\n\n              // Color nodes\n              var nodeColors = $scope.getNodeColors();\n              if (nodeColors) {\n                nodeData[nodeId].style += (\n                  \'fill: \' + nodeColors[nodeId] + \'; \');\n              }\n\n              // Add secondary label if it exists\n              if ($scope.nodeSecondaryLabels) {\n                if ($scope.nodeSecondaryLabels.hasOwnProperty(nodeId)) {\n                  nodeData[nodeId].secondaryLabel = (\n                    $scope.nodeSecondaryLabels[nodeId]);\n                  nodeData[nodeId].height *= 1.1;\n                }\n              }\n\n              var currentNodeIsTerminal = (\n                $scope.finalStateIds.indexOf(nodeId) !== -1);\n\n              nodeData[nodeId].nodeClass = (\n                currentNodeIsTerminal ? \'terminal-node\' :\n                nodeId === $scope.currentStateId() ? \'current-node\' :\n                nodeId === initStateId ? \'init-node\' :\n                !(nodeData[nodeId].reachable &&\n                  nodeData[nodeId].reachableFromEnd) ? \'bad-node\' :\n                \'normal-node\');\n\n              nodeData[nodeId].canDelete = (nodeId !== initStateId);\n              $scope.nodeList.push(nodeData[nodeId]);\n            }\n\n            $scope.getNodeErrorMessage = function(nodeLabel) {\n              var warnings = null;\n              if ($scope.showTranslationWarnings) {\n                warnings =\n                  TranslationStatusService.getAllStatesNeedUpdatewarning();\n              } else {\n                warnings =\n                  ExplorationWarningsService.getAllStateRelatedWarnings();\n              }\n              if (warnings.hasOwnProperty(nodeLabel)) {\n                return warnings[nodeLabel][0].toString();\n              }\n            };\n\n            // The translation applied when the graph is first loaded.\n            var origTranslations = [0, 0];\n            $scope.overallTransformStr = \'translate(0,0)\';\n            $scope.innerTransformStr = \'translate(0,0)\';\n\n            if ($scope.allowPanning) {\n              // Without the timeout, $element.find fails to find the required\n              // rect in the state graph modal dialog.\n              $timeout(function() {\n                var dimensions = getElementDimensions();\n\n                d3.select($element.find(\'rect.pannable-rect\')[0])\n                  .call(d3.behavior.zoom().scaleExtent([1, 1])\n                    .on(\'zoom\', function() {\n                      if (graphBounds.right - graphBounds.left < dimensions.w) {\n                        d3.event.translate[0] = 0;\n                      } else {\n                        d3.event.translate[0] = clamp(\n                          d3.event.translate[0],\n                          dimensions.w - graphBounds.right -\n                           origTranslations[0],\n                          -graphBounds.left - origTranslations[0]);\n                      }\n\n                      if (graphBounds.bottom - graphBounds.top < dimensions.h) {\n                        d3.event.translate[1] = 0;\n                      } else {\n                        d3.event.translate[1] = clamp(\n                          d3.event.translate[1],\n                          dimensions.h - graphBounds.bottom -\n                           origTranslations[1],\n                          -graphBounds.top - origTranslations[1]);\n                      }\n\n                      // We need a separate layer here so that the translation\n                      // does not influence the panning event receivers.\n                      $scope.innerTransformStr = (\n                        \'translate(\' + d3.event.translate + \')\');\n                      $scope.$apply();\n                    })\n                  );\n              }, 10);\n            }\n\n            if ($scope.centerAtCurrentState) {\n              $timeout(function() {\n                var dimensions = getElementDimensions();\n\n                // Center the graph at the node representing the current state.\n                origTranslations[0] = (\n                  dimensions.w / 2 - nodeData[$scope.currentStateId()].x0 -\n                  nodeData[$scope.currentStateId()].width / 2);\n                origTranslations[1] = (\n                  dimensions.h / 2 - nodeData[$scope.currentStateId()].y0 -\n                  nodeData[$scope.currentStateId()].height / 2);\n\n                if (graphBounds.right - graphBounds.left < dimensions.w) {\n                  origTranslations[0] = (\n                    dimensions.w / 2 -\n                    (graphBounds.right + graphBounds.left) / 2);\n                } else {\n                  origTranslations[0] = clamp(\n                    origTranslations[0],\n                    dimensions.w - graphBounds.right,\n                    -graphBounds.left);\n                }\n\n                if (graphBounds.bottom - graphBounds.top < dimensions.h) {\n                  origTranslations[1] = (\n                    dimensions.h / 2 -\n                    (graphBounds.bottom + graphBounds.top) / 2);\n                } else {\n                  origTranslations[1] = clamp(\n                    origTranslations[1],\n                    dimensions.h - graphBounds.bottom,\n                    -graphBounds.top);\n                }\n\n                $scope.overallTransformStr = (\n                  \'translate(\' + origTranslations + \')\');\n                $scope.$apply();\n              }, 20);\n            }\n          };\n        }\n      ]\n    };\n  }]);\n/* eslint-enable angular/directive-restrict */'

blocks = {}
debug_info = ''
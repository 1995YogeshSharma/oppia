from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'services/RteHelperService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A helper service for the Rich text editor(RTE).\n */\n\noppia.constant(\'RTE_COMPONENT_SPECS\', richTextComponents);\n\noppia.factory(\'RteHelperService\', [\n  \'$filter\', \'$log\', \'$interpolate\', \'ExplorationContextService\',\n  \'RTE_COMPONENT_SPECS\', \'HtmlEscaperService\', \'UrlInterpolationService\',\n  function(\n      $filter, $log, $interpolate, ExplorationContextService,\n      RTE_COMPONENT_SPECS, HtmlEscaperService, UrlInterpolationService) {\n    var _RICH_TEXT_COMPONENTS = [];\n\n    Object.keys(RTE_COMPONENT_SPECS).sort().forEach(function(componentId) {\n      _RICH_TEXT_COMPONENTS.push({\n        backendId: RTE_COMPONENT_SPECS[componentId].backend_id,\n        customizationArgSpecs: angular.copy(\n          RTE_COMPONENT_SPECS[componentId].customization_arg_specs),\n        id: RTE_COMPONENT_SPECS[componentId].frontend_id,\n        iconDataUrl: RTE_COMPONENT_SPECS[componentId].icon_data_url,\n        previewUrlTemplate:\n        RTE_COMPONENT_SPECS[componentId].preview_url_template,\n        isComplex: RTE_COMPONENT_SPECS[componentId].is_complex,\n        isBlockElement: RTE_COMPONENT_SPECS[componentId].is_block_element,\n        requiresFs: RTE_COMPONENT_SPECS[componentId].requires_fs,\n        tooltip: RTE_COMPONENT_SPECS[componentId].tooltip\n      });\n    });\n\n    var _createCustomizationArgDictFromAttrs = function(attrs) {\n      var customizationArgsDict = {};\n      for (var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n        if (attr.name === \'class\' || attr.name === \'src\' ||\n          attr.name === \'_moz_resizing\') {\n          continue;\n        }\n        var separatorLocation = attr.name.indexOf(\'-with-value\');\n        if (separatorLocation === -1) {\n          $log.error(\'RTE Error: invalid customization attribute \' + attr.name);\n          continue;\n        }\n        var argName = attr.name.substring(0, separatorLocation);\n        customizationArgsDict[argName] = HtmlEscaperService.escapedJsonToObj(\n          attr.value);\n      }\n      return customizationArgsDict;\n    };\n\n    return {\n      createCustomizationArgDictFromAttrs: function(attrs) {\n        return _createCustomizationArgDictFromAttrs(attrs);\n      },\n      createToolbarIcon: function(componentDefn) {\n        var el = $(\'<img/>\');\n        el.attr(\n          \'src\', UrlInterpolationService.getExtensionResourceUrl(\n            componentDefn.iconDataUrl));\n        el.addClass(\'oppia-rte-toolbar-image\');\n        return el.get(0);\n      },\n      // Returns a DOM node.\n      createRteElement: function(componentDefn, customizationArgsDict) {\n        var el = $(\'<img/>\');\n        if (ExplorationContextService.isInExplorationContext()) {\n          // TODO(sll): This extra key was introduced in commit\n          // 19a934ce20d592a3fc46bd97a2f05f41d33e3d66 in order to retrieve an\n          // image for RTE previews. However, it has had the unfortunate side-\n          // effect of adding an extra tag to the exploration RTE tags stored\n          // in the datastore. We are now removing this key in\n          // convertRteToHtml(), but we need to find a less invasive way to\n          // handle previews.\n          customizationArgsDict = angular.extend(customizationArgsDict, {\n            explorationId: ExplorationContextService.getExplorationId()\n          });\n        }\n        var componentPreviewUrlTemplate = componentDefn.previewUrlTemplate;\n        if (componentDefn.previewUrlTemplate.indexOf(\n          \'/rich_text_components\') === 0) {\n          var interpolatedUrl = UrlInterpolationService.getExtensionResourceUrl(\n            componentPreviewUrlTemplate);\n        } else {\n          var interpolatedUrl = ($interpolate(\n            componentPreviewUrlTemplate, false, null, true)(\n            customizationArgsDict));\n        }\n\n        if (!interpolatedUrl) {\n          $log.error(\n            \'Error interpolating url : \' + componentDefn.previewUrlTemplate);\n        } else {\n          el.attr(\'src\', interpolatedUrl);\n        }\n        el.addClass(\'oppia-noninteractive-\' + componentDefn.id);\n        if (componentDefn.isBlockElement) {\n          el.addClass(\'block-element\');\n        }\n        for (var attrName in customizationArgsDict) {\n          el.attr(\n            $filter(\'camelCaseToHyphens\')(attrName) + \'-with-value\',\n            HtmlEscaperService.objToEscapedJson(\n              customizationArgsDict[attrName]));\n        }\n\n        return el.get(0);\n      },\n      // Replace <oppia-noninteractive> tags with <img> tags.\n      convertHtmlToRte: function(html) {\n        // If an undefined or empty html value is passed in, then the same type\n        // of value should be returned. Without this check,\n        // convertHtmlToRte(undefined) would return \'undefined\', which is not\n        // ideal.\n        if (!html) {\n          return html;\n        }\n\n        var elt = $(\'<div>\' + html + \'</div>\');\n        var that = this;\n\n        _RICH_TEXT_COMPONENTS.forEach(function(componentDefn) {\n          elt.find(\'oppia-noninteractive-\' + componentDefn.id).replaceWith(\n            function() {\n              return that.createRteElement(\n                componentDefn,\n                _createCustomizationArgDictFromAttrs(this.attributes));\n            }\n          );\n        });\n\n        return elt.html();\n      },\n      // Replace <img> tags with <oppia-noninteractive> tags.\n      convertRteToHtml: function(rte) {\n        // If an undefined or empty rte value is passed in, then the same type\n        // of value should be returned. Without this check,\n        // convertRteToHtml(undefined) would return \'undefined\', which is not\n        // ideal.\n        if (!rte) {\n          return rte;\n        }\n\n        var elt = $(\'<div>\' + rte + \'</div>\');\n\n        _RICH_TEXT_COMPONENTS.forEach(function(componentDefn) {\n          elt.find(\n            \'img.oppia-noninteractive-\' + componentDefn.id\n          ).replaceWith(function() {\n            // Look for a class name starting with oppia-noninteractive-*.\n            var tagNameMatch = /(^|\\s)(oppia-noninteractive-[a-z0-9\\-]+)/.exec(\n              this.className);\n            if (!tagNameMatch) {\n              $log.error(\'RTE Error: invalid class name \' + this.className);\n            }\n            var jQueryElt = $(\'<\' + tagNameMatch[2] + \'/>\');\n            for (var i = 0; i < this.attributes.length; i++) {\n              var attr = this.attributes[i];\n              // The exploration-id-with-value attribute was added in\n              // createRteElement(), and should be stripped. See commit\n              // 19a934ce20d592a3fc46bd97a2f05f41d33e3d66.\n              if (attr.name !== \'class\' && attr.name !== \'src\' &&\n                attr.name !== \'exploration-id-with-value\') {\n                jQueryElt.attr(attr.name, attr.value);\n              }\n            }\n            return jQueryElt.get(0);\n          });\n        });\n\n        var textElt = elt[0].childNodes;\n        for (var i = textElt.length; i > 0; i--) {\n          for (var j = textElt[i - 1].childNodes.length; j > 0; j--) {\n            if (textElt[i - 1].childNodes[j - 1].nodeName === \'BR\' ||\n              (textElt[i - 1].childNodes[j - 1].nodeName === \'#text\' &&\n                textElt[i - 1].childNodes[j - 1].nodeValue.trim() === \'\')) {\n              textElt[i - 1].childNodes[j - 1].remove();\n            } else {\n              break;\n            }\n          }\n          if (textElt[i - 1].childNodes.length === 0) {\n            if (textElt[i - 1].nodeName === \'BR\' ||\n              (textElt[i - 1].nodeName === \'#text\' &&\n                textElt[i - 1].nodeValue.trim() === \'\') ||\n                textElt[i - 1].nodeName === \'P\') {\n              textElt[i - 1].remove();\n              continue;\n            }\n          } else {\n            break;\n          }\n        }\n\n        return elt.html();\n      },\n      getRichTextComponents: function() {\n        return angular.copy(_RICH_TEXT_COMPONENTS);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/editor/undo_redo/ChangeObjectFactorySpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Tests for ChangeObjectFactory.\n */\n\ndescribe(\'Factory for Change domain objects\', function() {\n  var ChangeObjectFactory = null;\n\n  beforeEach(module(\'oppia\'));\n\n  beforeEach(inject(function($injector) {\n    ChangeObjectFactory = $injector.get(\'ChangeObjectFactory\');\n  }));\n\n  it(\'should invoke no callbacks after creation\', function() {\n    var applyFunc = jasmine.createSpy(\'applyChange\');\n    var reverseFunc = jasmine.createSpy(\'reverseChange\');\n\n    var backendChangeObject = {\n      property_name: \'value\'\n    };\n    ChangeObjectFactory.create(backendChangeObject, applyFunc, reverseFunc);\n\n    expect(applyFunc).not.toHaveBeenCalled();\n    expect(reverseFunc).not.toHaveBeenCalled();\n  });\n\n  it(\'should invoke the apply callback when applied\', function() {\n    var applyFunc = jasmine.createSpy(\'applyChange\');\n    var reverseFunc = jasmine.createSpy(\'reverseChange\');\n\n    var backendChangeObject = {\n      property_name: \'value\'\n    };\n    var changeDomainObject = ChangeObjectFactory.create(\n      backendChangeObject, applyFunc, reverseFunc);\n\n    var fakeDomainObject = {\n      domain_property_name: \'fake value\'\n    };\n    changeDomainObject.applyChange(fakeDomainObject);\n\n    expect(applyFunc).toHaveBeenCalledWith(\n      backendChangeObject, fakeDomainObject);\n    expect(reverseFunc).not.toHaveBeenCalled();\n  });\n\n  it(\'should invoke the reverse callback when reversed\', function() {\n    var applyFunc = jasmine.createSpy(\'applyChange\');\n    var reverseFunc = jasmine.createSpy(\'reverseChange\');\n\n    var backendChangeObject = {\n      property_name: \'value\'\n    };\n    var changeDomainObject = ChangeObjectFactory.create(\n      backendChangeObject, applyFunc, reverseFunc);\n\n    var fakeDomainObject = {\n      domain_property_name: \'fake value\'\n    };\n    changeDomainObject.reverseChange(fakeDomainObject);\n\n    expect(reverseFunc).toHaveBeenCalledWith(\n      backendChangeObject, fakeDomainObject);\n    expect(applyFunc).not.toHaveBeenCalled();\n  });\n\n  it(\'should not receive changes to the provided change backend object\',\n    function() {\n      var backendChangeObject = {\n        property_name: \'value\'\n      };\n      var changeDomainObject = ChangeObjectFactory.create(\n        backendChangeObject, function() {}, function() {});\n\n      var returnedBackendObject = changeDomainObject.getBackendChangeObject();\n      returnedBackendObject.property_name = \'new value\';\n\n      expect(changeDomainObject.getBackendChangeObject()).toEqual({\n        property_name: \'value\'\n      });\n    }\n  );\n});'

blocks = {}
debug_info = ''
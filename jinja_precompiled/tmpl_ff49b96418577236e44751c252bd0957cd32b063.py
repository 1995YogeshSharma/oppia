from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/PretestEngineService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utility service for the pretests for an exploration.\n */\n\noppia.constant(\'INTERACTION_SPECS\', GLOBALS.INTERACTION_SPECS);\n\noppia.factory(\'PretestEngineService\', [\n  \'$http\', \'$rootScope\', \'$q\', \'AlertsService\', \'AnswerClassificationService\',\n  \'ContextService\', \'ExplorationHtmlFormatterService\',\n  \'ExpressionInterpolationService\', \'INTERACTION_SPECS\',\n  \'QuestionObjectFactory\', \'INTERACTION_DISPLAY_MODE_INLINE\',\n  function(\n      $http, $rootScope, $q, AlertsService, AnswerClassificationService,\n      ContextService, ExplorationHtmlFormatterService,\n      ExpressionInterpolationService, INTERACTION_SPECS,\n      QuestionObjectFactory, INTERACTION_DISPLAY_MODE_INLINE) {\n    var _explorationId = ContextService.getExplorationId();\n\n    var version = GLOBALS.explorationVersion;\n\n    var answerIsBeingProcessed = false;\n\n    var pretestQuestions = [];\n\n    var currentIndex = null;\n    var nextIndex = null;\n\n    var randomFromArray = function(arr) {\n      return arr[Math.floor(Math.random() * arr.length)];\n    };\n\n    // Evaluate feedback.\n    var makeFeedback = function(feedbackHtml, envs) {\n      return ExpressionInterpolationService.processHtml(feedbackHtml, envs);\n    };\n\n    // Evaluate question string.\n    var makeQuestion = function(newState, envs) {\n      return ExpressionInterpolationService.processHtml(\n        newState.content.getHtml(), envs);\n    };\n\n    // This should only be called when \'exploration\' is non-null.\n    var _loadInitialQuestion = function(successCallback) {\n      var initialState = pretestQuestions[0].getStateData();\n\n      var questionHtml = makeQuestion(initialState, []);\n      if (questionHtml === null) {\n        AlertsService.addWarning(\'Expression parsing error.\');\n        return;\n      }\n\n      currentIndex = 0;\n      nextIndex = 0;\n      successCallback(null, questionHtml);\n    };\n\n    var _getCurrentStateData = function() {\n      return pretestQuestions[currentIndex].getStateData();\n    };\n\n    var _getNextStateData = function() {\n      return pretestQuestions[nextIndex].getStateData();\n    };\n\n    return {\n      /**\n       * Initializes the pretests for an exploration, passing the data for the\n       * first question to successCallback.\n       *\n       *\n       * @param {function} successCallback - The function to execute after the\n       *   pretest question data is successfully loaded. This function will\n       *   be passed two arguments:\n       *   - initHtml {string}, an HTML string representing the content of the\n       *       first state.\n       */\n      init: function(pretestQuestionDicts, successCallback) {\n        answerIsBeingProcessed = false;\n        for (var i = 0; i < pretestQuestionDicts.length; i++) {\n          pretestQuestions.push(\n            QuestionObjectFactory.createFromBackendDict(pretestQuestionDicts[i])\n          );\n        }\n        _loadInitialQuestion(successCallback);\n      },\n      recordNewCardAdded: function() {\n        currentIndex = nextIndex;\n      },\n      getPretestQuestionCount: function() {\n        return pretestQuestions.length;\n      },\n      getExplorationId: function() {\n        return _explorationId;\n      },\n      getExplorationVersion: function() {\n        return version;\n      },\n      getStateContentHtml: function() {\n        return _getCurrentStateData().content.getHtml();\n      },\n      getStateContentAudioTranslations: function() {\n        return null;\n      },\n      isContentAudioTranslationAvailable: function() {\n        return false;\n      },\n      getCurrentInteractionHtml: function(labelForFocusTarget) {\n        var interactionId = _getCurrentStateData().interaction.id;\n        if (!interactionId) {\n          return null;\n        }\n\n        return ExplorationHtmlFormatterService.getInteractionHtml(\n          interactionId,\n          _getCurrentStateData().interaction.customizationArgs,\n          true,\n          labelForFocusTarget);\n      },\n      getNextInteractionHtml: function(labelForFocusTarget) {\n        var interactionId = _getNextStateData().interaction.id;\n\n        return ExplorationHtmlFormatterService.getInteractionHtml(\n          interactionId,\n          _getNextStateData().interaction.customizationArgs,\n          true,\n          labelForFocusTarget);\n      },\n      getCurrentInteraction: function() {\n        return _getCurrentStateData().interaction;\n      },\n      isInteractionInline: function() {\n        var interactionId = _getCurrentStateData().interaction.id;\n        return (\n          !interactionId ||\n          INTERACTION_SPECS[interactionId].display_mode ===\n            INTERACTION_DISPLAY_MODE_INLINE);\n      },\n      isNextInteractionInline: function() {\n        var interactionId = _getNextStateData().interaction.id;\n        return (\n          !interactionId ||\n          INTERACTION_SPECS[interactionId].display_mode ===\n            INTERACTION_DISPLAY_MODE_INLINE);\n      },\n      getCurrentInteractionInstructions: function() {\n        var interactionId = _getCurrentStateData().interaction.id;\n        return (\n          interactionId ? INTERACTION_SPECS[interactionId].instructions : \'\');\n      },\n      getNextInteractionInstructions: function() {\n        var interactionId = _getNextStateData().interaction.id;\n        return (\n          interactionId ? INTERACTION_SPECS[interactionId].instructions : \'\');\n      },\n      getNextInteraction: function() {\n        return _getNextStateData().interaction;\n      },\n      isCurrentStateTerminal: function() {\n        var interactionId = _getCurrentStateData().interaction.id;\n        return (\n          interactionId && INTERACTION_SPECS[interactionId].is_terminal);\n      },\n      isNextStateTerminal: function() {\n        var interactionId = _getNextStateData().interaction.id;\n        return (\n          interactionId && INTERACTION_SPECS[interactionId].is_terminal);\n      },\n      isStateShowingConceptCard: function() {\n        return false;\n      },\n      getLanguageCode: function() {\n        return pretestQuestions[currentIndex].getLanguageCode();\n      },\n      getHints: function() {\n        return _getCurrentStateData().interaction.hints;\n      },\n      doesInteractionSupportHints: function() {\n        return (\n          !INTERACTION_SPECS[\n            _getCurrentStateData().interaction.id].is_terminal &&\n          !INTERACTION_SPECS[_getCurrentStateData().interaction.id].is_linear);\n      },\n      getSolution: function() {\n        return _getCurrentStateData().interaction.solution;\n      },\n      getContentIdsToAudioTranslations: function() {\n        return _getCurrentStateData().contentIdsToAudioTranslations;\n      },\n      isInPreviewMode: function() {\n        return false;\n      },\n      submitAnswer: function(answer, interactionRulesService, successCallback) {\n        if (answerIsBeingProcessed) {\n          return;\n        }\n\n        answerIsBeingProcessed = true;\n        var oldIndex = currentIndex;\n        var oldState = _getCurrentStateData();\n        var contentIdsToAudioTranslations =\n          oldState.contentIdsToAudioTranslations;\n        var classificationResult = (\n          AnswerClassificationService.getMatchingClassificationResult(\n            null, oldState.interaction, answer,\n            interactionRulesService));\n        var answerIsCorrect = classificationResult.outcome.labelledAsCorrect;\n\n        // Use angular.copy() to clone the object\n        // since classificationResult.outcome points\n        // at oldState.interaction.default_outcome\n        var outcome = angular.copy(classificationResult.outcome);\n        // Compute the data for the next state.\n        var oldParams = {};\n        oldParams.answer = answer;\n        var feedbackHtml =\n          makeFeedback(outcome.feedback.getHtml(), [oldParams]);\n        var feedbackContentId = outcome.feedback.getContentId();\n        var feedbackAudioTranslations =\n          contentIdsToAudioTranslations.getBindableAudioTranslations(\n            feedbackContentId);\n        if (feedbackHtml === null) {\n          answerIsBeingProcessed = false;\n          AlertsService.addWarning(\'Expression parsing error.\');\n          return;\n        }\n\n        if (answerIsCorrect && (currentIndex < pretestQuestions.length - 1)) {\n          newState = pretestQuestions[currentIndex + 1].getStateData();\n        } else {\n          newState = oldState;\n        }\n\n        var questionHtml = makeQuestion(newState, [oldParams, {\n          answer: \'answer\'\n        }]);\n        if (questionHtml === null) {\n          answerIsBeingProcessed = false;\n          AlertsService.addWarning(\'Expression parsing error.\');\n          return;\n        }\n        answerIsBeingProcessed = false;\n\n        var refreshInteraction = (\n          answerIsCorrect || this.isInteractionInline());\n\n        nextIndex = currentIndex + 1;\n        var isFinalQuestion = (nextIndex === pretestQuestions.length);\n        var onSameCard = !answerIsCorrect;\n\n        successCallback(\n          nextIndex, refreshInteraction, feedbackHtml,\n          feedbackAudioTranslations, questionHtml, oldParams,\n          null, null, onSameCard, null, null, isFinalQuestion);\n        return answerIsCorrect;\n      },\n      isAnswerBeingProcessed: function() {\n        return answerIsBeingProcessed;\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
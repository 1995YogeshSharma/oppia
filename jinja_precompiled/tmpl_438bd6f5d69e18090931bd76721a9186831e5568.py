from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'services/SearchService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview search service for activityTilesInfinityGrid\n */\n\noppia.constant(\'SEARCH_DATA_URL\', \'/searchhandler/data\');\n\noppia.factory(\'SearchService\', [\n  \'$http\', \'$rootScope\', \'$log\', \'$translate\', \'SEARCH_DATA_URL\',\n  function($http, $rootScope, $log, $translate, SEARCH_DATA_URL) {\n    var _lastQuery = null;\n    var _lastSelectedCategories = {};\n    var _lastSelectedLanguageCodes = {};\n    var _searchCursor = null;\n\n    // Appends a suffix to the query describing allowed category and language\n    // codes to filter on.\n    var _getSuffixForQuery =\n      function(selectedCategories, selectedLanguageCodes) {\n        var querySuffix = \'\';\n\n        var _categories = \'\';\n        for (var key in selectedCategories) {\n          if (selectedCategories[key]) {\n            if (_categories) {\n              _categories += \'" OR "\';\n            }\n            _categories += key;\n          }\n        }\n        if (_categories) {\n          querySuffix += \'&category=("\' + _categories + \'")\';\n        }\n\n        var _languageCodes = \'\';\n        for (var key in selectedLanguageCodes) {\n          if (selectedLanguageCodes[key]) {\n            if (_languageCodes) {\n              _languageCodes += \'" OR "\';\n            }\n            _languageCodes += key;\n          }\n        }\n        if (_languageCodes) {\n          querySuffix += \'&language_code=("\' + _languageCodes + \'")\';\n        }\n\n        return querySuffix;\n      };\n\n    var hasReachedEndOfPage = function() {\n      return _searchCursor === null;\n    };\n\n    var updateSearchFields = function(\n        itemsType, urlComponent, selectionDetails) {\n      var itemCodeGroup = urlComponent.match(/=\\("[A-Za-z%20" ]+"\\)/);\n      var itemCodes = itemCodeGroup ? itemCodeGroup[0] : null;\n\n      var EXPECTED_PREFIX = \'=("\';\n      var EXPECTED_SUFFIX = \'")\';\n\n      if (!itemCodes ||\n          itemCodes.indexOf(EXPECTED_PREFIX) !== 0 ||\n          itemCodes.lastIndexOf(EXPECTED_SUFFIX) !==\n            itemCodes.length - EXPECTED_SUFFIX.length) {\n        throw Error(\'Invalid search query url fragment for \' +\n                    itemsType + \': \' + urlComponent);\n      }\n\n      var items = itemCodes.substring(\n        EXPECTED_PREFIX.length, itemCodes.length - EXPECTED_SUFFIX.length\n      ).split(\'" OR "\');\n\n      var selections = selectionDetails[itemsType].selections;\n      for (var i = 0; i < items.length; i++) {\n        selections[items[i]] = true;\n      }\n    };\n\n    var _isCurrentlyFetchingResults = false;\n    var numSearchesInProgress = 0;\n\n    var getQueryUrl = function(searchUrlQueryString) {\n      return SEARCH_DATA_URL + \'?q=\' + searchUrlQueryString;\n    };\n\n    return {\n      getSearchUrlQueryString: function(searchQuery, selectedCategories,\n          selectedLanguageCodes) {\n        return encodeURIComponent(searchQuery) +\n          _getSuffixForQuery(selectedCategories, selectedLanguageCodes);\n      },\n      // Note that an empty query results in all activities being shown.\n      executeSearchQuery: function(\n          searchQuery, selectedCategories, selectedLanguageCodes,\n          successCallback) {\n        var queryUrl = getQueryUrl(\n          this.getSearchUrlQueryString(\n            searchQuery, selectedCategories, selectedLanguageCodes));\n\n        _isCurrentlyFetchingResults = true;\n        numSearchesInProgress++;\n        $http.get(queryUrl).then(function(response) {\n          var data = response.data;\n          _lastQuery = searchQuery;\n          _lastSelectedCategories = angular.copy(selectedCategories);\n          _lastSelectedLanguageCodes = angular.copy(selectedLanguageCodes);\n          _searchCursor = data.search_cursor;\n          numSearchesInProgress--;\n\n          $rootScope.$broadcast(\n            \'initialSearchResultsLoaded\', data.activity_list);\n          _isCurrentlyFetchingResults = false;\n          var checkMismatch = function(searchQuery) {\n            var isMismatch = true;\n            $(\'.oppia-search-bar-input\').each(function(index) {\n              if ($(this).val().trim() === searchQuery) {\n                isMismatch = false;\n              }\n            });\n            return isMismatch;\n          };\n          if (checkMismatch(searchQuery)) {\n            $log.error(\'Mismatch\');\n            $log.error(\'SearchQuery: \' + searchQuery);\n            $log.error(\'Input: \' + $(\'.oppia-search-bar-input\').val().trim());\n          }\n        }, function() {\n          numSearchesInProgress--;\n        });\n\n        // Translate the new explorations loaded.\n        $translate.refresh();\n\n        if (successCallback) {\n          successCallback();\n        }\n      },\n      isSearchInProgress: function() {\n        return numSearchesInProgress > 0;\n      },\n      // The following takes in the url search component as an argument and the\n      // selectionDetails. It will update selectionDetails with the relevant\n      // fields that were extracted from the url. It returns the unencoded\n      // search query string.\n      updateSearchFieldsBasedOnUrlQuery: function(\n          urlComponent, selectionDetails) {\n        var urlQuery = urlComponent.substring(\'?q=\'.length);\n        // The following will split the urlQuery into 3 components:\n        // 1. query\n        // 2. categories (optional)\n        // 3. language codes (default to \'en\')\n        var querySegments = urlQuery.split(\'&\');\n\n        if (querySegments.length > 3) {\n          throw Error(\'Invalid search query url: \' + urlQuery);\n        }\n\n        for (var i = 1; i < querySegments.length; i++) {\n          var urlComponent = decodeURIComponent(querySegments[i]);\n\n          var itemsType = null;\n          if (urlComponent.indexOf(\'category\') === 0) {\n            itemsType = \'categories\';\n          } else if (urlComponent.indexOf(\'language_code\') === 0) {\n            itemsType = \'languageCodes\';\n          } else {\n            console.error(\'Invalid search query component: \' + urlComponent);\n            continue;\n          }\n\n          try {\n            updateSearchFields(itemsType, urlComponent, selectionDetails);\n          } catch (error) {\n            selectionDetails[itemsType].selections = {};\n            throw error;\n          }\n        }\n\n        return decodeURIComponent(querySegments[0]);\n      },\n      getCurrentUrlQueryString: function() {\n        return this.getSearchUrlQueryString(\n          _lastQuery, _lastSelectedCategories, _lastSelectedLanguageCodes);\n      },\n      loadMoreData: function(successCallback, failureCallback) {\n        // If a new query is still being sent, or the end of the page has been\n        // reached, do not fetch more results.\n        if (_isCurrentlyFetchingResults || hasReachedEndOfPage()) {\n          failureCallback(hasReachedEndOfPage());\n          return;\n        }\n\n        var queryUrl = getQueryUrl(this.getCurrentUrlQueryString());\n\n        if (_searchCursor) {\n          queryUrl += \'&cursor=\' + _searchCursor;\n        }\n\n        _isCurrentlyFetchingResults = true;\n        $http.get(queryUrl).then(function(response) {\n          _searchCursor = response.data.search_cursor;\n          _isCurrentlyFetchingResults = false;\n\n          if (successCallback) {\n            successCallback(response.data, hasReachedEndOfPage());\n          }\n        });\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
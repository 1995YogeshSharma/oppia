from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/StatsReportingService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Services for stats reporting.\n */\n\noppia.constant(\'STATS_EVENT_TYPES\', {\n  EVENT_TYPE_START_EXPLORATION: \'start\',\n  EVENT_TYPE_ACTUAL_START_EXPLORATION: \'actual_start\',\n  EVENT_TYPE_COMPLETE_EXPLORATION: \'complete\',\n  EVENT_TYPE_STATE_HIT: \'state_hit\',\n  EVENT_TYPE_STATE_COMPLETED: \'state_complete\',\n  EVENT_TYPE_ANSWER_SUBMITTED: \'answer_submitted\',\n  EVENT_TYPE_SOLUTION_HIT: \'solution_hit\',\n  EVENT_TYPE_LEAVE_FOR_REFRESHER_EXP: \'leave_for_refresher_exp\',\n});\n\noppia.constant(\'STATS_REPORTING_URLS\', {\n  ANSWER_SUBMITTED: \'/explorehandler/answer_submitted_event/<exploration_id>\',\n  EXPLORATION_COMPLETED: (\n    \'/explorehandler/exploration_complete_event/<exploration_id>\'),\n  EXPLORATION_MAYBE_LEFT: (\n    \'/explorehandler/exploration_maybe_leave_event/<exploration_id>\'),\n  EXPLORATION_STARTED: (\n    \'/explorehandler/exploration_start_event/<exploration_id>\'),\n  STATE_HIT: \'/explorehandler/state_hit_event/<exploration_id>\',\n  STATE_COMPLETED: \'/explorehandler/state_complete_event/<exploration_id>\',\n  EXPLORATION_ACTUALLY_STARTED: (\n    \'/explorehandler/exploration_actual_start_event/<exploration_id>\'),\n  SOLUTION_HIT: \'/explorehandler/solution_hit_event/<exploration_id>\',\n  LEAVE_FOR_REFRESHER_EXP: (\n    \'/explorehandler/leave_for_refresher_exp_event/<exploration_id>\'),\n  STATS_EVENTS: \'/explorehandler/stats_events/<exploration_id>\'\n});\n\noppia.factory(\'StatsReportingService\', [\n  \'$http\', \'$interval\', \'ContextService\', \'MessengerService\',\n  \'PlaythroughService\', \'siteAnalyticsService\', \'StopwatchObjectFactory\',\n  \'UrlInterpolationService\', \'DEFAULT_OUTCOME_CLASSIFICATION\',\n  \'PAGE_CONTEXT\', \'STATS_EVENT_TYPES\', \'STATS_REPORTING_URLS\',\n  function(\n      $http, $interval, ContextService, MessengerService,\n      PlaythroughService, siteAnalyticsService, StopwatchObjectFactory,\n      UrlInterpolationService, DEFAULT_OUTCOME_CLASSIFICATION,\n      PAGE_CONTEXT, STATS_EVENT_TYPES, STATS_REPORTING_URLS) {\n    var explorationId = null;\n    var explorationTitle = null;\n    var explorationVersion = null;\n    var sessionId = null;\n    var stateStopwatch = null;\n    var optionalCollectionId = undefined;\n    var statesVisited = {};\n    var numStatesVisited = 0;\n    var explorationStarted = false;\n    var explorationActuallyStarted = false;\n    var explorationIsComplete = false;\n\n    var _editorPreviewMode = ContextService.isInExplorationEditorPage();\n\n    // The following dict will contain all stats data accumulated over the\n    // interval time and will be reset when the dict is sent to backend for\n    // recording.\n    var aggregatedStats = {};\n\n    var refreshAggregatedStats = function() {\n      aggregatedStats = {\n        num_starts: 0,\n        num_completions: 0,\n        num_actual_starts: 0,\n        state_stats_mapping: {}\n      };\n    };\n\n    var createDefaultStateStatsMapping = function(stateName) {\n      aggregatedStats.state_stats_mapping[stateName] = {\n        total_answers_count: 0,\n        useful_feedback_count: 0,\n        total_hit_count: 0,\n        first_hit_count: 0,\n        num_times_solution_viewed: 0,\n        num_completions: 0\n      };\n    };\n\n    var getFullStatsUrl = function(urlIdentifier) {\n      return UrlInterpolationService.interpolateUrl(\n        STATS_REPORTING_URLS[urlIdentifier], {\n          exploration_id: explorationId\n        });\n    };\n\n    if (!_editorPreviewMode) {\n      $interval(function() {\n        postStatsToBackend();\n      }, 300000);\n    }\n\n    // This method is called whenever a learner tries to leave an exploration,\n    // when a learner starts an exploration, when a learner completes an\n    // exploration and also every five minutes.\n    var postStatsToBackend = function() {\n      if (explorationIsComplete) {\n        return;\n      }\n      $http.post(getFullStatsUrl(\'STATS_EVENTS\'), {\n        aggregated_stats: aggregatedStats,\n        exp_version: explorationVersion\n      });\n      refreshAggregatedStats();\n    };\n\n    return {\n      initSession: function(\n          newExplorationId, newExplorationTitle, newExplorationVersion,\n          newSessionId, collectionId) {\n        explorationId = newExplorationId;\n        explorationTitle = newExplorationTitle;\n        explorationVersion = newExplorationVersion;\n        sessionId = newSessionId;\n        stateStopwatch = StopwatchObjectFactory.create();\n        optionalCollectionId = collectionId;\n        refreshAggregatedStats();\n      },\n      // Note that this also resets the stateStopwatch.\n      recordExplorationStarted: function(stateName, params) {\n        if (explorationStarted) {\n          return;\n        }\n        aggregatedStats.num_starts += 1;\n\n        createDefaultStateStatsMapping(stateName);\n        aggregatedStats.state_stats_mapping[stateName].total_hit_count += 1;\n        aggregatedStats.state_stats_mapping[stateName].first_hit_count += 1;\n\n        postStatsToBackend();\n\n        $http.post(getFullStatsUrl(\'EXPLORATION_STARTED\'), {\n          params: params,\n          session_id: sessionId,\n          state_name: stateName,\n          version: explorationVersion\n        });\n\n        $http.post(getFullStatsUrl(\'STATE_HIT\'), {\n          client_time_spent_in_secs: 0.0,\n          exploration_version: explorationVersion,\n          new_state_name: stateName,\n          old_params: params,\n          session_id: sessionId,\n        });\n\n        MessengerService.sendMessage(MessengerService.EXPLORATION_LOADED, {\n          explorationVersion: explorationVersion,\n          explorationTitle: explorationTitle\n        });\n\n        statesVisited[stateName] = true;\n        numStatesVisited = 1;\n        siteAnalyticsService.registerNewCard(1);\n\n        stateStopwatch.reset();\n        explorationStarted = true;\n      },\n      recordExplorationActuallyStarted: function(stateName) {\n        if (explorationActuallyStarted) {\n          return;\n        }\n        aggregatedStats.num_actual_starts += 1;\n        $http.post(getFullStatsUrl(\'EXPLORATION_ACTUALLY_STARTED\'), {\n          exploration_version: explorationVersion,\n          state_name: stateName,\n          session_id: sessionId\n        });\n\n        PlaythroughService.recordExplorationStartAction(stateName);\n        explorationActuallyStarted = true;\n      },\n      recordSolutionHit: function(stateName) {\n        if (!aggregatedStats.state_stats_mapping.hasOwnProperty(stateName)) {\n          createDefaultStateStatsMapping(stateName);\n        }\n        aggregatedStats.state_stats_mapping[\n          stateName].num_times_solution_viewed += 1;\n\n        $http.post(getFullStatsUrl(\'SOLUTION_HIT\'), {\n          exploration_version: explorationVersion,\n          state_name: stateName,\n          session_id: sessionId,\n          time_spent_in_state_secs: stateStopwatch.getTimeInSecs()\n        });\n      },\n      recordLeaveForRefresherExp: function(stateName, refresherExpId) {\n        $http.post(getFullStatsUrl(\'LEAVE_FOR_REFRESHER_EXP\'), {\n          exploration_version: explorationVersion,\n          refresher_exp_id: refresherExpId,\n          state_name: stateName,\n          session_id: sessionId,\n          time_spent_in_state_secs: stateStopwatch.getTimeInSecs()\n        });\n      },\n      // Note that this also resets the stateStopwatch.\n      recordStateTransition: function(\n          oldStateName, newStateName, answer, oldParams, isFirstHit) {\n        if (!aggregatedStats.state_stats_mapping.hasOwnProperty(newStateName)) {\n          createDefaultStateStatsMapping(newStateName);\n        }\n        aggregatedStats.state_stats_mapping[newStateName].total_hit_count += 1;\n        if (isFirstHit) {\n          aggregatedStats.state_stats_mapping[\n            newStateName].first_hit_count += 1;\n        }\n\n        $http.post(getFullStatsUrl(\'STATE_HIT\'), {\n          // This is the time spent since the last submission.\n          client_time_spent_in_secs: stateStopwatch.getTimeInSecs(),\n          exploration_version: explorationVersion,\n          new_state_name: newStateName,\n          old_params: oldParams,\n          session_id: sessionId,\n        });\n\n        // Broadcast information about the state transition to listeners.\n        MessengerService.sendMessage(MessengerService.STATE_TRANSITION, {\n          explorationVersion: explorationVersion,\n          jsonAnswer: JSON.stringify(answer),\n          newStateName: newStateName,\n          oldStateName: oldStateName,\n          paramValues: oldParams\n        });\n\n        if (!statesVisited.hasOwnProperty(newStateName)) {\n          statesVisited[newStateName] = true;\n          numStatesVisited++;\n          siteAnalyticsService.registerNewCard(numStatesVisited);\n        }\n\n        stateStopwatch.reset();\n      },\n      recordStateCompleted: function(stateName) {\n        if (!aggregatedStats.state_stats_mapping.hasOwnProperty(stateName)) {\n          createDefaultStateStatsMapping(stateName);\n        }\n        aggregatedStats.state_stats_mapping[stateName].num_completions += 1;\n\n        $http.post(getFullStatsUrl(\'STATE_COMPLETED\'), {\n          exp_version: explorationVersion,\n          state_name: stateName,\n          session_id: sessionId,\n          time_spent_in_state_secs: stateStopwatch.getTimeInSecs()\n        });\n      },\n      recordExplorationCompleted: function(stateName, params) {\n        aggregatedStats.num_completions += 1;\n        $http.post(getFullStatsUrl(\'EXPLORATION_COMPLETED\'), {\n          client_time_spent_in_secs: stateStopwatch.getTimeInSecs(),\n          collection_id: optionalCollectionId,\n          params: params,\n          session_id: sessionId,\n          state_name: stateName,\n          version: explorationVersion\n        });\n\n        MessengerService.sendMessage(MessengerService.EXPLORATION_COMPLETED, {\n          explorationVersion: explorationVersion,\n          paramValues: params\n        });\n\n        siteAnalyticsService.registerFinishExploration();\n\n        postStatsToBackend();\n        PlaythroughService.recordExplorationQuitAction(\n          stateName, stateStopwatch.getTimeInSecs());\n\n        PlaythroughService.recordPlaythrough(true);\n        explorationIsComplete = true;\n      },\n      recordAnswerSubmitted: function(\n          stateName, params, answer, answerGroupIndex, ruleIndex,\n          classificationCategorization, feedbackIsUseful) {\n        if (!aggregatedStats.state_stats_mapping.hasOwnProperty(stateName)) {\n          createDefaultStateStatsMapping(stateName);\n        }\n        aggregatedStats.state_stats_mapping[stateName].total_answers_count += 1;\n        if (feedbackIsUseful) {\n          aggregatedStats.state_stats_mapping[\n            stateName].useful_feedback_count += 1;\n        }\n        $http.post(getFullStatsUrl(\'ANSWER_SUBMITTED\'), {\n          answer: answer,\n          params: params,\n          version: explorationVersion,\n          session_id: sessionId,\n          client_time_spent_in_secs: stateStopwatch.getTimeInSecs(),\n          old_state_name: stateName,\n          answer_group_index: answerGroupIndex,\n          rule_spec_index: ruleIndex,\n          classification_categorization: classificationCategorization\n        });\n      },\n      recordMaybeLeaveEvent: function(stateName, params) {\n        $http.post(getFullStatsUrl(\'EXPLORATION_MAYBE_LEFT\'), {\n          client_time_spent_in_secs: stateStopwatch.getTimeInSecs(),\n          collection_id: optionalCollectionId,\n          params: params,\n          session_id: sessionId,\n          state_name: stateName,\n          version: explorationVersion\n        });\n\n        postStatsToBackend();\n\n        PlaythroughService.recordExplorationQuitAction(\n          stateName, stateStopwatch.getTimeInSecs());\n        PlaythroughService.recordPlaythrough();\n      },\n      recordAnswerSubmitAction: function(\n          stateName, destStateName, interactionId, answer, feedback) {\n        PlaythroughService.recordAnswerSubmitAction(\n          stateName, destStateName, interactionId, answer, feedback,\n          stateStopwatch.getTimeInSecs());\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/skill_editor/SkillEditorStateServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n* @fileoverview Unit tests for SkillEditorStateService.js\n*/\n\ndescribe(\'Skill editor state service\', function() {\n  var SkillEditorStateService, $q, $rootScope,\n    SkillObjectFactory, SkillUpdateService;\n  var fakeEditableSkillBackendApiService = null;\n\n  var FakeEditableSkillBackendApiService = function() {\n    var self = {};\n\n    var _fetchOrUpdateSkill = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.newBackendSkillObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.newBackendSkillObject = {};\n    self.failure = null;\n    self.fetchSkill = _fetchOrUpdateSkill;\n    self.updateSkill = _fetchOrUpdateSkill;\n\n    return self;\n  };\n\n  var FakeSkillRightsBackendApiService = function() {\n    var self = {};\n\n    var _fetchSkillRights = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.backendSkillRightsObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.backendSkillRightsObject = {};\n    self.failure = null;\n    self.fetchSkillRights = _fetchSkillRights;\n\n    return self;\n  };\n\n  beforeEach(module(\'oppia\'));\n  beforeEach(module(\'oppia\', function($provide) {\n    fakeEditableSkillBackendApiService = (\n      new FakeEditableSkillBackendApiService());\n    $provide.value(\n      \'EditableSkillBackendApiService\',\n      [fakeEditableSkillBackendApiService][0]);\n\n    fakeSkillRightsBackendApiService = (\n      new FakeSkillRightsBackendApiService());\n    $provide.value(\n      \'SkillRightsBackendApiService\',\n      [fakeSkillRightsBackendApiService][0]);\n  }));\n\n  beforeEach(inject(function($injector) {\n    SkillEditorStateService = $injector.get(\n      \'SkillEditorStateService\');\n    SkillObjectFactory = $injector.get(\'SkillObjectFactory\');\n    SkillRightsObjectFactory = $injector.get(\'SkillRightsObjectFactory\');\n    SkillUpdateService = $injector.get(\'SkillUpdateService\');\n    $q = $injector.get(\'$q\');\n    $rootScope = $injector.get(\'$rootScope\');\n\n    var misconceptionDict1 = {\n      id: \'2\',\n      name: \'test name\',\n      notes: \'test notes\',\n      feedback: \'test feedback\'\n    };\n\n    var misconceptionDict2 = {\n      id: \'4\',\n      name: \'test name\',\n      notes: \'test notes\',\n      feedback: \'test feedback\'\n    };\n\n    var skillContentsDict = {\n      explanation: \'test explanation\',\n      worked_examples: [\'test worked_example 1\', \'test worked example 2\']\n    };\n\n    var skillDict = {\n      id: \'1\',\n      description: \'test description\',\n      misconceptions: [misconceptionDict1, misconceptionDict2],\n      skill_contents: skillContentsDict,\n      language_code: \'en\',\n      version: 3\n    };\n\n    skillRightsObject = {\n      skill_id: \'1\',\n      creator_id: \'0\',\n      skill_is_private: true,\n      can_edit_skill_description: true\n    };\n    fakeSkillRightsBackendApiService.backendSkillRightsObject = (\n      skillRightsObject);\n\n    fakeEditableSkillBackendApiService.newBackendSkillObject = skillDict;\n  }));\n\n  it(\'should request to load the skill from the backend\', function() {\n    spyOn(fakeEditableSkillBackendApiService, \'fetchSkill\').and.callThrough();\n    SkillEditorStateService.loadSkill(\'1\');\n    expect(fakeEditableSkillBackendApiService.fetchSkill)\n      .toHaveBeenCalled();\n  });\n\n  it(\'should track whether it is currently loading the skill\', function() {\n    expect(SkillEditorStateService.isLoadingSkill()).toBe(false);\n    SkillEditorStateService.loadSkill(\'1\');\n    expect(SkillEditorStateService.isLoadingSkill()).toBe(true);\n    $rootScope.$apply();\n    expect(SkillEditorStateService.isLoadingSkill()).toBe(false);\n  });\n\n  it(\'should indicate a collection is no longer loading after an error\',\n    function() {\n      expect(SkillEditorStateService.isLoadingSkill()).toBe(false);\n      fakeEditableSkillBackendApiService.failure = \'Internal 500 error\';\n      SkillEditorStateService.loadSkill(\'1\');\n      expect(SkillEditorStateService.isLoadingSkill()).toBe(true);\n      $rootScope.$apply();\n      expect(SkillEditorStateService.isLoadingSkill()).toBe(false);\n    });\n\n  it(\'should report that a skill has loaded through loadSkill()\', function() {\n    expect(SkillEditorStateService.hasLoadedSkill()).toBe(false);\n    var newSkill = SkillEditorStateService.loadSkill(\'1\');\n    expect(SkillEditorStateService.hasLoadedSkill()).toBe(false);\n    $rootScope.$apply();\n    expect(SkillEditorStateService.hasLoadedSkill()).toBe(true);\n  });\n\n  it(\'should return the last skill loaded as the same object\', function() {\n    var previousSkill = SkillEditorStateService.getSkill();\n    var expectedSkill = SkillObjectFactory.createFromBackendDict(\n      fakeEditableSkillBackendApiService.newBackendSkillObject);\n    expect(previousSkill).not.toEqual(expectedSkill);\n    SkillEditorStateService.loadSkill(\'1\');\n    $rootScope.$apply();\n    var actualSkill = SkillEditorStateService.getSkill();\n    expect(actualSkill).toEqual(expectedSkill);\n    expect(actualSkill).toBe(previousSkill);\n    expect(actualSkill).not.toBe(expectedSkill);\n  });\n\n  it(\'should fail to load a skill without first loading one\',\n    function() {\n      expect(function() {\n        SkillEditorStateService.saveSkill(\'commit message\');\n      }).toThrow();\n    });\n\n  it(\'should not save the skill if there are no pending changes\',\n    function() {\n      SkillEditorStateService.loadSkill(\'1\');\n      $rootScope.$apply();\n      expect(SkillEditorStateService.saveSkill(\n        \'commit message\')).toBe(false);\n    });\n\n  it(\'should be able to save the collection and pending changes\',\n    function() {\n      spyOn(fakeEditableSkillBackendApiService,\n        \'updateSkill\').and.callThrough();\n\n      SkillEditorStateService.loadSkill(\'1\');\n      SkillUpdateService.setSkillDescription(\n        SkillEditorStateService.getSkill(), \'new description\');\n      $rootScope.$apply();\n\n      expect(SkillEditorStateService.saveSkill(\n        \'commit message\')).toBe(true);\n      $rootScope.$apply();\n\n      var expectedId = \'1\';\n      var expectedVersion = 3;\n      var expectedCommitMessage = \'commit message\';\n      var updateSkillSpy = (\n        fakeEditableSkillBackendApiService.updateSkill);\n      expect(updateSkillSpy).toHaveBeenCalledWith(\n        expectedId, expectedVersion, expectedCommitMessage,\n        jasmine.any(Object));\n    });\n\n  it(\'should track whether it is currently saving the skill\',\n    function() {\n      SkillEditorStateService.loadSkill(\'1\');\n      SkillUpdateService.setSkillDescription(\n        SkillEditorStateService.getSkill(), \'new description\');\n      $rootScope.$apply();\n\n      expect(SkillEditorStateService.isSavingSkill()).toBe(false);\n      SkillEditorStateService.saveSkill(\'commit message\');\n      expect(SkillEditorStateService.isSavingSkill()).toBe(true);\n\n      $rootScope.$apply();\n      expect(SkillEditorStateService.isSavingSkill()).toBe(false);\n    });\n\n  it(\'should indicate a skill is no longer saving after an error\',\n    function() {\n      SkillEditorStateService.loadSkill(\'1\');\n      SkillUpdateService.setSkillDescription(\n        SkillEditorStateService.getSkill(), \'new description\');\n      $rootScope.$apply();\n\n      expect(SkillEditorStateService.isSavingSkill()).toBe(false);\n      fakeEditableSkillBackendApiService.failure = \'Internal 500 error\';\n\n      SkillEditorStateService.saveSkill(\'commit message\');\n      expect(SkillEditorStateService.isSavingSkill()).toBe(true);\n\n      $rootScope.$apply();\n      expect(SkillEditorStateService.isSavingSkill()).toBe(false);\n    });\n\n  it(\'should request to load the skill rights from the backend\',\n    function() {\n      spyOn(fakeSkillRightsBackendApiService, \'fetchSkillRights\')\n        .and.callThrough();\n\n      SkillEditorStateService.loadSkill(\'1\');\n      expect(fakeSkillRightsBackendApiService.fetchSkillRights)\n        .toHaveBeenCalled();\n    });\n\n  it(\'should initially return an interstitial skill rights object\', function() {\n    var skillRights = SkillEditorStateService.getSkillRights();\n    expect(skillRights.getSkillId()).toEqual(null);\n    expect(skillRights.getCreatorId()).toEqual(null);\n    expect(skillRights.isPrivate()).toEqual(true);\n    expect(skillRights.canEditSkillDescription()).toEqual(false);\n  });\n\n  it(\'should be able to set a new skill rights with an in-place copy\',\n    function() {\n      var previousSkillRights = SkillEditorStateService.getSkillRights();\n      var expectedSkillRights = SkillRightsObjectFactory.createFromBackendDict(\n        skillRightsObject);\n      expect(previousSkillRights).not.toEqual(expectedSkillRights);\n\n      SkillEditorStateService.setSkillRights(expectedSkillRights);\n\n      var actualSkillRights = SkillEditorStateService.getSkillRights();\n      expect(actualSkillRights).toEqual(expectedSkillRights);\n\n      expect(actualSkillRights).toBe(previousSkillRights);\n      expect(actualSkillRights).not.toBe(expectedSkillRights);\n    }\n  );\n});'

blocks = {}
debug_info = ''
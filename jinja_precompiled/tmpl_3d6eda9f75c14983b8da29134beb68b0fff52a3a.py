from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/exploration/ContentIdsToAudioTranslationsObjectFactorySpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for ContentIdsToAudioTranslations object factory.\n */\n\ndescribe(\'ContentIdsToAudioTranslations object factory\', function() {\n  beforeEach(module(\'oppia\', function($provide) {\n    $provide.value(\'LanguageUtilService\', {\n      getAudioLanguagesCount: function() {\n        return 2;\n      }\n    });\n  }));\n\n  describe(\'ContentIdsToAudioTranslationsObjectFactory\', function() {\n    var citatof = null;\n    var atof = null;\n    var citat = null;\n    var citatDict = {\n      content: {\n        en: {\n          filename: \'filename1.mp3\',\n          file_size_bytes: 100000,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename2.mp3\',\n          file_size_bytes: 11000,\n          needs_update: false\n        }\n      },\n      default_outcome: {\n        en: {\n          filename: \'filename3.mp3\',\n          file_size_bytes: 3000,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename4.mp3\',\n          file_size_bytes: 5000,\n          needs_update: false\n        }\n      },\n      feedback_1: {\n        en: {\n          filename: \'filename5.mp3\',\n          file_size_bytes: 2000,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename6.mp3\',\n          file_size_bytes: 9000,\n          needs_update: false\n        }\n      },\n      feedback_2: {\n        en: {\n          filename: \'filename7.mp3\',\n          file_size_bytes: 1000,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename8.mp3\',\n          file_size_bytes: 600,\n          needs_update: false\n        }\n      },\n      hint_1: {\n        en: {\n          filename: \'filename9.mp3\',\n          file_size_bytes: 104000,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename10.mp3\',\n          file_size_bytes: 1000,\n          needs_update: true\n        }\n      },\n      hint_2: {},\n      solution: {\n        en: {\n          filename: \'filename13.mp3\',\n          file_size_bytes: 15080,\n          needs_update: false\n        },\n        hi: {\n          filename: \'filename14.mp3\',\n          file_size_bytes: 10500,\n          needs_update: false\n        }\n      }\n    };\n\n    beforeEach(inject(function($injector) {\n      citatof = $injector.get(\'ContentIdsToAudioTranslationsObjectFactory\');\n      atof = $injector.get(\'AudioTranslationObjectFactory\');\n      citat = citatof.createFromBackendDict(citatDict);\n    }));\n\n    it(\'should get all content id\', function(){\n      var contentIdList = [\n        \'content\', \'default_outcome\', \'feedback_1\', \'feedback_2\', \'hint_1\',\n        \'hint_2\', \'solution\'];\n      expect(citat.getAllContentId()).toEqual(contentIdList);\n    });\n\n    it(\'should correctly get all bindable audio translations\', function() {\n      expect(citat.getBindableAudioTranslations(\'content\')).toEqual({\n        en: atof.createFromBackendDict({\n          filename: \'filename1.mp3\',\n          file_size_bytes: 100000,\n          needs_update: false\n        }),\n        hi: atof.createFromBackendDict({\n          filename: \'filename2.mp3\',\n          file_size_bytes: 11000,\n          needs_update: false\n        })\n      });\n    });\n\n    it(\'should get correct audio translation\', function() {\n      expect(citat.getAudioTranslation(\'hint_1\', \'en\')).toEqual(\n        atof.createFromBackendDict({\n          filename: \'filename9.mp3\',\n          file_size_bytes: 104000,\n          needs_update: false\n        }));\n    });\n\n    it(\'should make all audio needs update for a give content id\', function() {\n      citat.markAllAudioAsNeedingUpdate(\'content\');\n      expect(citat.getBindableAudioTranslations(\'content\')).toEqual({\n        en: atof.createFromBackendDict({\n          filename: \'filename1.mp3\',\n          file_size_bytes: 100000,\n          needs_update: true\n        }),\n        hi: atof.createFromBackendDict({\n          filename: \'filename2.mp3\',\n          file_size_bytes: 11000,\n          needs_update: true\n        })\n      });\n    });\n\n    it(\'should get all language code for a given content id\', function(){\n      var LanguageCodeList = [\'en\', \'hi\'];\n      expect(citat.getAudioLanguageCodes(\'hint_1\')).toEqual(LanguageCodeList);\n    });\n\n    it(\'should correctly check content id has audio translations\', function(){\n      expect(citat.hasAudioTranslations(\'content\')).toBe(true);\n      expect(citat.hasAudioTranslations(\'hint_2\')).toBe(false);\n    });\n\n    it(\'should correctly check content id has unflagged audio translations\',\n      function(){\n        expect(citat.hasUnflaggedAudioTranslations(\'content\')).toBe(true);\n        citat.markAllAudioAsNeedingUpdate(\'solution\');\n        expect(citat.hasUnflaggedAudioTranslations(\'solution\')).toBe(false);\n      });\n\n    it(\'should add a given content id\', function(){\n      citat.addContentId(\'feedback_3\');\n      expect(citat.getBindableAudioTranslations(\'feedback_3\')).toEqual({});\n      expect(function() {\n        citat.addContentId(\'content\');\n      }).toThrowError(\'Trying to add duplicate content id.\');\n    });\n\n    it(\'should delete a given content id\', function(){\n      citat.deleteContentId(\'feedback_1\');\n      var contentIdList = [\n        \'content\', \'default_outcome\', \'feedback_2\', \'hint_1\', \'hint_2\',\n        \'solution\'];\n      expect(citat.getAllContentId()).toEqual(contentIdList);\n      expect(function() {\n        citat.deleteContentId(\'feedback_3\');\n      }).toThrowError(\'Unable to find the given content id.\');\n    });\n\n    it(\'should delete all feedback content id\', function(){\n      citat.deleteAllFeedbackContentId();\n      var contentIdList = [\n        \'content\', \'default_outcome\', \'hint_1\', \'hint_2\', \'solution\'];\n      expect(citat.getAllContentId()).toEqual(contentIdList);\n    });\n\n    it(\'should check whether the text is fully translated\', inject(function() {\n      expect(citat.isFullyTranslated(\'content\')).toBe(true);\n      citat.deleteAudioTranslation(\'content\', \'hi\');\n      expect(citat.isFullyTranslated(\'content\')).toBe(false);\n      citat.deleteAudioTranslation(\'content\', \'en\');\n      expect(citat.isFullyTranslated(\'content\')).toBe(false);\n      expect(function() {\n        citat.deleteAudioTranslation(\'content\', \'hi-en\');\n      }).toThrowError(\n        \'Trying to remove non-existing translation for \' +\n        \'language code hi-en\');\n    }));\n\n    it(\'should add audio translation in a given content id\', function(){\n      citat.addAudioTranslation(\'hint_2\', \'en\', \'filename11.mp3\', 1000);\n      expect(citat.getBindableAudioTranslations(\'hint_2\')).toEqual({\n        en: atof.createFromBackendDict({\n          filename: \'filename11.mp3\',\n          file_size_bytes: 1000,\n          needs_update: false\n        })\n      });\n      expect(function() {\n        citat.addAudioTranslation(\'content\', \'en\', \'filename.mp3\', 1000);\n      }).toThrowError(\'Trying to add duplicate language code.\');\n    });\n\n    it(\'should delete audio translation in a given content id\', function(){\n      citat.deleteAudioTranslation(\'content\', \'hi\');\n      expect(citat.getBindableAudioTranslations(\'content\')).toEqual({\n        en: atof.createFromBackendDict({\n          filename: \'filename1.mp3\',\n          file_size_bytes: 100000,\n          needs_update: false\n        })\n      });\n    });\n\n    it(\'should delete all feedback audio translation\', function(){\n      var contentIdList = [\n        \'content\', \'default_outcome\', \'feedback_1\', \'feedback_2\', \'hint_1\',\n        \'hint_2\', \'solution\'];\n      expect(citat.getAllContentId()).toEqual(contentIdList);\n      citat.deleteAllFeedbackContentId();\n      expect(citat.getAllContentId()).toEqual([\n        \'content\', \'default_outcome\', \'hint_1\', \'hint_2\', \'solution\']);\n    });\n\n    it(\'should toggle needs update attribute in a given content id\', function(){\n      citat.toggleNeedsUpdateAttribute(\'content\', \'hi\');\n      expect(citat.getAudioTranslation(\'content\', \'hi\')).toEqual(\n        atof.createFromBackendDict({\n          filename: \'filename2.mp3\',\n          file_size_bytes: 11000,\n          needs_update: true\n        }));\n    });\n\n    it(\'should correctly convert to backend dict\', function() {\n      expect(citat.toBackendDict()).toEqual(citatDict);\n    });\n  });\n});'

blocks = {}
debug_info = ''
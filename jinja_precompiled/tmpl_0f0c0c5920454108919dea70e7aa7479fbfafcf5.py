from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/state_editor/StateResponsesDirective.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directive for managing the state responses in the state editor.\n */\noppia.directive(\'stateResponses\', [\n  \'UrlInterpolationService\', function(UrlInterpolationService) {\n    return {\n      restrict: \'E\',\n      scope: {\n        addState: \'=\',\n        onResponsesInitialized: \'=\',\n        onSaveContentIdsToAudioTranslations: \'=\',\n        onSaveInteractionAnswerGroups: \'=\',\n        onSaveInteractionDefaultOutcome: \'=\',\n        navigateToState: \'=\',\n        refreshWarnings: \'&\'\n      },\n      templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n        \'/pages/state_editor/state_responses_directive.html\'),\n      controller: [\n        \'$scope\', \'$rootScope\', \'$uibModal\', \'$filter\',\n        \'StateInteractionIdService\', \'AlertsService\',\n        \'ResponsesService\', \'ContextService\',\n        \'EditabilityService\', \'StateEditorService\',\n        \'StateContentIdsToAudioTranslationsService\', \'INTERACTION_SPECS\',\n        \'StateCustomizationArgsService\', \'PLACEHOLDER_OUTCOME_DEST\',\n        \'UrlInterpolationService\', \'AnswerGroupObjectFactory\',\n        \'RULE_SUMMARY_WRAP_CHARACTER_COUNT\', function(\n            $scope, $rootScope, $uibModal, $filter,\n            StateInteractionIdService, AlertsService,\n            ResponsesService, ContextService,\n            EditabilityService, StateEditorService,\n            StateContentIdsToAudioTranslationsService, INTERACTION_SPECS,\n            StateCustomizationArgsService, PLACEHOLDER_OUTCOME_DEST,\n            UrlInterpolationService, AnswerGroupObjectFactory,\n            RULE_SUMMARY_WRAP_CHARACTER_COUNT) {\n          $scope.SHOW_TRAINABLE_UNRESOLVED_ANSWERS = (\n            GLOBALS.SHOW_TRAINABLE_UNRESOLVED_ANSWERS);\n          $scope.EditabilityService = EditabilityService;\n          $scope.stateName = StateEditorService.getActiveStateName();\n          $scope.dragDotsImgUrl = UrlInterpolationService.getStaticImageUrl(\n            \'/general/drag_dots.png\');\n\n          var _initializeTrainingData = function() {\n            if (StateEditorService.isInQuestionMode()) {\n              return;\n            }\n            var explorationId = ContextService.getExplorationId();\n            var currentStateName = $scope.stateName;\n          };\n\n          $scope.suppressDefaultAnswerGroupWarnings = function() {\n            var interactionId = $scope.getCurrentInteractionId();\n            var answerGroups = ResponsesService.getAnswerGroups();\n            // This array contains the text of each of the possible answers\n            // for the interaction.\n            var answerChoices = [];\n            var customizationArgs = StateCustomizationArgsService.savedMemento;\n            var handledAnswersArray = [];\n\n            if (interactionId === \'MultipleChoiceInput\') {\n              var numChoices = $scope.getAnswerChoices().length;\n              var choiceIndices = [];\n              // Collect all answers which have been handled by at least one\n              // answer group.\n              for (var i = 0; i < answerGroups.length; i++) {\n                for (var j = 0; j < answerGroups[i].rules.length; j++) {\n                  handledAnswersArray.push(answerGroups[i].rules[j].inputs.x);\n                }\n              }\n              for (var i = 0; i < numChoices; i++) {\n                choiceIndices.push(i);\n              }\n              // We only suppress the default warning if each choice index has\n              // been handled by at least one answer group.\n              return choiceIndices.every(function(choiceIndex) {\n                return handledAnswersArray.indexOf(choiceIndex) !== -1;\n              });\n            } else if (interactionId === \'ItemSelectionInput\') {\n              var maxSelectionCount = (\n                customizationArgs.maxAllowableSelectionCount.value);\n              if (maxSelectionCount === 1) {\n                var numChoices = $scope.getAnswerChoices().length;\n                // This array contains a list of booleans, one for each answer\n                // choice. Each boolean is true if the corresponding answer has\n                // been covered by at least one rule, and false otherwise.\n                handledAnswersArray = [];\n                for (var i = 0; i < numChoices; i++) {\n                  handledAnswersArray.push(false);\n                  answerChoices.push($scope.getAnswerChoices()[i].val);\n                }\n\n                var answerChoiceToIndex = {};\n                answerChoices.forEach(function(answerChoice, choiceIndex) {\n                  answerChoiceToIndex[answerChoice] = choiceIndex;\n                });\n\n                answerGroups.forEach(function(answerGroup) {\n                  var rules = answerGroup.rules;\n                  rules.forEach(function(rule) {\n                    var ruleInputs = rule.inputs.x;\n                    ruleInputs.forEach(function(ruleInput) {\n                      var choiceIndex = answerChoiceToIndex[ruleInput];\n                      if (rule.type === \'Equals\' ||\n                          rule.type === \'ContainsAtLeastOneOf\') {\n                        handledAnswersArray[choiceIndex] = true;\n                      } else if (rule.type ===\n                        \'DoesNotContainAtLeastOneOf\') {\n                        for (var i = 0; i < handledAnswersArray.length; i++) {\n                          if (i !== choiceIndex) {\n                            handledAnswersArray[i] = true;\n                          }\n                        }\n                      }\n                    });\n                  });\n                });\n\n                var areAllChoicesCovered = handledAnswersArray.every(\n                  function(handledAnswer) {\n                    return handledAnswer;\n                  });\n                // We only suppress the default warning if each choice text has\n                // been handled by at least one answer group, based on rule\n                // type.\n                return areAllChoicesCovered;\n              }\n            }\n          };\n\n          $scope.isSelfLoopWithNoFeedback = function(outcome) {\n            if (!outcome) {\n              return false;\n            }\n            return outcome.isConfusing($scope.stateName);\n          };\n\n          $scope.isSelfLoopThatIsMarkedCorrect = function(outcome) {\n            if (!outcome ||\n                !StateEditorService.getCorrectnessFeedbackEnabled()) {\n              return false;\n            }\n            var currentStateName = $scope.stateName;\n            return (\n              (outcome.dest === currentStateName) &&\n              outcome.labelledAsCorrect);\n          };\n\n          $scope.changeActiveAnswerGroupIndex = function(newIndex) {\n            $rootScope.$broadcast(\'externalSave\');\n            ResponsesService.changeActiveAnswerGroupIndex(newIndex);\n            $scope.activeAnswerGroupIndex = (\n              ResponsesService.getActiveAnswerGroupIndex());\n          };\n\n          $scope.getCurrentInteractionId = function() {\n            return StateInteractionIdService.savedMemento;\n          };\n\n          $scope.isCreatingNewState = function(outcome) {\n            return outcome && outcome.dest === PLACEHOLDER_OUTCOME_DEST;\n          };\n\n          // This returns false if the current interaction ID is null.\n          $scope.isCurrentInteractionLinear = function() {\n            var interactionId = $scope.getCurrentInteractionId();\n            return interactionId && INTERACTION_SPECS[interactionId].is_linear;\n          };\n\n          $scope.isLinearWithNoFeedback = function(outcome) {\n            // Returns false if current interaction is linear and has no\n            // feedback\n            if (!outcome) {\n              return false;\n            }\n            return $scope.isCurrentInteractionLinear() &&\n              !outcome.hasNonemptyFeedback();\n          };\n\n          $scope.getOutcomeTooltip = function(outcome) {\n            if ($scope.isSelfLoopThatIsMarkedCorrect(outcome)) {\n              return \'Self-loops should not be labelled as correct.\';\n            }\n\n            // Outcome tooltip depends on whether feedback is displayed\n            if ($scope.isLinearWithNoFeedback(outcome)) {\n              return \'Please direct the learner to a different card.\';\n            } else {\n              return \'Please give Oppia something useful to say,\' +\n                     \' or direct the learner to a different card.\';\n            }\n          };\n\n          $scope.$on(\'initializeAnswerGroups\', function(evt, data) {\n            ResponsesService.init(data);\n            $scope.answerGroups = ResponsesService.getAnswerGroups();\n            $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n\n            // If the creator selects an interaction which has only one possible\n            // answer, automatically expand the default response. Otherwise,\n            // default to having no responses initially selected.\n            if ($scope.isCurrentInteractionLinear()) {\n              ResponsesService.changeActiveAnswerGroupIndex(0);\n            }\n\n            // Initialize training data for these answer groups.\n            _initializeTrainingData();\n\n            $scope.activeAnswerGroupIndex = (\n              ResponsesService.getActiveAnswerGroupIndex());\n            $rootScope.$broadcast(\'externalSave\');\n          });\n\n          $scope.$on(\'onInteractionIdChanged\', function(\n              evt, newInteractionId) {\n            $rootScope.$broadcast(\'externalSave\');\n            ResponsesService.onInteractionIdChanged(\n              newInteractionId, function(newAnswerGroups, newDefaultOutcome) {\n                $scope.onSaveContentIdsToAudioTranslations(\n                  angular.copy(\n                    StateContentIdsToAudioTranslationsService.displayed));\n                $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n                $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n                $scope.refreshWarnings()();\n                $scope.answerGroups = ResponsesService.getAnswerGroups();\n                $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n\n                // Reinitialize training data if the interaction ID is changed.\n                _initializeTrainingData();\n\n                $scope.activeAnswerGroupIndex = (\n                  ResponsesService.getActiveAnswerGroupIndex());\n              });\n\n            // Prompt the user to create a new response if it is not a linear or\n            // non-terminal interaction and if an actual interaction is\n            // specified (versus one being deleted).\n            if (newInteractionId &&\n                !INTERACTION_SPECS[newInteractionId].is_linear &&\n                !INTERACTION_SPECS[newInteractionId].is_terminal) {\n              $scope.openAddAnswerGroupModal();\n            }\n          });\n\n          $scope.$on(\'answerGroupChanged\', function() {\n            $scope.answerGroups = ResponsesService.getAnswerGroups();\n            $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n            $scope.activeAnswerGroupIndex = (\n              ResponsesService.getActiveAnswerGroupIndex());\n          });\n\n          $scope.$on(\'updateAnswerChoices\', function(evt, newAnswerChoices) {\n            ResponsesService.updateAnswerChoices(\n              newAnswerChoices, function(newAnswerGroups) {\n                $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n                $scope.refreshWarnings()();\n              });\n          });\n\n          $scope.openAddAnswerGroupModal = function() {\n            AlertsService.clearWarnings();\n            $rootScope.$broadcast(\'externalSave\');\n            var stateName = StateEditorService.getActiveStateName();\n            var addState = $scope.addState;\n            $uibModal.open({\n              templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n                \'/pages/exploration_editor/editor_tab/\' +\n                \'add_answer_group_modal_directive.html\'),\n              // Clicking outside this modal should not dismiss it.\n              backdrop: \'static\',\n              controller: [\n                \'$scope\', \'$uibModalInstance\', \'ResponsesService\',\n                \'EditorFirstTimeEventsService\', \'StateEditorService\',\n                \'RuleObjectFactory\', \'OutcomeObjectFactory\',\n                \'COMPONENT_NAME_FEEDBACK\', \'GenerateContentIdService\',\n                function(\n                    $scope, $uibModalInstance, ResponsesService,\n                    EditorFirstTimeEventsService, StateEditorService,\n                    RuleObjectFactory, OutcomeObjectFactory,\n                    COMPONENT_NAME_FEEDBACK, GenerateContentIdService) {\n                  $scope.feedbackEditorIsOpen = false;\n                  $scope.addState = addState;\n                  $scope.questionModeEnabled =\n                    StateEditorService.isInQuestionMode();\n                  $scope.openFeedbackEditor = function() {\n                    $scope.feedbackEditorIsOpen = true;\n                  };\n                  $scope.tmpRule = RuleObjectFactory.createNew(null, {});\n                  var feedbackContentId = GenerateContentIdService.getNextId(\n                    COMPONENT_NAME_FEEDBACK);\n\n                  $scope.tmpOutcome = OutcomeObjectFactory.createNew(\n                    $scope.questionModeEnabled ? null : stateName,\n                    feedbackContentId, \'\', []);\n\n                  $scope.isSelfLoopWithNoFeedback = function(tmpOutcome) {\n                    return (\n                      tmpOutcome.dest ===\n                      stateName && !tmpOutcome.hasNonemptyFeedback());\n                  };\n\n                  $scope.addAnswerGroupForm = {};\n\n                  $scope.saveResponse = function(reopen) {\n                    $scope.$broadcast(\'saveOutcomeFeedbackDetails\');\n                    $scope.$broadcast(\'saveOutcomeDestDetails\');\n\n                    EditorFirstTimeEventsService.registerFirstSaveRuleEvent();\n\n                    // Close the modal and save it afterwards.\n                    $uibModalInstance.close({\n                      tmpRule: angular.copy($scope.tmpRule),\n                      tmpOutcome: angular.copy($scope.tmpOutcome),\n                      reopen: reopen\n                    });\n                  };\n\n                  $scope.cancel = function() {\n                    $uibModalInstance.dismiss(\'cancel\');\n                    AlertsService.clearWarnings();\n                  };\n                }\n              ]\n            }).result.then(function(result) {\n              // Create a new answer group.\n              $scope.answerGroups.push(AnswerGroupObjectFactory.createNew(\n                [result.tmpRule], result.tmpOutcome, [], null));\n              ResponsesService.save(\n                $scope.answerGroups, $scope.defaultOutcome,\n                function(newAnswerGroups, newDefaultOutcome) {\n                  $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n                  $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n                  $scope.refreshWarnings()();\n                });\n              StateContentIdsToAudioTranslationsService.displayed.addContentId(\n                result.tmpOutcome.feedback.getContentId());\n              StateContentIdsToAudioTranslationsService.saveDisplayedValue();\n              $scope.onSaveContentIdsToAudioTranslations(\n                StateContentIdsToAudioTranslationsService.displayed\n              );\n              $scope.changeActiveAnswerGroupIndex(\n                $scope.answerGroups.length - 1);\n\n              // After saving it, check if the modal should be reopened right\n              // away.\n              if (result.reopen) {\n                $scope.openAddAnswerGroupModal();\n              }\n            });\n          };\n\n          // When the page is scrolled so that the top of the page is above the\n          // browser viewport, there are some bugs in the positioning of the\n          // helper. This is a bug in jQueryUI that has not been fixed yet. For\n          // more details, see http://stackoverflow.com/q/5791886\n          $scope.ANSWER_GROUP_LIST_SORTABLE_OPTIONS = {\n            axis: \'y\',\n            cursor: \'move\',\n            handle: \'.oppia-rule-sort-handle\',\n            items: \'.oppia-sortable-rule-block\',\n            revert: 100,\n            tolerance: \'pointer\',\n            start: function(e, ui) {\n              $rootScope.$broadcast(\'externalSave\');\n              $scope.changeActiveAnswerGroupIndex(-1);\n              ui.placeholder.height(ui.item.height());\n            },\n            stop: function() {\n              ResponsesService.save(\n                $scope.answerGroups, $scope.defaultOutcome,\n                function(newAnswerGroups, newDefaultOutcome) {\n                  $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n                  $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n                  $scope.refreshWarnings()();\n                });\n            }\n          };\n\n          $scope.deleteAnswerGroup = function(index, evt) {\n            // Prevent clicking on the delete button from also toggling the\n            // display state of the answer group.\n            evt.stopPropagation();\n\n            AlertsService.clearWarnings();\n            $uibModal.open({\n              templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n                \'/pages/exploration_editor/editor_tab/\' +\n                \'delete_answer_group_modal_directive.html\'),\n              backdrop: true,\n              controller: [\n                \'$scope\', \'$uibModalInstance\', function(\n                    $scope, $uibModalInstance) {\n                  $scope.reallyDelete = function() {\n                    $uibModalInstance.close();\n                  };\n\n                  $scope.cancel = function() {\n                    $uibModalInstance.dismiss(\'cancel\');\n                    AlertsService.clearWarnings();\n                  };\n                }\n              ]\n            }).result.then(function() {\n              var deletedOutcome =\n                ResponsesService.getAnswerGroup(index).outcome;\n              ResponsesService.deleteAnswerGroup(\n                index, function(newAnswerGroups) {\n                  $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n                  $scope.refreshWarnings()();\n                });\n              var deletedFeedbackContentId =\n                deletedOutcome.feedback.getContentId();\n              StateContentIdsToAudioTranslationsService.\n                displayed.deleteContentId(deletedFeedbackContentId);\n              StateContentIdsToAudioTranslationsService.saveDisplayedValue();\n              $scope.onSaveContentIdsToAudioTranslations(\n                StateContentIdsToAudioTranslationsService.displayed\n              );\n            });\n          };\n\n          $scope.saveTaggedMisconception = function(misconceptionId) {\n            ResponsesService.updateActiveAnswerGroup({\n              taggedMisconceptionId: misconceptionId\n            }, function(newAnswerGroups) {\n              $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n              $scope.refreshWarnings()();\n            });\n          };\n\n          $scope.saveActiveAnswerGroupFeedback = function(updatedOutcome) {\n            ResponsesService.updateActiveAnswerGroup({\n              feedback: updatedOutcome.feedback\n            }, function(newAnswerGroups) {\n              $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n              $scope.refreshWarnings()();\n            });\n          };\n\n          $scope.saveActiveAnswerGroupDest = function(updatedOutcome) {\n            ResponsesService.updateActiveAnswerGroup({\n              dest: updatedOutcome.dest,\n              refresherExplorationId: updatedOutcome.refresherExplorationId,\n              missingPrerequisiteSkillId:\n                updatedOutcome.missingPrerequisiteSkillId\n            }, function(newAnswerGroups) {\n              $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n              $scope.refreshWarnings()();\n            });\n          };\n\n          $scope.saveActiveAnswerGroupCorrectnessLabel = function(\n              updatedOutcome) {\n            ResponsesService.updateActiveAnswerGroup({\n              labelledAsCorrect: updatedOutcome.labelledAsCorrect\n            }, function(newAnswerGroups) {\n              $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n              $scope.refreshWarnings()();\n            });\n          };\n\n          $scope.saveActiveAnswerGroupRules = function(updatedRules) {\n            ResponsesService.updateActiveAnswerGroup({\n              rules: updatedRules\n            }, function(newAnswerGroups) {\n              $scope.onSaveInteractionAnswerGroups(newAnswerGroups);\n              $scope.refreshWarnings()();\n            });\n          };\n\n          $scope.saveDefaultOutcomeFeedback = function(updatedOutcome) {\n            ResponsesService.updateDefaultOutcome({\n              feedback: updatedOutcome.feedback\n            }, function(newDefaultOutcome) {\n              $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n            });\n          };\n\n          $scope.saveDefaultOutcomeDest = function(updatedOutcome) {\n            ResponsesService.updateDefaultOutcome({\n              dest: updatedOutcome.dest,\n              refresherExplorationId: updatedOutcome.refresherExplorationId,\n              missingPrerequisiteSkillId:\n                updatedOutcome.missingPrerequisiteSkillId\n            }, function(newDefaultOutcome) {\n              $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n            });\n          };\n\n          $scope.saveDefaultOutcomeCorrectnessLabel = function(updatedOutcome) {\n            ResponsesService.updateDefaultOutcome({\n              labelledAsCorrect: updatedOutcome.labelledAsCorrect\n            }, function(newDefaultOutcome) {\n              $scope.onSaveInteractionDefaultOutcome(newDefaultOutcome);\n            });\n          };\n\n          $scope.getAnswerChoices = function() {\n            return ResponsesService.getAnswerChoices();\n          };\n\n          $scope.summarizeAnswerGroup = function(\n              answerGroup, interactionId, answerChoices, shortenRule) {\n            var summary = \'\';\n            var outcome = answerGroup.outcome;\n            var hasFeedback = outcome.hasNonemptyFeedback();\n\n            if (answerGroup.rules) {\n              var firstRule = $filter(\'convertToPlainText\')(\n                $filter(\'parameterizeRuleDescription\')(\n                  answerGroup.rules[0], interactionId, answerChoices));\n              summary = \'Answer \' + firstRule;\n\n              if (hasFeedback && shortenRule) {\n                summary = $filter(\'wrapTextWithEllipsis\')(\n                  summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n              }\n              summary = \'[\' + summary + \'] \';\n            }\n\n            if (hasFeedback) {\n              summary += (\n                shortenRule ?\n                  $filter(\'truncate\')(outcome.feedback.getHtml(), 30) :\n                  $filter(\'convertToPlainText\')(outcome.feedback.getHtml()));\n            }\n            return summary;\n          };\n\n          $scope.summarizeDefaultOutcome = function(\n              defaultOutcome, interactionId, answerGroupCount, shortenRule) {\n            if (!defaultOutcome) {\n              return \'\';\n            }\n\n            var summary = \'\';\n            var hasFeedback = defaultOutcome.hasNonemptyFeedback();\n\n            if (interactionId && INTERACTION_SPECS[interactionId].is_linear) {\n              summary =\n                INTERACTION_SPECS[interactionId].default_outcome_heading;\n            } else if (answerGroupCount > 0) {\n              summary = \'All other answers\';\n            } else {\n              summary = \'All answers\';\n            }\n\n            if (hasFeedback && shortenRule) {\n              summary = $filter(\'wrapTextWithEllipsis\')(\n                summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n            }\n            summary = \'[\' + summary + \'] \';\n\n            if (hasFeedback) {\n              summary +=\n                $filter(\n                  \'convertToPlainText\'\n                )(defaultOutcome.feedback.getHtml());\n            }\n            return summary;\n          };\n\n          $scope.isOutcomeLooping = function(outcome) {\n            var activeStateName = $scope.stateName;\n            return outcome && (outcome.dest === activeStateName);\n          };\n\n          if (StateEditorService.isInQuestionMode()) {\n            $scope.onResponsesInitialized();\n          }\n        }\n      ]\n    };\n  }]);'

blocks = {}
debug_info = ''
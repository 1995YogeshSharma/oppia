from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'expressions/ExpressionSyntaxTreeService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\noppia.factory(\'ExpressionSyntaxTreeService\', [\n  \'$log\', \'ExpressionParserService\', \'PARAMETER_TYPES\',\n  function($log, ExpressionParserService, PARAMETER_TYPES) {\n    // Exceptions that can be thrown from the evaluation of expressions.\n    var ExpressionError = function() {\n    };\n    ExpressionError.prototype = new Error();\n    ExpressionError.prototype.constructor = ExpressionError;\n\n    var ExprUndefinedVarError = function(varname, envs) {\n      this.varname = varname;\n      this.envs = envs;\n    };\n    ExprUndefinedVarError.prototype = new ExpressionError();\n    ExprUndefinedVarError.prototype.constructor = ExprUndefinedVarError;\n    ExprUndefinedVarError.prototype.name = \'ExprUndefinedVarError\';\n    ExprUndefinedVarError.prototype.toString = function() {\n      return this.name + \': \' + this.varname + \' not found in \' + this.envs;\n    };\n\n    var ExprWrongNumArgsError = function(args, expectedMin, expectedMax) {\n      this.args = args;\n      this.expectedMin = expectedMin;\n      this.expectedMax = expectedMax;\n    };\n    ExprWrongNumArgsError.prototype = new ExpressionError();\n    ExprWrongNumArgsError.prototype.constructor = ExprWrongNumArgsError;\n    ExprWrongNumArgsError.prototype.name = \'ExprWrongNumArgsError\';\n    ExprWrongNumArgsError.prototype.toString = function() {\n      return this.name + \': {\' + this.args + \'} not in range [\' +\n        this.expectedMin + \',\' + this.expectedMax + \']\';\n    };\n\n    var ExprWrongArgTypeError = function(arg, actualType, expectedType) {\n      this.arg = arg;\n      this.actualType = actualType;\n      this.expectedType = expectedType;\n    };\n    ExprWrongArgTypeError.prototype = new ExpressionError();\n    ExprWrongArgTypeError.prototype.constructor = ExprWrongArgTypeError;\n    ExprWrongArgTypeError.prototype.name = \'ExprWrongArgTypeError\';\n    ExprWrongArgTypeError.prototype.toString = function() {\n      if (this.arg === null) {\n        return this.name + \': Type \' + this.actualType +\n        \' does not match expected type \' + this.expectedType;\n      }\n      return this.name + \': \' + this.arg + \' has type \' + this.actualType +\n        \' which does not match expected type \' + this.expectedType;\n    };\n\n    var getParamsUsedInExpression = function(expression) {\n      var _findParams = function(parseTree) {\n        var paramsFound = [];\n\n        if (parseTree instanceof Array) {\n          if (parseTree[0] === \'#\') {\n            paramsFound.push(parseTree[1]);\n          } else {\n            for (var i = 1; i < parseTree.length; i++) {\n              paramsFound = paramsFound.concat(_findParams(parseTree[i]));\n            }\n          }\n        }\n\n        var uniqueParams = [];\n        for (var i = 0; i < paramsFound.length; i++) {\n          if (uniqueParams.indexOf(paramsFound[i]) === -1) {\n            uniqueParams.push(paramsFound[i]);\n          }\n        }\n\n        return uniqueParams.sort();\n      };\n\n      var parsed = ExpressionParserService.parse(expression);\n      return _findParams(parsed);\n    };\n\n    // Checks if the args array has the expectedNum number of elements and\n    // throws an error if not. If optional expectedMax is specified, it\n    // verifies the number of args is in [expectedNum, expectedMax] range\n    // inclusive.\n    var verifyNumArgs = function(args, expectedNum, expectedMax) {\n      if (expectedMax === undefined) {\n        expectedMax = expectedNum;\n      }\n      if (args.length >= expectedNum && args.length <= expectedMax) {\n        return;\n      }\n      throw new ExprWrongNumArgsError(args, expectedNum, expectedMax);\n    };\n\n    var _verifyArgTypesMatchExpectedType = function(argTypes, expectedType) {\n      for (var i = 0; i < argTypes.length; i++) {\n        if (argTypes[i] !== expectedType) {\n          throw new ExprWrongArgTypeError(null, argTypes[i], expectedType);\n        }\n      }\n      return true;\n    };\n\n    var _verifyArgTypesMatch = function(argType1, argType2) {\n      if (argType1 !== argType2) {\n        throw new ExprWrongArgTypeError(null, argType1, argType2);\n      }\n      return true;\n    };\n\n    var applyFunctionToParseTree = function(parsed, envs, func) {\n      return func(parsed, envs.concat(system));\n    };\n\n    /**\n     * Looks up a variable of the given name in the env. Here the variable\n     * can be system or user defined functions and parameters, as well as\n     * system operators.\n     * @param {string} name The name to look up.\n     * @param {!Array.<!Object>} envs Represents a nested name space\n     *     environment to look up the name in. The first element is looked up\n     *     first (i.e. has higher precedence).\n     * @throws {ExprUndefinedVarError} The named variable was not found in\n     *     the given environment.\n     */\n    var lookupEnvs = function(name, envs) {\n      // Parameter value look up.\n      var value;\n      if (envs.some(function(env) {\n        if (env.hasOwnProperty(name)) {\n          value = env[name];\n          return true;\n        }\n        return false;\n      })) {\n        return value;\n      }\n\n      throw new ExprUndefinedVarError(name, envs);\n    };\n\n    // Coerces the argument to a Number, and throws an error if the result\n    // is NaN.\n    var _coerceToNumber = function(originalValue) {\n      var coercedValue = (+originalValue);\n      if (!isNaN(coercedValue)) {\n        return coercedValue;\n      }\n      throw new ExprWrongArgTypeError(\n        originalValue, typeof originalValue, \'Number\');\n    };\n\n    // Coerces all values in the given argument array to Number, and throws\n    // an error if the result is NaN.\n    var _coerceAllArgsToNumber = function(args) {\n      for (var i = 0; i < args.length; i++) {\n        args[i] = _coerceToNumber(args[i]);\n      }\n      return args;\n    };\n\n    // NOTE TO DEVELOPERS: When adding a new reserved word to this object,\n    //   please first ensure that existing explorations do not use this\n    //   parameter name. Also, to prevent future explorations using it,\n    //   modify feconf.INVALID_PARAMETER_NAMES accordingly.\n    // TODO(kashida): Document all operators input and output contracts.\n    // Arguments:\n    // args: for eval(): list of values of the evaluated sub-expression\n    //       for getType(): list of types of the evaluated sub-expression\n\n    var system = {\n      \'+\': {\n        eval: function(args) {\n          verifyNumArgs(args, 1, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs.length === 1 ? numericArgs[0] :\n            numericArgs[0] + numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 1, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'-\': {\n        eval: function(args) {\n          verifyNumArgs(args, 1, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs.length === 1 ? -numericArgs[0] :\n            numericArgs[0] - numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 1, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'*\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] * numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'/\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] / numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'%\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] % numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'<=\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] <= numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'>=\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] >= numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'<\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] < numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'>\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return numericArgs[0] > numericArgs[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'!\': {\n        eval: function(args) {\n          verifyNumArgs(args, 1);\n          return !args[0];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 1);\n          _verifyArgTypesMatchExpectedType(\n            args, PARAMETER_TYPES.UNICODE_STRING);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'==\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          return args[0] === args[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'!=\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          return args[0] !== args[1];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'&&\': {\n        eval: function(args) {\n          // TODO(kashida): Make this short-circuit.\n          verifyNumArgs(args, 2);\n          return Boolean(args[0] && args[1]);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(\n            args, PARAMETER_TYPES.UNICODE_STRING);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      \'||\': {\n        eval: function(args) {\n          // TODO(kashida): Make this short-circuit.\n          verifyNumArgs(args, 2);\n          return Boolean(args[0] || args[1]);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(\n            args, PARAMETER_TYPES.UNICODE_STRING);\n          return PARAMETER_TYPES.UNICODE_STRING;\n        }\n      },\n      // Note that removing quotation marks from this key causes issues with\n      // minification (when running the deployment scripts).\n      /* eslint-disable quote-props */\n      \'if\': {\n        eval: function(args) {\n          // TODO(kashida): Make this short-circuit.\n          verifyNumArgs(args, 3);\n          return args[0] ? args[1] : args[2];\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 3);\n          _verifyArgTypesMatchExpectedType(\n            [args[0]], PARAMETER_TYPES.UNICODE_STRING);\n          _verifyArgTypesMatch(args[1], args[2]);\n          return args[1];\n        }\n      },\n      \'floor\': {\n        eval: function(args) {\n          verifyNumArgs(args, 1);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return Math.floor(numericArgs[0]);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 1);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'pow\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return Math.pow(args[0], args[1]);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'log\': {\n        eval: function(args) {\n          verifyNumArgs(args, 2);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          var preciseAns = Math.log(numericArgs[0]) / Math.log(numericArgs[1]);\n          // We round answers to 9 decimal places, so that we don\'t run into\n          // issues like log(9, 3) = 2.0000000000004.\n          return Math.round(preciseAns * Math.pow(10, 9)) / Math.pow(10, 9);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 2);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      },\n      \'abs\': {\n        eval: function(args) {\n          verifyNumArgs(args, 1);\n          var numericArgs = _coerceAllArgsToNumber(args);\n          return Math.abs(numericArgs[0]);\n        },\n        getType: function(args) {\n          verifyNumArgs(args, 1);\n          _verifyArgTypesMatchExpectedType(args, PARAMETER_TYPES.REAL);\n          return PARAMETER_TYPES.REAL;\n        }\n      }\n      /* eslint-enable quote-props */\n    };\n\n    return {\n      ExpressionError: ExpressionError,\n      ExprUndefinedVarError: ExprUndefinedVarError,\n      ExprWrongNumArgsError: ExprWrongNumArgsError,\n      ExprWrongArgTypeError: ExprWrongArgTypeError,\n      applyFunctionToParseTree: applyFunctionToParseTree,\n      getParamsUsedInExpression: getParamsUsedInExpression,\n      lookupEnvs: lookupEnvs\n    };\n  }\n]);'

blocks = {}
debug_info = ''
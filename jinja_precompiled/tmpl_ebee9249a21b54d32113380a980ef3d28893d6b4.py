from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/StateResponses.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controllers and filters for responses corresponding\n * to a state\'s interaction and answer groups.\n */\n\noppia.controller(\'StateResponses\', [\n  \'$scope\', \'$rootScope\', \'$uibModal\', \'$filter\', \'stateInteractionIdService\',\n  \'EditorStateService\', \'AlertsService\', \'ResponsesService\', \'RouterService\',\n  \'ExplorationContextService\', \'TrainingDataService\',\n  \'stateCustomizationArgsService\', \'PLACEHOLDER_OUTCOME_DEST\',\n  \'INTERACTION_SPECS\', \'UrlInterpolationService\', \'AnswerGroupObjectFactory\',\n  function(\n      $scope, $rootScope, $uibModal, $filter, stateInteractionIdService,\n      EditorStateService, AlertsService, ResponsesService, RouterService,\n      ExplorationContextService, TrainingDataService,\n      stateCustomizationArgsService, PLACEHOLDER_OUTCOME_DEST,\n      INTERACTION_SPECS, UrlInterpolationService, AnswerGroupObjectFactory) {\n    $scope.SHOW_TRAINABLE_UNRESOLVED_ANSWERS = (\n      GLOBALS.SHOW_TRAINABLE_UNRESOLVED_ANSWERS);\n    $scope.EditorStateService = EditorStateService;\n\n    $scope.dragDotsImgUrl = UrlInterpolationService.getStaticImageUrl(\n      \'/general/drag_dots.png\');\n\n    var _initializeTrainingData = function() {\n      var explorationId = ExplorationContextService.getExplorationId();\n      var currentStateName = EditorStateService.getActiveStateName();\n      TrainingDataService.initializeTrainingData(\n        explorationId, currentStateName);\n    };\n\n    $scope.suppressDefaultAnswerGroupWarnings = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      var answerGroups = ResponsesService.getAnswerGroups();\n      // This array contains the text of each of the possible answers\n      // for the interaction.\n      var answerChoices = [];\n      var customizationArgs = stateCustomizationArgsService.savedMemento;\n      var handledAnswersArray = [];\n\n      if (interactionId === \'MultipleChoiceInput\') {\n        var numChoices = $scope.getAnswerChoices().length;\n        var choiceIndices = [];\n        // Collect all answers which have been handled by at least one\n        // answer group.\n        for (var i = 0; i < answerGroups.length; i++) {\n          for (var j = 0; j < answerGroups[i].rules.length; j++) {\n            handledAnswersArray.push(answerGroups[i].rules[j].inputs.x);\n          }\n        }\n        for (var i = 0; i < numChoices; i++) {\n          choiceIndices.push(i);\n        }\n        // We only suppress the default warning if each choice index has\n        // been handled by at least one answer group.\n        return choiceIndices.every(function(choiceIndex) {\n          return handledAnswersArray.indexOf(choiceIndex) !== -1;\n        });\n      } else if (interactionId === \'ItemSelectionInput\') {\n        var maxSelectionCount = (\n          customizationArgs.maxAllowableSelectionCount.value);\n        if (maxSelectionCount === 1) {\n          var numChoices = $scope.getAnswerChoices().length;\n          // This array contains a list of booleans, one for each answer choice.\n          // Each boolean is true if the corresponding answer has been\n          // covered by at least one rule, and false otherwise.\n          handledAnswersArray = [];\n          for (var i = 0; i < numChoices; i++) {\n            handledAnswersArray.push(false);\n            answerChoices.push($scope.getAnswerChoices()[i].val);\n          }\n\n          var answerChoiceToIndex = {};\n          answerChoices.forEach(function(answerChoice, choiceIndex) {\n            answerChoiceToIndex[answerChoice] = choiceIndex;\n          });\n\n          answerGroups.forEach(function(answerGroup) {\n            var rules = answerGroup.rules;\n            rules.forEach(function(rule) {\n              var ruleInputs = rule.inputs.x;\n              ruleInputs.forEach(function(ruleInput) {\n                var choiceIndex = answerChoiceToIndex[ruleInput];\n                if (rule.type === \'Equals\' ||\n                    rule.type === \'ContainsAtLeastOneOf\') {\n                  handledAnswersArray[choiceIndex] = true;\n                } else if (rule.type ===\n                  \'DoesNotContainAtLeastOneOf\') {\n                  for (var i = 0; i < handledAnswersArray.length; i++) {\n                    if (i !== choiceIndex) {\n                      handledAnswersArray[i] = true;\n                    }\n                  }\n                }\n              });\n            });\n          });\n\n          var areAllChoicesCovered = handledAnswersArray.every(\n            function(handledAnswer) {\n              return handledAnswer;\n            });\n          // We only suppress the default warning if each choice text has\n          // been handled by at least one answer group, based on rule type.\n          return areAllChoicesCovered;\n        }\n      }\n    };\n\n    $scope.isSelfLoopWithNoFeedback = function(outcome) {\n      if (!outcome) {\n        return false;\n      }\n      return outcome.isConfusing(EditorStateService.getActiveStateName());\n    };\n\n    $scope.isSelfLoopThatIsMarkedCorrect = function(outcome) {\n      if (!outcome) {\n        return false;\n      }\n      var currentStateName = EditorStateService.getActiveStateName();\n      return ((outcome.dest === currentStateName) && outcome.labelledAsCorrect);\n    };\n\n    $scope.changeActiveAnswerGroupIndex = function(newIndex) {\n      $rootScope.$broadcast(\'externalSave\');\n      ResponsesService.changeActiveAnswerGroupIndex(newIndex);\n      $scope.activeAnswerGroupIndex = (\n        ResponsesService.getActiveAnswerGroupIndex());\n    };\n\n    $scope.getCurrentInteractionId = function() {\n      return stateInteractionIdService.savedMemento;\n    };\n\n    $scope.isCurrentInteractionTrainable = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      return (\n        interactionId &&\n        INTERACTION_SPECS[interactionId].is_trainable);\n    };\n\n    $scope.isCreatingNewState = function(outcome) {\n      return outcome && outcome.dest === PLACEHOLDER_OUTCOME_DEST;\n    };\n\n    // This returns false if the current interaction ID is null.\n    $scope.isCurrentInteractionLinear = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      return interactionId && INTERACTION_SPECS[interactionId].is_linear;\n    };\n\n    $scope.isLinearWithNoFeedback = function(outcome) {\n      // Returns false if current interaction is linear and has no feedback\n      if (!outcome) {\n        return false;\n      }\n      return $scope.isCurrentInteractionLinear() &&\n        !outcome.hasNonemptyFeedback();\n    };\n\n    $scope.getOutcomeTooltip = function(outcome) {\n      if ($scope.isSelfLoopThatIsMarkedCorrect(outcome)) {\n        return \'Self-loops should not be labelled as correct.\';\n      }\n\n      // Outcome tooltip depends on whether feedback is displayed\n      if ($scope.isLinearWithNoFeedback(outcome)) {\n        return \'Please direct the learner to a different card.\';\n      } else {\n        return \'Please give Oppia something useful to say,\' +\n               \' or direct the learner to a different card.\';\n      }\n    };\n\n    $scope.$on(\'initializeAnswerGroups\', function(evt, data) {\n      ResponsesService.init(data);\n      $scope.answerGroups = ResponsesService.getAnswerGroups();\n      $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n\n      // If the creator selects an interaction which has only one possible\n      // answer, automatically expand the default response. Otherwise, default\n      // to having no responses initially selected.\n      if ($scope.isCurrentInteractionLinear()) {\n        ResponsesService.changeActiveAnswerGroupIndex(0);\n      }\n\n      // Initialize training data for these answer groups.\n      _initializeTrainingData();\n\n      $scope.activeAnswerGroupIndex = (\n        ResponsesService.getActiveAnswerGroupIndex());\n      $rootScope.$broadcast(\'externalSave\');\n    });\n\n    $scope.$on(\'onInteractionIdChanged\', function(evt, newInteractionId) {\n      $rootScope.$broadcast(\'externalSave\');\n      ResponsesService.onInteractionIdChanged(newInteractionId, function() {\n        $scope.answerGroups = ResponsesService.getAnswerGroups();\n        $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n\n        // Reinitialize training data if the interaction ID is changed.\n        _initializeTrainingData();\n\n        $scope.activeAnswerGroupIndex = (\n          ResponsesService.getActiveAnswerGroupIndex());\n      });\n\n      // Prompt the user to create a new response if it is not a linear or\n      // non-terminal interaction and if an actual interaction is specified\n      // (versus one being deleted).\n      if (newInteractionId &&\n          !INTERACTION_SPECS[newInteractionId].is_linear &&\n          !INTERACTION_SPECS[newInteractionId].is_terminal) {\n        // Open the training interface if the interaction is trainable,\n        // otherwise open the answer group modal.\n        if (GLOBALS.SHOW_TRAINABLE_UNRESOLVED_ANSWERS &&\n            $scope.isCurrentInteractionTrainable()) {\n          $scope.openTeachOppiaModal();\n        } else {\n          $scope.openAddAnswerGroupModal();\n        }\n      }\n    });\n\n    $scope.$on(\'answerGroupChanged\', function() {\n      $scope.answerGroups = ResponsesService.getAnswerGroups();\n      $scope.defaultOutcome = ResponsesService.getDefaultOutcome();\n      $scope.activeAnswerGroupIndex = (\n        ResponsesService.getActiveAnswerGroupIndex());\n    });\n\n    $scope.$on(\'updateAnswerChoices\', function(evt, newAnswerChoices) {\n      ResponsesService.updateAnswerChoices(newAnswerChoices);\n    });\n\n    $scope.openTeachOppiaModal = function() {\n      AlertsService.clearWarnings();\n      $rootScope.$broadcast(\'externalSave\');\n\n      $uibModal.open({\n        templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n          \'/pages/exploration_editor/editor_tab/\' +\n          \'teach_oppia_modal_directive.html\'),\n        backdrop: false,\n        controller: [\n          \'$scope\', \'$injector\', \'$uibModalInstance\',\n          \'ExplorationHtmlFormatterService\',\n          \'stateInteractionIdService\', \'stateCustomizationArgsService\',\n          \'ExplorationContextService\', \'EditorStateService\',\n          \'ExplorationStatesService\', \'TrainingDataService\',\n          \'AnswerClassificationService\', \'FocusManagerService\',\n          \'AngularNameService\', \'EXPLICIT_CLASSIFICATION\',\n          function(\n              $scope, $injector, $uibModalInstance,\n              ExplorationHtmlFormatterService,\n              stateInteractionIdService, stateCustomizationArgsService,\n              ExplorationContextService, EditorStateService,\n              ExplorationStatesService, TrainingDataService,\n              AnswerClassificationService, FocusManagerService,\n              AngularNameService, EXPLICIT_CLASSIFICATION) {\n            var _explorationId = ExplorationContextService.getExplorationId();\n            var _stateName = EditorStateService.getActiveStateName();\n            var _state = ExplorationStatesService.getState(_stateName);\n\n            $scope.stateContent = _state.content.getHtml();\n            $scope.inputTemplate = (\n              ExplorationHtmlFormatterService.getInteractionHtml(\n                stateInteractionIdService.savedMemento,\n                stateCustomizationArgsService.savedMemento,\n                false,\n                \'testInteractionInput\'));\n            $scope.answerTemplate = \'\';\n\n            $scope.trainingData = [];\n            $scope.trainingDataAnswer = \'\';\n            $scope.trainingDataFeedback = \'\';\n            $scope.trainingDataOutcomeDest = \'\';\n\n            // Retrieve the interaction ID.\n            var interactionId = stateInteractionIdService.savedMemento;\n\n            var rulesServiceName =\n              AngularNameService.getNameOfInteractionRulesService(\n                interactionId);\n\n            // Inject RulesService dynamically.\n            var rulesService = $injector.get(rulesServiceName);\n\n            // See the training panel directive in StateEditor for an\n            // explanation on the structure of this object.\n            $scope.classification = {\n              answerGroupIndex: 0,\n              newOutcome: null\n            };\n\n            FocusManagerService.setFocus(\'testInteractionInput\');\n\n            $scope.finishTeaching = function(reopen) {\n              $uibModalInstance.close({\n                reopen: reopen\n              });\n            };\n\n            $scope.submitAnswer = function(answer) {\n              $scope.answerTemplate = (\n                ExplorationHtmlFormatterService.getAnswerHtml(\n                  answer, stateInteractionIdService.savedMemento,\n                  stateCustomizationArgsService.savedMemento));\n\n              var classificationResult = (\n                AnswerClassificationService.getMatchingClassificationResult(\n                  _explorationId, _stateName, _state, answer, rulesService));\n              var feedbackHtml = \'Nothing\';\n              var dest = classificationResult.outcome.dest;\n              if (classificationResult.outcome.hasNonemptyFeedback()) {\n                feedbackHtml = classificationResult.outcome.feedback.getHtml();\n              }\n              if (dest === _stateName) {\n                dest = \'<em>(try again)</em>\';\n              }\n              $scope.trainingDataAnswer = answer;\n              $scope.trainingDataFeedback = feedbackHtml;\n              $scope.trainingDataOutcomeDest = dest;\n\n              var classificationCategorization = (\n                classificationResult.classificationCategorization);\n\n              // If answer is classified using explicit rules then we don\'t show\n              // yes / no option to creator. Otherwise we ask whether the\n              // response it satisfactory and assign a different response\n              // if response is not satisfactory.\n              if (classificationCategorization === EXPLICIT_CLASSIFICATION) {\n                $scope.classification.answerGroupIndex = -1;\n              } else {\n                $scope.classification.answerGroupIndex = (\n                  classificationResult.answerGroupIndex);\n              }\n            };\n          }]\n      }).result.then(function(result) {\n        // Check if the modal should be reopened right away.\n        if (result.reopen) {\n          $scope.openTeachOppiaModal();\n        }\n      });\n    };\n\n    $scope.openAddAnswerGroupModal = function() {\n      AlertsService.clearWarnings();\n      $rootScope.$broadcast(\'externalSave\');\n\n      $uibModal.open({\n        templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n          \'/pages/exploration_editor/editor_tab/\' +\n          \'add_answer_group_modal_directive.html\'),\n        // Clicking outside this modal should not dismiss it.\n        backdrop: \'static\',\n        controller: [\n          \'$scope\', \'$uibModalInstance\', \'ResponsesService\',\n          \'EditorStateService\', \'EditorFirstTimeEventsService\',\n          \'RuleObjectFactory\', \'OutcomeObjectFactory\',\n          function(\n              $scope, $uibModalInstance, ResponsesService,\n              EditorStateService, EditorFirstTimeEventsService,\n              RuleObjectFactory, OutcomeObjectFactory) {\n            $scope.feedbackEditorIsOpen = false;\n\n            $scope.openFeedbackEditor = function() {\n              $scope.feedbackEditorIsOpen = true;\n            };\n            $scope.tmpRule = RuleObjectFactory.createNew(null, {});\n            $scope.tmpOutcome = OutcomeObjectFactory.createNew(\n              EditorStateService.getActiveStateName(), \'\', []);\n\n            $scope.isSelfLoopWithNoFeedback = function(tmpOutcome) {\n              return (\n                tmpOutcome.dest === EditorStateService.getActiveStateName() &&\n                !tmpOutcome.hasNonemptyFeedback());\n            };\n\n            $scope.addAnswerGroupForm = {};\n\n            $scope.saveResponse = function(reopen) {\n              $scope.$broadcast(\'saveOutcomeFeedbackDetails\');\n              $scope.$broadcast(\'saveOutcomeDestDetails\');\n\n              EditorFirstTimeEventsService.registerFirstSaveRuleEvent();\n\n              // Close the modal and save it afterwards.\n              $uibModalInstance.close({\n                tmpRule: angular.copy($scope.tmpRule),\n                tmpOutcome: angular.copy($scope.tmpOutcome),\n                reopen: reopen\n              });\n            };\n\n            $scope.cancel = function() {\n              $uibModalInstance.dismiss(\'cancel\');\n              AlertsService.clearWarnings();\n            };\n          }\n        ]\n      }).result.then(function(result) {\n        // Create a new answer group.\n        $scope.answerGroups.push(AnswerGroupObjectFactory.createNew(\n          [result.tmpRule], result.tmpOutcome, []));\n        ResponsesService.save($scope.answerGroups, $scope.defaultOutcome);\n        $scope.changeActiveAnswerGroupIndex($scope.answerGroups.length - 1);\n\n        // After saving it, check if the modal should be reopened right away.\n        if (result.reopen) {\n          $scope.openAddAnswerGroupModal();\n        }\n      });\n    };\n\n    // When the page is scrolled so that the top of the page is above the\n    // browser viewport, there are some bugs in the positioning of the helper.\n    // This is a bug in jQueryUI that has not been fixed yet. For more details,\n    // see http://stackoverflow.com/q/5791886\n    $scope.ANSWER_GROUP_LIST_SORTABLE_OPTIONS = {\n      axis: \'y\',\n      cursor: \'move\',\n      handle: \'.oppia-rule-sort-handle\',\n      items: \'.oppia-sortable-rule-block\',\n      revert: 100,\n      tolerance: \'pointer\',\n      start: function(e, ui) {\n        $rootScope.$broadcast(\'externalSave\');\n        $scope.changeActiveAnswerGroupIndex(-1);\n        ui.placeholder.height(ui.item.height());\n      },\n      stop: function() {\n        ResponsesService.save($scope.answerGroups, $scope.defaultOutcome);\n      }\n    };\n\n    $scope.deleteAnswerGroup = function(index, evt) {\n      // Prevent clicking on the delete button from also toggling the display\n      // state of the answer group.\n      evt.stopPropagation();\n\n      AlertsService.clearWarnings();\n      $uibModal.open({\n        templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n          \'/pages/exploration_editor/editor_tab/\' +\n          \'delete_answer_group_modal_directive.html\'),\n        backdrop: true,\n        controller: [\n          \'$scope\', \'$uibModalInstance\', function($scope, $uibModalInstance) {\n            $scope.reallyDelete = function() {\n              $uibModalInstance.close();\n            };\n\n            $scope.cancel = function() {\n              $uibModalInstance.dismiss(\'cancel\');\n              AlertsService.clearWarnings();\n            };\n          }\n        ]\n      }).result.then(function() {\n        ResponsesService.deleteAnswerGroup(index);\n      });\n    };\n\n    $scope.saveActiveAnswerGroupFeedback = function(updatedOutcome) {\n      ResponsesService.updateActiveAnswerGroup({\n        feedback: updatedOutcome.feedback\n      });\n    };\n\n    $scope.saveActiveAnswerGroupDest = function(updatedOutcome) {\n      ResponsesService.updateActiveAnswerGroup({\n        dest: updatedOutcome.dest,\n        refresherExplorationId: updatedOutcome.refresherExplorationId\n      });\n    };\n\n    $scope.saveActiveAnswerGroupCorrectnessLabel = function(updatedOutcome) {\n      ResponsesService.updateActiveAnswerGroup({\n        labelledAsCorrect: updatedOutcome.labelledAsCorrect\n      });\n    };\n\n    $scope.saveActiveAnswerGroupRules = function(updatedRules) {\n      ResponsesService.updateActiveAnswerGroup({\n        rules: updatedRules\n      });\n    };\n\n    $scope.saveDefaultOutcomeFeedback = function(updatedOutcome) {\n      ResponsesService.updateDefaultOutcome({\n        feedback: updatedOutcome.feedback\n      });\n    };\n\n    $scope.saveDefaultOutcomeDest = function(updatedOutcome) {\n      ResponsesService.updateDefaultOutcome({\n        dest: updatedOutcome.dest,\n        refresherExplorationId: updatedOutcome.refresherExplorationId\n      });\n    };\n\n    $scope.saveDefaultOutcomeCorrectnessLabel = function(updatedOutcome) {\n      ResponsesService.updateDefaultOutcome({\n        labelledAsCorrect: updatedOutcome.labelledAsCorrect\n      });\n    };\n\n    $scope.getAnswerChoices = function() {\n      return ResponsesService.getAnswerChoices();\n    };\n\n    $scope.isOutcomeLooping = function(outcome) {\n      var activeStateName = EditorStateService.getActiveStateName();\n      return outcome && (outcome.dest === activeStateName);\n    };\n\n    $scope.navigateToState = function(stateName) {\n      RouterService.navigateToMainTab(stateName);\n    };\n  }\n]);\n\noppia.filter(\'summarizeAnswerGroup\', [\n  \'$filter\', \'RULE_SUMMARY_WRAP_CHARACTER_COUNT\',\n  function($filter, RULE_SUMMARY_WRAP_CHARACTER_COUNT) {\n    return function(answerGroup, interactionId, answerChoices, shortenRule) {\n      var summary = \'\';\n      var outcome = answerGroup.outcome;\n      var hasFeedback = outcome.hasNonemptyFeedback();\n\n      if (answerGroup.rules) {\n        var firstRule = $filter(\'convertToPlainText\')(\n          $filter(\'parameterizeRuleDescription\')(\n            answerGroup.rules[0], interactionId, answerChoices));\n        summary = \'Answer \' + firstRule;\n\n        if (hasFeedback && shortenRule) {\n          summary = $filter(\'wrapTextWithEllipsis\')(\n            summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n        }\n        summary = \'[\' + summary + \'] \';\n      }\n\n      if (hasFeedback) {\n        summary += (\n          shortenRule ?\n            $filter(\'truncate\')(outcome.feedback.getHtml(), 30) :\n            $filter(\'convertToPlainText\')(outcome.feedback.getHtml()));\n      }\n      return summary;\n    };\n  }\n]);\n\noppia.filter(\'summarizeDefaultOutcome\', [\n  \'$filter\', \'INTERACTION_SPECS\', \'RULE_SUMMARY_WRAP_CHARACTER_COUNT\',\n  function($filter, INTERACTION_SPECS, RULE_SUMMARY_WRAP_CHARACTER_COUNT) {\n    return function(\n        defaultOutcome, interactionId, answerGroupCount, shortenRule) {\n      if (!defaultOutcome) {\n        return \'\';\n      }\n\n      var summary = \'\';\n      var hasFeedback = defaultOutcome.hasNonemptyFeedback();\n\n      if (interactionId && INTERACTION_SPECS[interactionId].is_linear) {\n        summary = INTERACTION_SPECS[interactionId].default_outcome_heading;\n      } else if (answerGroupCount > 0) {\n        summary = \'All other answers\';\n      } else {\n        summary = \'All answers\';\n      }\n\n      if (hasFeedback && shortenRule) {\n        summary = $filter(\'wrapTextWithEllipsis\')(\n          summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n      }\n      summary = \'[\' + summary + \'] \';\n\n      if (hasFeedback) {\n        summary +=\n          $filter(\'convertToPlainText\')(defaultOutcome.feedback.getHtml());\n      }\n      return summary;\n    };\n  }\n]);'

blocks = {}
debug_info = ''
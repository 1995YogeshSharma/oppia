from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/HintsAndSolutionManagerServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the Hints/Solution Manager service.\n */\n\ndescribe(\'HintsAndSolutionManager service\', function() {\n  var $timeout;\n  var $rootScope;\n  var hasms;\n  var hof;\n  var sof;\n  var EVENT_NEW_CARD_AVAILABLE;\n\n  beforeEach(module(\'oppia\'));\n  beforeEach(inject(function($injector) {\n    $timeout = $injector.get(\'$timeout\');\n    $rootScope = $injector.get(\'$rootScope\');\n    hasms = $injector.get(\'HintsAndSolutionManagerService\');\n    hof = $injector.get(\'HintObjectFactory\');\n    sof = $injector.get(\'SolutionObjectFactory\');\n    EVENT_NEW_CARD_AVAILABLE = $injector.get(\'EVENT_NEW_CARD_AVAILABLE\');\n\n    // Initialize the service with two hints and a solution.\n    hasms.reset([\n      hof.createFromBackendDict({\n        hint_content: {\n          html: \'one\',\n          audio_translations: {}\n        }\n      }), hof.createFromBackendDict({\n        hint_content: {\n          html: \'two\',\n          audio_translations: {}\n        }\n      })\n    ], sof.createFromBackendDict({\n      answer_is_exclusive: false,\n      correct_answer: \'This is a correct answer!\',\n      explanation: {\n        html: \'This is the explanation to the answer\',\n        audio_translations: {}\n      }\n    }));\n  }));\n\n  it(\'should display hints at the right times\', function() {\n    expect(hasms.isHintViewable(0)).toBe(false);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $timeout.flush();\n\n    // The first hint becomes viewable.\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    // No additional hints become viewable because the first hint has not been\n    // consumed yet.\n\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    // The first hint is consumed, but a delay is needed for the second hint to\n    // be viewable.\n    expect(hasms.displayHint(0).getHtml()).toBe(\'one\');\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $timeout.flush();\n\n    // The second hint is now available, but has not been consumed yet.\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(true);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    // The second hint is consumed, but a delay is needed for the solution to\n    // be viewable. Previous hints are still viewable, too.\n    expect(hasms.displayHint(1).getHtml()).toBe(\'two\');\n    expect(hasms.displayHint(0).getHtml()).toBe(\'one\');\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(true);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $timeout.flush();\n\n    // The solution is now viewable.\n    expect(hasms.isSolutionViewable()).toBe(true);\n  });\n\n  it(\'should not continue to display hints after after a correct answer is\' +\n     \'submitted\', function() {\n    expect(hasms.isHintViewable(0)).toBe(false);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $timeout.flush();\n    // The first hint becomes viewable.\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    // The first hint is consumed, but a delay is needed for the second hint\n    // to be viewable.\n    expect(hasms.displayHint(0).getHtml()).toBe(\'one\');\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $rootScope.$broadcast(EVENT_NEW_CARD_AVAILABLE);\n    $timeout.flush();\n\n    // Because a correct answer was submitted, the next hint should not be\n    // available.\n    expect(hasms.isHintViewable(0)).toBe(true);\n    expect(hasms.isHintViewable(1)).toBe(false);\n    expect(hasms.isSolutionViewable()).toBe(false);\n\n    $timeout.verifyNoPendingTasks();\n  });\n\n  it(\'should show the correct number of hints\', function() {\n    expect(hasms.getNumHints()).toBe(2);\n  });\n\n  it(\'should correctly retrieve the solution\', function() {\n    expect(hasms.isSolutionConsumed()).toBe(false);\n    expect(hasms.displaySolution().correctAnswer).toBe(\n      \'This is a correct answer!\');\n    expect(hasms.isSolutionConsumed()).toBe(true);\n  });\n});'

blocks = {}
debug_info = ''
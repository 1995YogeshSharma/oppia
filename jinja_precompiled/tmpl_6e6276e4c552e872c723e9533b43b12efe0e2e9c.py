from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/collection/CollectionValidationService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service to validate the consistency of a collection. These\n * checks are performable in the frontend to avoid sending a potentially invalid\n * collection to the backend, which performs similar validation checks to these\n * in collection_domain.Collection and subsequent domain objects.\n */\n\noppia.factory(\'CollectionValidationService\', [\n  \'CollectionLinearizerService\',\n  function(CollectionLinearizerService) {\n    var _getNonexistentExplorationIds = function(collection) {\n      return collection.getCollectionNodes().filter(function(collectionNode) {\n        return !collectionNode.doesExplorationExist();\n      }).map(function(collectionNode) {\n        return collectionNode.getExplorationId();\n      });\n    };\n\n    var _getPrivateExplorationIds = function(collection) {\n      return collection.getCollectionNodes().filter(function(collectionNode) {\n        return collectionNode.isExplorationPrivate();\n      }).map(function(collectionNode) {\n        return collectionNode.getExplorationId();\n      });\n    };\n\n    // Validates that the tags for the collection are in the proper format,\n    // returns true if all tags are in the correct format.\n    var validateTagFormat = function(tags) {\n      // Check to ensure that all tags follow the format specified in\n      // TAG_REGEX.\n      var tagRegex = new RegExp(GLOBALS.TAG_REGEX);\n      return tags.every(function(tag) {\n        return tag.match(tagRegex);\n      });\n    };\n\n    // Validates that the tags for the collection do not have duplicates,\n    // returns true if there are no duplicates.\n    var validateDuplicateTags = function(tags) {\n      return tags.every(function(tag, idx) {\n        return tags.indexOf(tag, idx + 1) === -1;\n      });\n    };\n\n    // Validates that the tags for the collection are normalized,\n    // returns true if all tags were normalized.\n    var validateTagsNormalized = function(tags) {\n      return tags.every(function(tag) {\n        return tag === tag.trim().replace(/\\s+/g, \' \');\n      });\n    };\n\n    var _validateCollection = function(collection, isPublic) {\n      // NOTE TO DEVELOPERS: Please ensure that this validation logic is the\n      // same as that in core.domain.collection_domain.Collection.validate().\n      var issues = [];\n\n      var collectionHasNodes = collection.getCollectionNodeCount() > 0;\n      if (!collectionHasNodes) {\n        issues.push(\n          \'There should be at least 1 exploration in the collection.\');\n      }\n\n      var nonexistentExpIds = _getNonexistentExplorationIds(collection);\n      if (nonexistentExpIds.length !== 0) {\n        issues.push(\n          \'The following exploration(s) either do not exist, or you do not \' +\n          \'have edit access to add them to this collection: \' +\n          nonexistentExpIds.join(\', \'));\n      }\n\n      if (isPublic) {\n        var privateExpIds = _getPrivateExplorationIds(collection);\n        if (privateExpIds.length !== 0) {\n          issues.push(\n            \'Private explorations cannot be added to a public collection: \' +\n            privateExpIds.join(\', \'));\n        }\n      }\n\n      return issues;\n    };\n\n    return {\n      /**\n       * Returns a list of error strings found when validating the provided\n       * collection. The validation methods used in this function are written to\n       * match the validations performed in the backend. This function is\n       * expensive, so it should be called sparingly.\n       */\n      findValidationIssuesForPrivateCollection: function(collection) {\n        return _validateCollection(collection, false);\n      },\n\n      /**\n       * Behaves in the same way as findValidationIssuesForPrivateCollection(),\n       * except additional validation checks are performed which are specific to\n       * public collections. This function is expensive, so it should be called\n       * sparingly.\n       */\n      findValidationIssuesForPublicCollection: function(collection) {\n        return _validateCollection(collection, true);\n      },\n\n      /**\n       * Returns false if the tags are not validate.\n       */\n      isTagValid: function(tags) {\n        return validateTagFormat(tags) && validateDuplicateTags(tags) &&\n          validateTagsNormalized(tags);\n      }\n    };\n  }]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/exploration/ParamTypeObjectFactory.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating new frontend instances of ParamType\n * domain objects.\n */\n\noppia.factory(\'ParamTypeObjectFactory\', [function() {\n  /**\n   * @private @constructor\n   * Defines a specific type that a parameter can take.\n   *\n   * IMPORTANT: All new types must be created in this file and registered in the\n   * {@link ParamType.registry}. See {@link ParamType.registry.UnicodeString}\n   * for an example.\n   *\n   * @param {Function.<?, Boolean>} validateFunction - Returns true when a value\n   *    is valid.\n   * @param {?} defaultValue - simple value any parameter of this type can take.\n   */\n  var ParamType = function(typeDefinitionObject) {\n    if (!typeDefinitionObject.validate(typeDefinitionObject.default_value)) {\n      throw new Error(\n        \'The default value is invalid according to validation function\');\n    }\n\n    /** @member {String} */\n    this._name = null;\n    /** @member {Function.<?, Boolean>} */\n    this.valueIsValid = typeDefinitionObject.validate;\n    /** @member {?} */\n    this.defaultValue = typeDefinitionObject.default_value;\n  };\n\n\n  // Instance methods.\n\n  /** @returns {?} - A valid default value for this particular type. */\n  ParamType.prototype.createDefaultValue = function() {\n    return angular.copy(this.defaultValue);\n  };\n\n  /** @returns {String} - The display-name of this type. */\n  ParamType.prototype.getName = function() {\n    return this._name;\n  };\n\n\n  // Class methods.\n\n  /**\n   * @param {String} backendName - the name of the type to fetch.\n   * @returns {ParamType} - The associated type, if any.\n   * @throws {Error} - When the given type name isn\'t registered.\n   */\n  ParamType.getTypeFromBackendName = function(backendName) {\n    if (!ParamType.registry.hasOwnProperty(backendName)) {\n      throw new Error(backendName + \' is not a registered parameter type.\');\n    }\n    return ParamType.registry[backendName];\n  };\n\n  /** @returns {ParamType} - Implementation-defined default parameter type. */\n  ParamType.getDefaultType = function() {\n    return ParamType.registry.UnicodeString;\n  };\n\n\n  // Type registration.\n\n  /** @type {Object.<String, ParamType>} */\n  ParamType.registry = {};\n\n  ParamType.registry.UnicodeString = new ParamType({\n    validate: function(value) {\n      return (typeof value === \'string\' || value instanceof String);\n    },\n    default_value: \'\',\n  });\n\n  // To finalize type registration, we encode the name of each type into their\n  // definition, then freeze them from modifications.\n  Object.keys(ParamType.registry).forEach(function(paramTypeName) {\n    var paramType = ParamType.registry[paramTypeName];\n    paramType._name = paramTypeName;\n    Object.freeze(paramType);\n  });\n  // Finally, we freeze the registry itself.\n  Object.freeze(ParamType.registry);\n\n  return ParamType;\n}]);'

blocks = {}
debug_info = ''
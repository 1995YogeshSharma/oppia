from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/ResponsesService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service responses corresponding to a state\'s interaction and\n * answer groups.\n */\n\noppia.factory(\'ResponsesService\', [\n  \'$rootScope\', \'stateInteractionIdService\', \'INTERACTION_SPECS\',\n  \'AnswerGroupsCacheService\', \'EditorStateService\', \'ChangeListService\',\n  \'ExplorationStatesService\', \'GraphDataService\', \'OutcomeObjectFactory\',\n  \'stateSolutionService\', \'SolutionVerificationService\', \'AlertsService\',\n  \'ExplorationContextService\', \'ExplorationWarningsService\',\n  \'INFO_MESSAGE_SOLUTION_IS_VALID\', \'INFO_MESSAGE_SOLUTION_IS_INVALID\',\n  \'INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE\',\n  function(\n      $rootScope, stateInteractionIdService, INTERACTION_SPECS,\n      AnswerGroupsCacheService, EditorStateService, ChangeListService,\n      ExplorationStatesService, GraphDataService, OutcomeObjectFactory,\n      stateSolutionService, SolutionVerificationService, AlertsService,\n      ExplorationContextService, ExplorationWarningsService,\n      INFO_MESSAGE_SOLUTION_IS_VALID, INFO_MESSAGE_SOLUTION_IS_INVALID,\n      INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE) {\n    var _answerGroupsMemento = null;\n    var _defaultOutcomeMemento = null;\n    var _confirmedUnclassifiedAnswersMemento = null;\n    // Represents the current selected answer group, starting at index 0. If the\n    // index equal to the number of answer groups (answerGroups.length), then it\n    // is referring to the default outcome.\n    var _activeAnswerGroupIndex = null;\n    var _activeRuleIndex = -1;\n    var _answerGroups = null;\n    var _defaultOutcome = null;\n    var _confirmedUnclassifiedAnswers = null;\n    var _answerChoices = null;\n\n    var _saveAnswerGroups = function(newAnswerGroups) {\n      var oldAnswerGroups = _answerGroupsMemento;\n      if (newAnswerGroups && oldAnswerGroups &&\n          !angular.equals(newAnswerGroups, oldAnswerGroups)) {\n        _answerGroups = newAnswerGroups;\n        $rootScope.$broadcast(\'answerGroupChanged\');\n        ExplorationStatesService.saveInteractionAnswerGroups(\n          EditorStateService.getActiveStateName(),\n          angular.copy(newAnswerGroups));\n\n        // To check if the solution is valid once a rule has been changed or\n        // added.\n        var currentInteractionId = stateInteractionIdService.savedMemento;\n        var interactionCanHaveSolution = (\n          currentInteractionId &&\n          INTERACTION_SPECS[currentInteractionId].can_have_solution);\n        var solutionExists = (\n          stateSolutionService.savedMemento &&\n          stateSolutionService.savedMemento.correctAnswer !== null);\n\n        if (interactionCanHaveSolution && solutionExists) {\n          var currentStateName = EditorStateService.getActiveStateName();\n          var solutionWasPreviouslyValid = (\n            ExplorationStatesService.isSolutionValid(\n              EditorStateService.getActiveStateName()));\n          var solutionIsCurrentlyValid = (\n            SolutionVerificationService.verifySolution(\n              ExplorationContextService.getExplorationId(),\n              ExplorationStatesService.getState(currentStateName),\n              stateSolutionService.savedMemento.correctAnswer));\n\n          ExplorationStatesService.updateSolutionValidity(\n            currentStateName, solutionIsCurrentlyValid);\n          ExplorationWarningsService.updateWarnings();\n\n          if (solutionIsCurrentlyValid && !solutionWasPreviouslyValid) {\n            AlertsService.addInfoMessage(INFO_MESSAGE_SOLUTION_IS_VALID);\n          } else if (!solutionIsCurrentlyValid && solutionWasPreviouslyValid) {\n            AlertsService.addInfoMessage(\n              INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE);\n          } else if (!solutionIsCurrentlyValid && !solutionWasPreviouslyValid) {\n            AlertsService.addInfoMessage(INFO_MESSAGE_SOLUTION_IS_INVALID);\n          }\n        }\n\n        GraphDataService.recompute();\n        _answerGroupsMemento = angular.copy(newAnswerGroups);\n      }\n    };\n\n    var _updateAnswerGroup = function(index, updates) {\n      var answerGroup = _answerGroups[index];\n      if (updates.hasOwnProperty(\'rules\')) {\n        answerGroup.rules = updates.rules;\n      }\n      if (updates.hasOwnProperty(\'feedback\')) {\n        answerGroup.outcome.feedback = updates.feedback;\n      }\n      if (updates.hasOwnProperty(\'dest\')) {\n        answerGroup.outcome.dest = updates.dest;\n      }\n      if (updates.hasOwnProperty(\'refresherExplorationId\')) {\n        answerGroup.outcome.refresherExplorationId = (\n          updates.refresherExplorationId);\n      }\n      if (updates.hasOwnProperty(\'labelledAsCorrect\')) {\n        answerGroup.outcome.labelledAsCorrect = updates.labelledAsCorrect;\n      }\n      if (updates.hasOwnProperty(\'trainingData\')) {\n        answerGroup.trainingData = updates.trainingData;\n      }\n      _saveAnswerGroups(_answerGroups);\n    };\n\n    var _saveDefaultOutcome = function(newDefaultOutcome) {\n      var oldDefaultOutcome = _defaultOutcomeMemento;\n      if (!angular.equals(newDefaultOutcome, oldDefaultOutcome)) {\n        _defaultOutcome = newDefaultOutcome;\n\n        ExplorationStatesService.saveInteractionDefaultOutcome(\n          EditorStateService.getActiveStateName(),\n          angular.copy(newDefaultOutcome));\n\n        GraphDataService.recompute();\n        _defaultOutcomeMemento = angular.copy(newDefaultOutcome);\n      }\n    };\n\n    var _saveConfirmedUnclassifiedAnswers = function(\n        newConfirmedUnclassifiedAnswers) {\n      var oldConfirmedUnclassifiedAnswers = (\n        _confirmedUnclassifiedAnswersMemento);\n      if (!angular.equals(\n        newConfirmedUnclassifiedAnswers, oldConfirmedUnclassifiedAnswers)) {\n        _confirmedUnclassifiedAnswers = newConfirmedUnclassifiedAnswers;\n\n        ExplorationStatesService.saveConfirmedUnclassifiedAnswers(\n          EditorStateService.getActiveStateName(),\n          angular.copy(newConfirmedUnclassifiedAnswers));\n\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          newConfirmedUnclassifiedAnswers);\n      }\n    };\n\n    return {\n      // The \'data\' arg is a list of interaction handlers for the\n      // currently-active state.\n      init: function(data) {\n        AnswerGroupsCacheService.reset();\n\n        _answerGroups = angular.copy(data.answerGroups);\n        _defaultOutcome = angular.copy(data.defaultOutcome);\n        _confirmedUnclassifiedAnswers = angular.copy(\n          data.confirmedUnclassifiedAnswers);\n        AnswerGroupsCacheService.set(\n          stateInteractionIdService.savedMemento, _answerGroups);\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n      },\n      onInteractionIdChanged: function(newInteractionId, callback) {\n        if (AnswerGroupsCacheService.contains(newInteractionId)) {\n          _answerGroups = AnswerGroupsCacheService.get(newInteractionId);\n        } else {\n          _answerGroups = [];\n        }\n\n        // Preserve the default outcome unless the interaction is terminal.\n        // Recreate the default outcome if switching away from a terminal\n        // interaction.\n        if (newInteractionId) {\n          if (INTERACTION_SPECS[newInteractionId].is_terminal) {\n            _defaultOutcome = null;\n          } else if (!_defaultOutcome) {\n            _defaultOutcome = OutcomeObjectFactory.createNew(\n              EditorStateService.getActiveStateName(), \'\', []);\n          }\n        }\n\n        _confirmedUnclassifiedAnswers = [];\n\n        _saveAnswerGroups(_answerGroups);\n        _saveDefaultOutcome(_defaultOutcome);\n        _saveConfirmedUnclassifiedAnswers(_confirmedUnclassifiedAnswers);\n        AnswerGroupsCacheService.set(newInteractionId, _answerGroups);\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n\n        if (callback) {\n          callback();\n        }\n      },\n      getActiveAnswerGroupIndex: function() {\n        return _activeAnswerGroupIndex;\n      },\n      changeActiveAnswerGroupIndex: function(newIndex) {\n        // If the current group is being clicked on again, close it.\n        if (newIndex === _activeAnswerGroupIndex) {\n          _activeAnswerGroupIndex = -1;\n        } else {\n          _activeAnswerGroupIndex = newIndex;\n        }\n\n        _activeRuleIndex = -1;\n      },\n      getActiveRuleIndex: function() {\n        return _activeRuleIndex;\n      },\n      changeActiveRuleIndex: function(newIndex) {\n        _activeRuleIndex = newIndex;\n      },\n      getAnswerChoices: function() {\n        return angular.copy(_answerChoices);\n      },\n      updateAnswerGroup: function(index, updates) {\n        _updateAnswerGroup(index, updates);\n      },\n      deleteAnswerGroup: function(index) {\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _answerGroups.splice(index, 1);\n        _activeAnswerGroupIndex = -1;\n        _saveAnswerGroups(_answerGroups);\n      },\n      updateActiveAnswerGroup: function(updates) {\n        _updateAnswerGroup(_activeAnswerGroupIndex, updates);\n      },\n      updateDefaultOutcome: function(updates) {\n        var outcome = _defaultOutcome;\n        if (updates.hasOwnProperty(\'feedback\')) {\n          outcome.feedback = updates.feedback;\n        }\n        if (updates.hasOwnProperty(\'dest\')) {\n          outcome.dest = updates.dest;\n        }\n        if (updates.hasOwnProperty(\'refresherExplorationId\')) {\n          outcome.refresherExplorationId = updates.refresherExplorationId;\n        }\n        if (updates.hasOwnProperty(\'labelledAsCorrect\')) {\n          outcome.labelledAsCorrect = updates.labelledAsCorrect;\n        }\n        _saveDefaultOutcome(outcome);\n      },\n      updateConfirmedUnclassifiedAnswers: function(\n          confirmedUnclassifiedAnswers) {\n        _saveConfirmedUnclassifiedAnswers(confirmedUnclassifiedAnswers);\n      },\n      // Updates answer choices when the interaction requires it -- for\n      // example, the rules for multiple choice need to refer to the multiple\n      // choice interaction\'s customization arguments.\n      updateAnswerChoices: function(newAnswerChoices) {\n        var oldAnswerChoices = angular.copy(_answerChoices);\n        _answerChoices = newAnswerChoices;\n\n        // If the interaction is ItemSelectionInput, update the answer groups\n        // to refer to the new answer options.\n        if (stateInteractionIdService.savedMemento === \'ItemSelectionInput\' &&\n            oldAnswerChoices) {\n          // We use an approximate algorithm here. If the length of the answer\n          // choices array remains the same, and no choice is replicated at\n          // different indices in both arrays (which indicates that some\n          // moving-around happened), then replace any old choice with its\n          // corresponding new choice. Otherwise, we simply remove any answer\n          // that has not been changed. This is not foolproof, but it should\n          // cover most cases.\n          //\n          // TODO(sll): Find a way to make this fully deterministic. This can\n          // probably only occur after we support custom editors for\n          // interactions.\n          var onlyEditsHappened = false;\n          if (oldAnswerChoices.length === newAnswerChoices.length) {\n            onlyEditsHappened = true;\n\n            // Check that no answer choice appears to have been moved.\n            var numAnswerChoices = oldAnswerChoices.length;\n            for (var i = 0; i < numAnswerChoices; i++) {\n              for (var j = 0; j < numAnswerChoices; j++) {\n                if (i !== j &&\n                    oldAnswerChoices[i].val === newAnswerChoices[j].val) {\n                  onlyEditsHappened = false;\n                  break;\n                }\n              }\n            }\n          }\n\n          var oldChoiceStrings = oldAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n          var newChoiceStrings = newAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n\n          _answerGroups.forEach(function(answerGroup, answerGroupIndex) {\n            var newRules = angular.copy(answerGroup.rules);\n            newRules.forEach(function(rule) {\n              for (var key in rule.inputs) {\n                var newInputValue = [];\n                rule.inputs[key].forEach(function(item) {\n                  var newIndex = newChoiceStrings.indexOf(item);\n                  if (newIndex !== -1) {\n                    newInputValue.push(item);\n                  } else if (onlyEditsHappened) {\n                    var oldIndex = oldChoiceStrings.indexOf(item);\n                    if (oldIndex !== -1) {\n                      newInputValue.push(newAnswerChoices[oldIndex].val);\n                    }\n                  }\n                });\n                rule.inputs[key] = newInputValue;\n              }\n            });\n\n            _updateAnswerGroup(answerGroupIndex, {\n              rules: newRules\n            });\n          });\n        }\n      },\n      getAnswerGroups: function() {\n        return angular.copy(_answerGroups);\n      },\n      getAnswerGroup: function(index) {\n        return angular.copy(_answerGroups[index]);\n      },\n      getAnswerGroupCount: function() {\n        return _answerGroups.length;\n      },\n      getDefaultOutcome: function() {\n        return angular.copy(_defaultOutcome);\n      },\n      getConfirmedUnclassifiedAnswers: function() {\n        return angular.copy(_confirmedUnclassifiedAnswers);\n      },\n      // This registers the change to the handlers in the list of changes, and\n      // also updates the states object in ExplorationStatesService.\n      save: function(newAnswerGroups, defaultOutcome) {\n        _saveAnswerGroups(newAnswerGroups);\n        _saveDefaultOutcome(defaultOutcome);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
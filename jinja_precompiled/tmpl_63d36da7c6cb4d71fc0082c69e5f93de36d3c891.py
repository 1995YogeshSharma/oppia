from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/ResponsesService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service responses corresponding to a state\'s interaction and\n * answer groups.\n */\n\noppia.factory(\'ResponsesService\', [\n  \'$rootScope\', \'StateInteractionIdService\', \'INTERACTION_SPECS\',\n  \'AnswerGroupsCacheService\', \'StateEditorService\',\n  \'OutcomeObjectFactory\', \'COMPONENT_NAME_DEFAULT_OUTCOME\',\n  \'StateSolutionService\', \'SolutionVerificationService\', \'AlertsService\',\n  \'ContextService\', \'StateContentIdsToAudioTranslationsService\',\n  \'SolutionValidityService\',\n  \'INFO_MESSAGE_SOLUTION_IS_VALID\', \'INFO_MESSAGE_SOLUTION_IS_INVALID\',\n  \'INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE\',\n  function(\n      $rootScope, StateInteractionIdService, INTERACTION_SPECS,\n      AnswerGroupsCacheService, StateEditorService,\n      OutcomeObjectFactory, COMPONENT_NAME_DEFAULT_OUTCOME,\n      StateSolutionService, SolutionVerificationService, AlertsService,\n      ContextService, StateContentIdsToAudioTranslationsService,\n      SolutionValidityService,\n      INFO_MESSAGE_SOLUTION_IS_VALID, INFO_MESSAGE_SOLUTION_IS_INVALID,\n      INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE) {\n    var _answerGroupsMemento = null;\n    var _defaultOutcomeMemento = null;\n    var _confirmedUnclassifiedAnswersMemento = null;\n    // Represents the current selected answer group, starting at index 0. If the\n    // index equal to the number of answer groups (answerGroups.length), then it\n    // is referring to the default outcome.\n    var _activeAnswerGroupIndex = null;\n    var _activeRuleIndex = -1;\n    var _answerGroups = null;\n    var _defaultOutcome = null;\n    var _confirmedUnclassifiedAnswers = null;\n    var _answerChoices = null;\n\n    var _verifySolution = function() {\n      // This checks if the solution is valid once a rule has been changed or\n      // added.\n      var currentInteractionId = StateInteractionIdService.savedMemento;\n      var interactionCanHaveSolution = (\n        currentInteractionId &&\n        INTERACTION_SPECS[currentInteractionId].can_have_solution);\n      var solutionExists = (\n        StateSolutionService.savedMemento &&\n        StateSolutionService.savedMemento.correctAnswer !== null);\n\n      if (interactionCanHaveSolution && solutionExists) {\n        var interaction = StateEditorService.getInteraction();\n\n        interaction.answerGroups = angular.copy(_answerGroups);\n        interaction.defaultOutcome = angular.copy(_defaultOutcome);\n        var solutionIsValid = SolutionVerificationService.verifySolution(\n          StateEditorService.getActiveStateName(),\n          interaction,\n          StateSolutionService.savedMemento.correctAnswer\n        );\n\n        SolutionValidityService.updateValidity(\n          StateEditorService.getActiveStateName(), solutionIsValid);\n        var solutionWasPreviouslyValid = (\n          SolutionValidityService.isSolutionValid(\n            StateEditorService.getActiveStateName()));\n        if (solutionIsValid && !solutionWasPreviouslyValid) {\n          AlertsService.addInfoMessage(INFO_MESSAGE_SOLUTION_IS_VALID);\n        } else if (!solutionIsValid && solutionWasPreviouslyValid) {\n          AlertsService.addInfoMessage(\n            INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_CURRENT_RULE);\n        } else if (!solutionIsValid && !solutionWasPreviouslyValid) {\n          AlertsService.addInfoMessage(INFO_MESSAGE_SOLUTION_IS_INVALID);\n        }\n      }\n    };\n\n    var _saveAnswerGroups = function(newAnswerGroups) {\n      var oldAnswerGroups = _answerGroupsMemento;\n      if (newAnswerGroups && oldAnswerGroups &&\n          !angular.equals(newAnswerGroups, oldAnswerGroups)) {\n        _answerGroups = newAnswerGroups;\n        $rootScope.$broadcast(\'answerGroupChanged\', newAnswerGroups);\n        _verifySolution();\n        _answerGroupsMemento = angular.copy(newAnswerGroups);\n      }\n    };\n\n    var _updateAnswerGroup = function(index, updates, callback) {\n      var answerGroup = _answerGroups[index];\n      if (updates.hasOwnProperty(\'rules\')) {\n        answerGroup.rules = updates.rules;\n      }\n      if (updates.hasOwnProperty(\'taggedMisconceptionId\')) {\n        answerGroup.taggedMisconceptionId = updates.taggedMisconceptionId;\n      }\n      if (updates.hasOwnProperty(\'feedback\')) {\n        answerGroup.outcome.feedback = updates.feedback;\n      }\n      if (updates.hasOwnProperty(\'dest\')) {\n        answerGroup.outcome.dest = updates.dest;\n      }\n      if (updates.hasOwnProperty(\'refresherExplorationId\')) {\n        answerGroup.outcome.refresherExplorationId = (\n          updates.refresherExplorationId);\n      }\n      if (updates.hasOwnProperty(\'missingPrerequisiteSkillId\')) {\n        answerGroup.outcome.missingPrerequisiteSkillId = (\n          updates.missingPrerequisiteSkillId);\n      }\n      if (updates.hasOwnProperty(\'labelledAsCorrect\')) {\n        answerGroup.outcome.labelledAsCorrect = updates.labelledAsCorrect;\n      }\n      if (updates.hasOwnProperty(\'trainingData\')) {\n        answerGroup.trainingData = updates.trainingData;\n      }\n      _saveAnswerGroups(_answerGroups);\n      callback(_answerGroupsMemento);\n    };\n\n    var _updateAnswerGroupsAudioTranslation = function() {\n      StateContentIdsToAudioTranslationsService.displayed.\n        deleteAllFeedbackContentId();\n      for (var i = 0; i < _answerGroups.length; i++) {\n        StateContentIdsToAudioTranslationsService.displayed.addContentId(\n          _answerGroups[i].outcome.feedback.getContentId());\n      }\n      StateContentIdsToAudioTranslationsService.saveDisplayedValue();\n    };\n\n    var _saveDefaultOutcome = function(newDefaultOutcome) {\n      var oldDefaultOutcome = _defaultOutcomeMemento;\n      if (!angular.equals(newDefaultOutcome, oldDefaultOutcome)) {\n        _defaultOutcome = newDefaultOutcome;\n        _verifySolution();\n        _defaultOutcomeMemento = angular.copy(newDefaultOutcome);\n      }\n    };\n\n    var _saveConfirmedUnclassifiedAnswers = function(\n        newConfirmedUnclassifiedAnswers) {\n      var oldConfirmedUnclassifiedAnswers = (\n        _confirmedUnclassifiedAnswersMemento);\n      if (!angular.equals(\n        newConfirmedUnclassifiedAnswers, oldConfirmedUnclassifiedAnswers)) {\n        _confirmedUnclassifiedAnswers = newConfirmedUnclassifiedAnswers;\n\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          newConfirmedUnclassifiedAnswers);\n      }\n    };\n\n    return {\n      // The \'data\' arg is a list of interaction handlers for the\n      // currently-active state.\n      init: function(data) {\n        AnswerGroupsCacheService.reset();\n\n        _answerGroups = angular.copy(data.answerGroups);\n        _defaultOutcome = angular.copy(data.defaultOutcome);\n        _confirmedUnclassifiedAnswers = angular.copy(\n          data.confirmedUnclassifiedAnswers);\n        if (StateInteractionIdService.savedMemento !== null) {\n          AnswerGroupsCacheService.set(\n            StateInteractionIdService.savedMemento, _answerGroups);\n        }\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n      },\n      onInteractionIdChanged: function(newInteractionId, callback) {\n        if (AnswerGroupsCacheService.contains(newInteractionId)) {\n          _answerGroups = AnswerGroupsCacheService.get(newInteractionId);\n        } else {\n          _answerGroups = [];\n        }\n\n        // This is necessary in order to keep the audio translations of the\n        // answer groups in sync with the answer groups that are fetched from\n        // the cache.\n        _updateAnswerGroupsAudioTranslation();\n\n        // Preserve the default outcome unless the interaction is terminal.\n        // Recreate the default outcome if switching away from a terminal\n        // interaction.\n        if (newInteractionId) {\n          if (INTERACTION_SPECS[newInteractionId].is_terminal) {\n            _defaultOutcome = null;\n            StateContentIdsToAudioTranslationsService.displayed.deleteContentId(\n              COMPONENT_NAME_DEFAULT_OUTCOME);\n          } else if (!_defaultOutcome) {\n            _defaultOutcome = OutcomeObjectFactory.createNew(\n              StateEditorService.getActiveStateName(),\n              COMPONENT_NAME_DEFAULT_OUTCOME, \'\', []);\n            StateContentIdsToAudioTranslationsService.displayed.addContentId(\n              COMPONENT_NAME_DEFAULT_OUTCOME);\n          }\n          _updateAnswerGroupsAudioTranslation();\n        }\n\n        _confirmedUnclassifiedAnswers = [];\n\n        _saveAnswerGroups(_answerGroups);\n        _saveDefaultOutcome(_defaultOutcome);\n        _saveConfirmedUnclassifiedAnswers(_confirmedUnclassifiedAnswers);\n        if (newInteractionId) {\n          AnswerGroupsCacheService.set(newInteractionId, _answerGroups);\n        }\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n\n        if (callback) {\n          callback(_answerGroupsMemento, _defaultOutcomeMemento);\n        }\n      },\n      getActiveAnswerGroupIndex: function() {\n        return _activeAnswerGroupIndex;\n      },\n      changeActiveAnswerGroupIndex: function(newIndex) {\n        // If the current group is being clicked on again, close it.\n        if (newIndex === _activeAnswerGroupIndex) {\n          _activeAnswerGroupIndex = -1;\n        } else {\n          _activeAnswerGroupIndex = newIndex;\n        }\n\n        _activeRuleIndex = -1;\n      },\n      getActiveRuleIndex: function() {\n        return _activeRuleIndex;\n      },\n      changeActiveRuleIndex: function(newIndex) {\n        _activeRuleIndex = newIndex;\n      },\n      getAnswerChoices: function() {\n        return angular.copy(_answerChoices);\n      },\n      updateAnswerGroup: function(index, updates, callback) {\n        _updateAnswerGroup(index, updates, callback);\n      },\n      deleteAnswerGroup: function(index, callback) {\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _answerGroups.splice(index, 1);\n        _activeAnswerGroupIndex = -1;\n        _saveAnswerGroups(_answerGroups);\n        callback(_answerGroupsMemento);\n      },\n      updateActiveAnswerGroup: function(updates, callback) {\n        _updateAnswerGroup(_activeAnswerGroupIndex, updates, callback);\n      },\n      updateDefaultOutcome: function(updates, callback) {\n        var outcome = _defaultOutcome;\n        if (updates.hasOwnProperty(\'feedback\')) {\n          outcome.feedback = updates.feedback;\n        }\n        if (updates.hasOwnProperty(\'dest\')) {\n          outcome.dest = updates.dest;\n        }\n        if (updates.hasOwnProperty(\'refresherExplorationId\')) {\n          outcome.refresherExplorationId = updates.refresherExplorationId;\n        }\n        if (updates.hasOwnProperty(\'missingPrerequisiteSkillId\')) {\n          outcome.missingPrerequisiteSkillId =\n            updates.missingPrerequisiteSkillId;\n        }\n        if (updates.hasOwnProperty(\'labelledAsCorrect\')) {\n          outcome.labelledAsCorrect = updates.labelledAsCorrect;\n        }\n        _saveDefaultOutcome(outcome);\n        callback(_defaultOutcomeMemento);\n      },\n      updateConfirmedUnclassifiedAnswers: function(\n          confirmedUnclassifiedAnswers) {\n        _saveConfirmedUnclassifiedAnswers(confirmedUnclassifiedAnswers);\n      },\n      // Updates answer choices when the interaction requires it -- for\n      // example, the rules for multiple choice need to refer to the multiple\n      // choice interaction\'s customization arguments.\n      updateAnswerChoices: function(newAnswerChoices, callback) {\n        var oldAnswerChoices = angular.copy(_answerChoices);\n        _answerChoices = newAnswerChoices;\n\n        // If the interaction is ItemSelectionInput, update the answer groups\n        // to refer to the new answer options.\n        if (StateInteractionIdService.savedMemento === \'ItemSelectionInput\' &&\n            oldAnswerChoices) {\n          // We use an approximate algorithm here. If the length of the answer\n          // choices array remains the same, and no choice is replicated at\n          // different indices in both arrays (which indicates that some\n          // moving-around happened), then replace any old choice with its\n          // corresponding new choice. Otherwise, we simply remove any answer\n          // that has not been changed. This is not foolproof, but it should\n          // cover most cases.\n          //\n          // TODO(sll): Find a way to make this fully deterministic. This can\n          // probably only occur after we support custom editors for\n          // interactions.\n          var onlyEditsHappened = false;\n          if (oldAnswerChoices.length === newAnswerChoices.length) {\n            onlyEditsHappened = true;\n\n            // Check that no answer choice appears to have been moved.\n            var numAnswerChoices = oldAnswerChoices.length;\n            for (var i = 0; i < numAnswerChoices; i++) {\n              for (var j = 0; j < numAnswerChoices; j++) {\n                if (i !== j &&\n                    oldAnswerChoices[i].val === newAnswerChoices[j].val) {\n                  onlyEditsHappened = false;\n                  break;\n                }\n              }\n            }\n          }\n\n          var oldChoiceStrings = oldAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n          var newChoiceStrings = newAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n\n          _answerGroups.forEach(function(answerGroup, answerGroupIndex) {\n            var newRules = angular.copy(answerGroup.rules);\n            newRules.forEach(function(rule) {\n              for (var key in rule.inputs) {\n                var newInputValue = [];\n                rule.inputs[key].forEach(function(item) {\n                  var newIndex = newChoiceStrings.indexOf(item);\n                  if (newIndex !== -1) {\n                    newInputValue.push(item);\n                  } else if (onlyEditsHappened) {\n                    var oldIndex = oldChoiceStrings.indexOf(item);\n                    if (oldIndex !== -1) {\n                      newInputValue.push(newAnswerChoices[oldIndex].val);\n                    }\n                  }\n                });\n                rule.inputs[key] = newInputValue;\n              }\n            });\n\n            _updateAnswerGroup(answerGroupIndex, {\n              rules: newRules\n            }, callback);\n          });\n        }\n\n        // If the interaction is DragAndDropSortInput, update the answer groups\n        // to refer to the new answer options.\n        if (StateInteractionIdService.savedMemento === \'DragAndDropSortInput\' &&\n            oldAnswerChoices) {\n          // If the length of the answer choices array changes, then there is\n          // surely any deletion or modification or addition in the array. We\n          // simply set answer groups to refer to default value. If the length\n          // of the answer choices array remains the same and all the choices in\n          // the previous array are present, then no change is required.\n          // However, if any of the choices is not present, we set answer groups\n          // to refer to the default value containing new answer choices.\n          var anyChangesHappened = false;\n          if (oldAnswerChoices.length !== newAnswerChoices.length) {\n            anyChangesHappened = true;\n          } else {\n            // Check if any modification happened in answer choices.\n            var numAnswerChoices = oldAnswerChoices.length;\n            for (var i = 0; i < numAnswerChoices; i++) {\n              var choiceIsPresent = false;\n              for (var j = 0; j < numAnswerChoices; j++) {\n                if (oldAnswerChoices[i].val === newAnswerChoices[j].val) {\n                  choiceIsPresent = true;\n                  break;\n                }\n              }\n              if (choiceIsPresent === false) {\n                anyChangesHappened = true;\n                break;\n              }\n            }\n          }\n\n          if (anyChangesHappened) {\n            _answerGroups.forEach(function(answerGroup, answerGroupIndex) {\n              var newRules = angular.copy(answerGroup.rules);\n              newRules.forEach(function(rule) {\n                if (rule.type === \'HasElementXAtPositionY\') {\n                  for (var key in rule.inputs) {\n                    var newInputValue = \'\';\n                    if (key === \'y\') {\n                      newInputValue = 1;\n                    }\n                    rule.inputs[key] = newInputValue;\n                  }\n                } else if (rule.type === \'HasElementXBeforeElementY\') {\n                  for (var key in rule.inputs) {\n                    var newInputValue = \'\';\n                    rule.inputs[key] = newInputValue;\n                  }\n                } else {\n                  for (var key in rule.inputs) {\n                    var newInputValue = [];\n                    rule.inputs[key] = newInputValue;\n                  }\n                }\n              });\n\n              _updateAnswerGroup(answerGroupIndex, {\n                rules: newRules\n              }, callback);\n            });\n          }\n        }\n      },\n      getAnswerGroups: function() {\n        return angular.copy(_answerGroups);\n      },\n      getAnswerGroup: function(index) {\n        return angular.copy(_answerGroups[index]);\n      },\n      getAnswerGroupCount: function() {\n        return _answerGroups.length;\n      },\n      getDefaultOutcome: function() {\n        return angular.copy(_defaultOutcome);\n      },\n      getConfirmedUnclassifiedAnswers: function() {\n        return angular.copy(_confirmedUnclassifiedAnswers);\n      },\n      // This registers the change to the handlers in the list of changes.\n      save: function(newAnswerGroups, defaultOutcome, callback) {\n        _saveAnswerGroups(newAnswerGroups);\n        _saveDefaultOutcome(defaultOutcome);\n        callback(_answerGroupsMemento, _defaultOutcomeMemento);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
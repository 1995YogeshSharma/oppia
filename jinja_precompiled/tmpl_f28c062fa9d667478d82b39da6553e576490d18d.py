from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'services/SpeechSynthesisChunkerService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service to chunk a piece of text into smaller parts\n * to feed into SpeechSynthesis, because SpeechSynthesis always times\n * out after 200-300 characters.\n *\n * Code is adapted from:\n * https://gist.github.com/woollsta/2d146f13878a301b36d7\n *\n * Credits to Peter Woolley and Brett Zamir.\n */\n\noppia.factory(\'SpeechSynthesisChunkerService\', [\n  \'$timeout\', \'RTE_COMPONENT_SPECS\', function($timeout, RTE_COMPONENT_SPECS) {\n    // Max number of characters to fit into one chunk.\n    var CHUNK_LENGTH = 160;\n\n    var _speechSynthesis = window.speechSynthesis;\n\n    var RTE_COMPONENT_NAMES = {};\n    Object.keys(RTE_COMPONENT_SPECS).forEach(function(componentSpec) {\n      RTE_COMPONENT_NAMES[componentSpec] =\n        RTE_COMPONENT_SPECS[componentSpec].frontend_id;\n    });\n\n    // Punctuation marks that should result in an audible pause when playing\n    // back autogenerated audio.\n    var PUNCTUATION_MARKS_TO_END_CHUNKS = \'.!?:;\';\n    // Punctuation marks that we don\'t want to influence the playing back of\n    // autogenerated audio.\n    var PUNCTUATION_MARKS_TO_IGNORE = \'"\';\n\n    var cancelRequested = false;\n\n    /**\n     * Takes an utterance, and plays it in separate utterances each of at\n     *    most 160 characters in length.\n     * @param {SpeechSynthesisUtterance} utterance - The original utterance\n     *    that contains the whole message to speak.\n     * @param {Number} offset - An integer indicating what offset in the text\n     *    to begin the next chunked utterance.\n     * @param {requestCallback} - Callback that is activated when the last\n     *    chunked utterance finishes playing.\n     */\n    var _speechUtteranceChunker = function(utterance, offset, callback) {\n      var newUtterance;\n      var text = (offset !== undefined ?\n        utterance.text.substring(offset) : utterance.text);\n\n      // This regex pattern finds the next string at most 160\n      // characters in length that ends on a punctuation mark in\n      // PUNCTUATION_MARKS_TO_END_CHUNKS.\n      var delimitChunkRegex = new RegExp(\'^[\\\\s\\\\S]{\' +\n        Math.floor(CHUNK_LENGTH / 4) + \',\' + CHUNK_LENGTH + \'}[\' +\n        PUNCTUATION_MARKS_TO_END_CHUNKS + \']{1}|^[\\\\s\\\\S]{1,\' +\n        CHUNK_LENGTH + \'}$|^[\\\\s\\\\S]{1,\' + CHUNK_LENGTH + \'} \');\n      var chunkArray = text.match(delimitChunkRegex);\n\n      if (chunkArray === null ||\n          chunkArray[0] === undefined ||\n          chunkArray[0].length <= 2) {\n        // Call once all text has been spoken.\n        if (callback !== undefined) {\n          callback();\n        }\n        return;\n      }\n      var chunk = chunkArray[0];\n      newUtterance = new SpeechSynthesisUtterance(chunk);\n\n      // Copy properties from the current utterance to the next utterance,\n      // excluding the text being spoken.\n      for (var property in utterance) {\n        if (property !== \'text\') {\n          newUtterance[property] = utterance[property];\n        }\n      }\n      newUtterance.onend = function() {\n        if (cancelRequested) {\n          cancelRequested = false;\n          return;\n        }\n        offset += chunk.length;\n        _speechUtteranceChunker(utterance, offset, callback);\n      };\n\n      // IMPORTANT!! Do not remove: Logging the object out fixes some onend\n      // firing issues. Placing the speak invocation inside a callback\n      // fixes ordering and onend issues.\n      // eslint-disable-next-line no-console\n      console.log(newUtterance);\n      $timeout(function() {\n        speechSynthesis.speak(newUtterance);\n      }, 0);\n    };\n\n    var _convertToSpeakableText = function(html) {\n      elt = $(\'<div>\' + html + \'</div>\');\n      // Convert links into speakable text by extracting the readable value.\n      elt.find(\'oppia-noninteractive-\' + RTE_COMPONENT_NAMES.Link)\n        .replaceWith(function() {\n          if (this.attributes[\'text-with-value\'] !== undefined) {\n            return this.attributes[\'text-with-value\'].textContent\n              .replace(/&quot;/g, \'\');\n          }\n        });\n\n      // Convert LaTeX to speakable text.\n      elt.find(\'oppia-noninteractive-\' + RTE_COMPONENT_NAMES.Math)\n        .replaceWith(function() {\n          if (this.attributes[\'raw_latex-with-value\'] !== undefined) {\n            return _formatLatexToSpeakableText(\n              this.attributes[\'raw_latex-with-value\'].textContent);\n          }\n        });\n\n      html = elt.html();\n      // Replace certain HTML elements with periods to indicate\n      // pauses in speaking. Also, for some reason, there\'s a lot\n      // of whitespace (like hundreds of characters) so we trim\n      // it off to avoid blank chunks.\n      html = html.replace(new RegExp(\'</li>\', \'g\'), \'.\').trim();\n      // Strip away HTML tags.\n      var tmp = $(\'<div></div>\');\n      tmp.html(html);\n      var textToSpeakWithoutPauses = tmp.text();\n      var textToSpeak = \'\';\n      // Insert a space after punctuation marks to ensure that chunking will\n      // end on the desired punctuation marks so that SpeechSynthesis will\n      // pause more naturally. Remove any punctuation marks that have no\n      // effect on speaking.\n      for (var i = 0; i < textToSpeakWithoutPauses.length; i++) {\n        if (PUNCTUATION_MARKS_TO_IGNORE.indexOf(\n          textToSpeakWithoutPauses.charAt(i)) > -1) {\n          continue;\n        }\n        textToSpeak += textToSpeakWithoutPauses.charAt(i);\n        if (PUNCTUATION_MARKS_TO_END_CHUNKS.indexOf(\n          textToSpeakWithoutPauses.charAt(i)) > -1) {\n          textToSpeak += \' \';\n        }\n      }\n      return textToSpeak;\n    };\n\n    var _formatLatexToSpeakableText = function(latex) {\n      return latex\n        .replace(/&quot;/g, \'\')\n        .replace(/\\\\/g, \'\')\n        .replace(/\\s+/, \' \')\n        // Separate consecutive characters with spaces so that \'ab\'\n        // is pronounced \'a\' followed by \'b\'.\n        .split(\'\').join(\' \')\n        .replace(/\\s*(\\d+)\\s*/g, \'$1\')\n        // Replace dashes with \'minus\'.\n        .replace(/-/g, \' minus \')\n        // Ensure that \'x^2\' is pronounced \'x squared\' rather than\n        // \'x caret 2\'.\n        .replace(/\\s*\\^\\s*/g, \'^\')\n        // Speak \'x^y\' as \'x to the power of y\' unless the exponent is two or\n        // three, in which case Web Speech will read \'squared\' and \'cubed\'\n        // respectively.\n        .replace(/(.*)\\^(\\{*[0-9].+|[0-14-9]\\}*)/g, \'$1 to the power of $2\')\n        // Handle simple fractions.\n        .replace(/f\\sr\\sa\\sc\\s\\{\\s*(.+)\\s*\\}\\s\\{\\s*(.+)\\s*\\}/g,\n          \'$1/$2\')\n        // If a fraction contains a variable, then say (numerator) \'over\'\n        // (denominator).\n        .replace(/(\\d*\\D+)\\/(\\d*\\D*)|(\\d*\\D*)\\/(\\d*\\D+)/g, \'$1 over $2\')\n        // Handle basic trigonometric functions.\n        .replace(/t\\sa\\sn/g, \'the tangent of\')\n        .replace(/s\\si\\sn/g, \'the sine of\')\n        .replace(/c\\so\\ss/g, \'the cosine of\')\n        // Handle square roots.\n        .replace(/s\\sq\\sr\\st\\s\\{\\s*(.+)\\s*\\}/g, \'the square root of $1\')\n        // Remove brackets.\n        .replace(/[\\}\\{]/g, \'\')\n        // Replace multiple spaces with single space.\n        .replace(/\\s\\s+/g, \' \')\n        .trim();\n    };\n\n    return {\n      speak: function(utterance, callback) {\n        cancelRequested = false;\n        _speechUtteranceChunker(utterance, 0, callback);\n      },\n      cancel: function() {\n        cancelRequested = true;\n        if (_speechSynthesis) {\n          _speechSynthesis.cancel();\n        }\n      },\n      convertToSpeakableText: function(html) {\n        return _convertToSpeakableText(html);\n      },\n      formatLatexToSpeakableText: function(latex) {\n        return _formatLatexToSpeakableText(latex);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
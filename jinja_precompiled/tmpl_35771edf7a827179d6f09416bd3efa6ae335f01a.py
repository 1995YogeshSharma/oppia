from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/collection_editor/CollectionEditorStateServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for CollectionEditorStateService.\n */\n\ndescribe(\'Collection editor state service\', function() {\n  var CollectionEditorStateService = null;\n  var CollectionObjectFactory = null;\n  var CollectionRightsObjectFactory = null;\n  var CollectionUpdateService = null;\n  var fakeEditableCollectionBackendApiService = null;\n  var fakeCollectionRightsBackendApiService = null;\n\n  // TODO(bhenning): Consider moving this to a more shareable location.\n  var FakeEditableCollectionBackendApiService = function() {\n    var self = {};\n\n    var _fetchOrUpdateCollection = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.newBackendCollectionObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.newBackendCollectionObject = {};\n    self.failure = null;\n    self.fetchCollection = _fetchOrUpdateCollection;\n    self.updateCollection = _fetchOrUpdateCollection;\n\n    return self;\n  };\n\n  var FakeCollectionRightsBackendApiService = function() {\n    var self = {};\n\n    var _fetchCollectionRights = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.backendCollectionRightsObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.backendCollectionRightsObject = {};\n    self.failure = null;\n    self.fetchCollectionRights = _fetchCollectionRights;\n\n    return self;\n  };\n\n  beforeEach(module(\'oppia\'));\n  beforeEach(module(\'oppia\', GLOBALS.TRANSLATOR_PROVIDER_FOR_TESTS));\n  beforeEach(module(\'oppia\', function($provide) {\n    fakeEditableCollectionBackendApiService = (\n      new FakeEditableCollectionBackendApiService());\n    $provide.value(\n      \'EditableCollectionBackendApiService\',\n      [fakeEditableCollectionBackendApiService][0]);\n\n    fakeCollectionRightsBackendApiService = (\n      new FakeCollectionRightsBackendApiService());\n    $provide.value(\n      \'CollectionRightsBackendApiService\',\n      [fakeCollectionRightsBackendApiService][0]);\n  }));\n\n  beforeEach(inject(function($injector) {\n    CollectionEditorStateService = $injector.get(\n      \'CollectionEditorStateService\');\n    CollectionObjectFactory = $injector.get(\'CollectionObjectFactory\');\n    CollectionRightsObjectFactory = $injector.get(\n      \'CollectionRightsObjectFactory\');\n    CollectionUpdateService = $injector.get(\'CollectionUpdateService\');\n    $q = $injector.get(\'$q\');\n    $rootScope = $injector.get(\'$rootScope\');\n    $scope = $rootScope.$new();\n\n    fakeEditableCollectionBackendApiService.newBackendCollectionObject = {\n      id: \'0\',\n      title: \'Collection Under Test\',\n      category: \'Test\',\n      objective: \'To pass\',\n      language_code: \'en\',\n      schema_version: \'3\',\n      version: \'1\',\n      nodes: [{\n        exploration_id: \'0\'\n      }, {\n        exploration_id: \'1\'\n      }]\n    };\n    secondBackendCollectionObject = {\n      id: \'5\',\n      title: \'Interesting collection\',\n      category: \'Test\',\n      objective: \'To be interesting\',\n      language_code: \'en\',\n      tags: [],\n      schema_version: \'3\',\n      version: \'3\',\n      nodes: [{\n        exploration_id: \'0\'\n      }]\n    };\n\n    privateCollectionRightsObject = {\n      collection_id: \'5\',\n      can_edit: \'true\',\n      can_unpublish: \'false\',\n      is_private: \'true\',\n      owner_names: [\'A\']\n    };\n    fakeCollectionRightsBackendApiService.backendCollectionRightsObject = (\n      privateCollectionRightsObject);\n\n    unpublishablePublicCollectionRightsObject = {\n      collection_id: \'5\',\n      can_edit: \'true\',\n      can_unpublish: \'true\',\n      is_private: \'false\',\n      owner_names: [\'A\']\n    };\n  }));\n\n  it(\'should request to load the collection from the backend\', function() {\n    spyOn(\n      fakeEditableCollectionBackendApiService,\n      \'fetchCollection\').and.callThrough();\n\n    CollectionEditorStateService.loadCollection(5);\n    expect(fakeEditableCollectionBackendApiService.fetchCollection)\n      .toHaveBeenCalled();\n  });\n\n  it(\'should request to load the collection rights from the backend\',\n    function() {\n      spyOn(fakeCollectionRightsBackendApiService, \'fetchCollectionRights\')\n        .and.callThrough();\n\n      CollectionEditorStateService.loadCollection(5);\n      expect(fakeCollectionRightsBackendApiService.fetchCollectionRights)\n        .toHaveBeenCalled();\n    }\n  );\n\n  it(\'should fire an init event after loading the first collection\',\n    function() {\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n      CollectionEditorStateService.loadCollection(5);\n      $rootScope.$apply();\n\n      expect($rootScope.$broadcast).toHaveBeenCalledWith(\n        \'collectionInitialized\');\n    }\n  );\n\n  it(\'should fire an update event after loading more collections\', function() {\n    // Load initial collection.\n    CollectionEditorStateService.loadCollection(5);\n    $rootScope.$apply();\n\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n    // Load a second collection.\n    CollectionEditorStateService.loadCollection(1);\n    $rootScope.$apply();\n\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\n      \'collectionReinitialized\');\n  });\n\n  it(\'should track whether it is currently loading the collection\', function() {\n    expect(CollectionEditorStateService.isLoadingCollection()).toBe(false);\n\n    CollectionEditorStateService.loadCollection(5);\n    expect(CollectionEditorStateService.isLoadingCollection()).toBe(true);\n\n    $rootScope.$apply();\n    expect(CollectionEditorStateService.isLoadingCollection()).toBe(false);\n  });\n\n  it(\'should indicate a collection is no longer loading after an error\',\n    function() {\n      expect(CollectionEditorStateService.isLoadingCollection()).toBe(false);\n      fakeEditableCollectionBackendApiService.failure = \'Internal 500 error\';\n\n      CollectionEditorStateService.loadCollection(5);\n      expect(CollectionEditorStateService.isLoadingCollection()).toBe(true);\n\n      $rootScope.$apply();\n      expect(CollectionEditorStateService.isLoadingCollection()).toBe(false);\n    }\n  );\n\n  it(\'it should report that a collection has loaded through loadCollection()\',\n    function() {\n      expect(CollectionEditorStateService.hasLoadedCollection()).toBe(false);\n\n      CollectionEditorStateService.loadCollection(5);\n      expect(CollectionEditorStateService.hasLoadedCollection()).toBe(false);\n\n      $rootScope.$apply();\n      expect(CollectionEditorStateService.hasLoadedCollection()).toBe(true);\n    }\n  );\n\n  it(\'it should report that a collection has loaded through setCollection()\',\n    function() {\n      expect(CollectionEditorStateService.hasLoadedCollection()).toBe(false);\n\n      var newCollection = CollectionObjectFactory.create(\n        secondBackendCollectionObject);\n      CollectionEditorStateService.setCollection(newCollection);\n      expect(CollectionEditorStateService.hasLoadedCollection()).toBe(true);\n    }\n  );\n\n  it(\'should initially return an empty collection\', function() {\n    var collection = CollectionEditorStateService.getCollection();\n    expect(collection.getId()).toBeUndefined();\n    expect(collection.getTitle()).toBeUndefined();\n    expect(collection.getObjective()).toBeUndefined();\n    expect(collection.getCategory()).toBeUndefined();\n    expect(collection.getCollectionNodes()).toEqual([]);\n  });\n\n  it(\'should initially return an empty collection rights\', function() {\n    var collectionRights = CollectionEditorStateService.getCollectionRights();\n    expect(collectionRights.getCollectionId()).toBeUndefined();\n    expect(collectionRights.canEdit()).toBeUndefined();\n    expect(collectionRights.canUnpublish()).toBeUndefined();\n    expect(collectionRights.isPrivate()).toBeUndefined();\n    expect(collectionRights.getOwnerNames()).toEqual([]);\n  });\n\n  it(\'should return the last collection loaded as the same object\', function() {\n    var previousCollection = CollectionEditorStateService.getCollection();\n    var expectedCollection = CollectionObjectFactory.create(\n      fakeEditableCollectionBackendApiService.newBackendCollectionObject);\n    expect(previousCollection).not.toEqual(expectedCollection);\n\n    CollectionEditorStateService.loadCollection(5);\n    $rootScope.$apply();\n\n    var actualCollection = CollectionEditorStateService.getCollection();\n    expect(actualCollection).toEqual(expectedCollection);\n\n    // Although the actual collection equals the expected collection, they are\n    // different objects. Ensure that the actual collection is still the same\n    // object from before loading it, however.\n    expect(actualCollection).toBe(previousCollection);\n    expect(actualCollection).not.toBe(expectedCollection);\n  });\n\n  it(\'should return the last collection rights loaded as the same object\',\n    function() {\n      var previousCollectionRights = (\n        CollectionEditorStateService.getCollectionRights());\n      var expectedCollectionRights = CollectionRightsObjectFactory.create(\n        fakeCollectionRightsBackendApiService.backendCollectionRightsObject);\n      expect(previousCollectionRights).not.toEqual(expectedCollectionRights);\n\n      CollectionEditorStateService.loadCollection(5);\n      $rootScope.$apply();\n\n      var actualCollectionRights = (\n        CollectionEditorStateService.getCollectionRights());\n      expect(actualCollectionRights).toEqual(expectedCollectionRights);\n\n      // Although the actual collection rights equals the expected collection\n      // rights, they are different objects. Ensure that the actual collection\n      // rights is still the same object from before loading it, however.\n      expect(actualCollectionRights).toBe(previousCollectionRights);\n      expect(actualCollectionRights).not.toBe(expectedCollectionRights);\n    }\n  );\n\n  it(\'should be able to set a new collection with an in-place copy\',\n    function() {\n      var previousCollection = CollectionEditorStateService.getCollection();\n      var expectedCollection = CollectionObjectFactory.create(\n        secondBackendCollectionObject);\n      expect(previousCollection).not.toEqual(expectedCollection);\n\n      CollectionEditorStateService.setCollection(expectedCollection);\n\n      var actualCollection = CollectionEditorStateService.getCollection();\n      expect(actualCollection).toEqual(expectedCollection);\n\n      // Although the actual collection equals the expected collection, they are\n      // different objects. Ensure that the actual collection is still the same\n      // object from before loading it, however.\n      expect(actualCollection).toBe(previousCollection);\n      expect(actualCollection).not.toBe(expectedCollection);\n    }\n  );\n\n  it(\'should be able to set a new collection rights with an in-place copy\',\n    function() {\n      var previousCollectionRights = (\n        CollectionEditorStateService.getCollectionRights());\n      var expectedCollectionRights = CollectionRightsObjectFactory.create(\n        unpublishablePublicCollectionRightsObject);\n      expect(previousCollectionRights).not.toEqual(expectedCollectionRights);\n\n      CollectionEditorStateService.setCollectionRights(\n        expectedCollectionRights);\n\n      var actualCollectionRights = (\n        CollectionEditorStateService.getCollectionRights());\n      expect(actualCollectionRights).toEqual(expectedCollectionRights);\n\n      // Although the actual collection rights equals the expected collection\n      // rights, they are different objects. Ensure that the actual collection\n      // rights is still the same object from before loading it, however.\n      expect(actualCollectionRights).toBe(previousCollectionRights);\n      expect(actualCollectionRights).not.toBe(expectedCollectionRights);\n    }\n  );\n\n  it(\'should fire an update event after setting the new collection\',\n    function() {\n      // Load initial collection.\n      CollectionEditorStateService.loadCollection(5);\n      $rootScope.$apply();\n\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n      var newCollection = CollectionObjectFactory.create(\n        secondBackendCollectionObject);\n      CollectionEditorStateService.setCollection(newCollection);\n\n      expect($rootScope.$broadcast).toHaveBeenCalledWith(\n        \'collectionReinitialized\');\n    }\n  );\n\n  it(\'should fail to save the collection without first loading one\',\n    function() {\n      expect(function() {\n        CollectionEditorStateService.saveCollection(\'Commit message\');\n      }).toThrow();\n    }\n  );\n\n  it(\'should not save the collection if there are no pending changes\',\n    function() {\n      CollectionEditorStateService.loadCollection(5);\n      $rootScope.$apply();\n\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n      expect(CollectionEditorStateService.saveCollection(\n        \'Commit message\')).toBe(false);\n      expect($rootScope.$broadcast).not.toHaveBeenCalled();\n    }\n  );\n\n  it(\'should be able to save the collection and pending changes\', function() {\n    spyOn(\n      fakeEditableCollectionBackendApiService,\n      \'updateCollection\').and.callThrough();\n\n    CollectionEditorStateService.loadCollection(0);\n    CollectionUpdateService.setCollectionTitle(\n      CollectionEditorStateService.getCollection(), \'New title\');\n    $rootScope.$apply();\n\n    expect(CollectionEditorStateService.saveCollection(\n      \'Commit message\')).toBe(true);\n    $rootScope.$apply();\n\n    var expectedId = \'0\';\n    var expectedVersion = \'1\';\n    var expectedCommitMessage = \'Commit message\';\n    var updateCollectionSpy = (\n      fakeEditableCollectionBackendApiService.updateCollection);\n    expect(updateCollectionSpy).toHaveBeenCalledWith(\n      expectedId, expectedVersion, expectedCommitMessage, jasmine.any(Object));\n  });\n\n  it(\'should fire an update event after saving the collection\', function() {\n    CollectionEditorStateService.loadCollection(5);\n    CollectionUpdateService.setCollectionTitle(\n      CollectionEditorStateService.getCollection(), \'New title\');\n    $rootScope.$apply();\n\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n    CollectionEditorStateService.saveCollection(\'Commit message\');\n    $rootScope.$apply();\n\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\n      \'collectionReinitialized\');\n  });\n\n  it(\'should track whether it is currently saving the collection\', function() {\n    CollectionEditorStateService.loadCollection(5);\n    CollectionUpdateService.setCollectionTitle(\n      CollectionEditorStateService.getCollection(), \'New title\');\n    $rootScope.$apply();\n\n    expect(CollectionEditorStateService.isSavingCollection()).toBe(false);\n    CollectionEditorStateService.saveCollection(\'Commit message\');\n    expect(CollectionEditorStateService.isSavingCollection()).toBe(true);\n\n    $rootScope.$apply();\n    expect(CollectionEditorStateService.isSavingCollection()).toBe(false);\n  });\n\n  it(\'should indicate a collection is no longer saving after an error\',\n    function() {\n      CollectionEditorStateService.loadCollection(5);\n      CollectionUpdateService.setCollectionTitle(\n        CollectionEditorStateService.getCollection(), \'New title\');\n      $rootScope.$apply();\n\n      expect(CollectionEditorStateService.isSavingCollection()).toBe(false);\n      fakeEditableCollectionBackendApiService.failure = \'Internal 500 error\';\n\n      CollectionEditorStateService.saveCollection(\'Commit message\');\n      expect(CollectionEditorStateService.isSavingCollection()).toBe(true);\n\n      $rootScope.$apply();\n      expect(CollectionEditorStateService.isSavingCollection()).toBe(false);\n    }\n  );\n});'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/TrainingModalService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service which handles opening and closing\n * the training modal used for unresolved answers.\n */\n\noppia.factory(\'TrainingModalService\', [\n  \'$rootScope\', \'$uibModal\', \'AlertsService\', \'UrlInterpolationService\',\n  function($rootScope, $uibModal, AlertsService, UrlInterpolationService) {\n    return {\n      /**\n      * Opens unresolved answer trainer modal for given answer.\n      * @param {Object} unhandledAnswer - The answer to be trained.\n      * @param {requestCallback} finishTrainingCallback - Function to call when\n          answer has been trained.\n      */\n      openTrainUnresolvedAnswerModal: function(\n          unhandledAnswer, finishTrainingCallback) {\n        AlertsService.clearWarnings();\n        $uibModal.open({\n          templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_editor/editor_tab/\' +\n            \'training_unresolved_answer_modal_directive.html\'),\n          backdrop: true,\n          controller: [\n            \'$scope\', \'$injector\', \'$uibModalInstance\',\n            \'ExplorationStatesService\', \'StateEditorService\',\n            \'AnswerClassificationService\', \'ContextService\',\n            \'StateInteractionIdService\', \'AngularNameService\',\n            \'ResponsesService\', \'TrainingDataService\',\n            \'StateContentIdsToAudioTranslationsService\',\n            \'AnswerGroupObjectFactory\', \'GraphDataService\',\n            \'ExplorationWarningsService\',\n            function($scope, $injector, $uibModalInstance,\n                ExplorationStatesService, StateEditorService,\n                AnswerClassificationService, ContextService,\n                StateInteractionIdService, AngularNameService,\n                ResponsesService, TrainingDataService,\n                StateContentIdsToAudioTranslationsService,\n                AnswerGroupObjectFactory, GraphDataService,\n                ExplorationWarningsService) {\n              $scope.trainingDataAnswer = \'\';\n\n              // See the training panel directive in ExplorationEditorTab for an\n              // explanation on the structure of this object.\n              $scope.classification = {\n                answerGroupIndex: 0,\n                newOutcome: null\n              };\n              $scope.addingNewResponse = false;\n\n              var _saveNewAnswerGroup = function(newAnswerGroup) {\n                var answerGroups = ResponsesService.getAnswerGroups();\n                var translationService = (\n                  StateContentIdsToAudioTranslationsService);\n                answerGroups.push(newAnswerGroup);\n                ResponsesService.save(\n                  answerGroups, ResponsesService.getDefaultOutcome(),\n                  function(newAnswerGroups, newDefaultOutcome) {\n                    ExplorationStatesService.saveInteractionAnswerGroups(\n                      StateEditorService.getActiveStateName(),\n                      angular.copy(newAnswerGroups));\n\n                    ExplorationStatesService.saveInteractionDefaultOutcome(\n                      StateEditorService.getActiveStateName(),\n                      angular.copy(newDefaultOutcome));\n\n                    GraphDataService.recompute();\n                    ExplorationWarningsService.updateWarnings();\n                  });\n                translationService.displayed.addContentId(\n                  newAnswerGroup.outcome.feedback.getContentId());\n                translationService.saveDisplayedValue();\n                ExplorationStatesService.saveContentIdsToAudioTranslations(\n                  translationService.stateName,\n                  angular.copy(translationService.displayed));\n              };\n\n              $scope.exitTrainer = function() {\n                $uibModalInstance.dismiss();\n              };\n\n              $scope.onConfirm = function() {\n                var index = $scope.classification.answerGroupIndex;\n\n                if (index > ResponsesService.getAnswerGroupCount()) {\n                  var newOutcome = $scope.classification.newOutcome;\n                  var newAnswerGroup = AnswerGroupObjectFactory.createNew(\n                    [], angular.copy(newOutcome), [unhandledAnswer], null);\n                  _saveNewAnswerGroup(newAnswerGroup);\n                  TrainingDataService.associateWithAnswerGroup(\n                    ResponsesService.getAnswerGroupCount() - 1,\n                    unhandledAnswer);\n                } else if (index === ResponsesService.getAnswerGroupCount()) {\n                  TrainingDataService.associateWithDefaultResponse(\n                    unhandledAnswer);\n                } else {\n                  TrainingDataService.associateWithAnswerGroup(\n                    index, unhandledAnswer);\n                }\n                $uibModalInstance.close();\n                finishTrainingCallback();\n              };\n\n              $scope.init = function() {\n                var explorationId =\n                  ContextService.getExplorationId();\n                var currentStateName =\n                  StateEditorService.getActiveStateName();\n                var state = ExplorationStatesService.getState(currentStateName);\n\n                // Retrieve the interaction ID.\n                var interactionId = StateInteractionIdService.savedMemento;\n\n                var rulesServiceName =\n                  AngularNameService.getNameOfInteractionRulesService(\n                    interactionId);\n\n                // Inject RulesService dynamically.\n                var rulesService = $injector.get(rulesServiceName);\n\n                var classificationResult = (\n                  AnswerClassificationService.getMatchingClassificationResult(\n                    currentStateName, state.interaction, unhandledAnswer,\n                    rulesService));\n                var feedback = \'Nothing\';\n                var dest = classificationResult.outcome.dest;\n                if (classificationResult.outcome.feedback.length > 0) {\n                  feedback = classificationResult.outcome.feedback.getHtml();\n                }\n                if (dest === currentStateName) {\n                  dest = \'<em>(try again)</em>\';\n                }\n\n                // $scope.trainingDataAnswer, $scope.trainingDataFeedback\n                // $scope.trainingDataOutcomeDest are intended to be local\n                // to this modal and should not be used to populate any\n                // information in the active exploration (including the\n                // feedback). The feedback here refers to a representation\n                // of the outcome of an answer group, rather than the\n                // specific feedback of the outcome (for instance, it\n                // includes the destination state within the feedback).\n                $scope.trainingDataAnswer = unhandledAnswer;\n                $scope.classification.answerGroupIndex = (\n                  classificationResult.answerGroupIndex);\n              };\n\n              $scope.init();\n            }]\n        });\n        // Save the modified training data externally in state content.\n        $rootScope.$broadcast(\'externalSave\');\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
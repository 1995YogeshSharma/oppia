from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'expressions/ExpressionTypeParserService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\noppia.factory(\'ExpressionTypeParserService\', [\n  \'$log\', \'ExpressionParserService\', \'ExpressionSyntaxTreeService\',\n  \'PARAMETER_TYPES\',\n  function(\n      $log, ExpressionParserService, ExpressionSyntaxTreeService,\n      PARAMETER_TYPES) {\n    var getExpressionOutputType = function(expression, envs) {\n      return ExpressionSyntaxTreeService.applyFunctionToParseTree(\n        ExpressionParserService.parse(expression), envs, getType);\n    };\n\n    /**\n     * @param {*} parsed Parse output from the parser. See parser.pegjs for\n     *     the data structure.\n     * @param {!Array.<!Object>} envs Represents a nested name space\n     *     environment to look up the name in. The first element is looked\n     *     up first (i.e. has higher precedence). The values of each Object\n     *     are strings representing a parameter type (i.e. they are equal to\n     *     values in the PARAMETER_TYPES object).\n     */\n    var getType = function(parsed, envs) {\n      // The intermediate nodes of the parse tree are arrays. The terminal\n      // nodes are JavaScript primitives (as described in the "Parser output"\n      // section of parser.pegjs).\n      if (parsed instanceof Array) {\n        if (parsed.length === 0) {\n          throw \'Parser generated an intermediate node with zero children\';\n        }\n\n        if (parsed[0] === \'#\') {\n          return ExpressionSyntaxTreeService.lookupEnvs(parsed[1], envs);\n        }\n\n        // Get the types of the arguments.\n        var args = parsed.slice(1).map(function(item) {\n          return getType(item, envs);\n        });\n\n        // The first element should be a function name.\n        return ExpressionSyntaxTreeService.lookupEnvs(\n          parsed[0], envs).getType(args);\n      }\n\n      // If \'parsed\' is not an array, it should be a terminal node with the\n      // actual value.\n      return (\n        isNaN(+parsed) ?\n          PARAMETER_TYPES.UNICODE_STRING :\n          PARAMETER_TYPES.REAL);\n    };\n\n    return {\n      getType: getType,\n      getExpressionOutputType: getExpressionOutputType\n    };\n  }\n]);'

blocks = {}
debug_info = ''
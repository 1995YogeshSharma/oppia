from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/library/Library.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Data and controllers for the Oppia contributors\' library page.\n */\n\n// NOTE TO DEVELOPERS: The constants defined below in LIBRARY_PAGE_MODES should\n// be same as the LIBRARY_PAGE_MODE constants defined in feconf.py. For example\n// LIBRARY_PAGE_MODES.GROUP should have the same value as\n// LIBRARY_PAGE_MODE_GROUP in feconf.py.\noppia.constant(\'LIBRARY_PAGE_MODES\', {\n  GROUP: \'group\',\n  INDEX: \'index\',\n  SEARCH: \'search\'\n});\n\noppia.controller(\'Library\', [\n  \'$scope\', \'$http\', \'$log\', \'$uibModal\', \'$rootScope\', \'$window\', \'$timeout\',\n  \'ConstructTranslationIdsService\', \'UrlService\', \'ALL_CATEGORIES\',\n  \'SearchService\', \'WindowDimensionsService\', \'UrlInterpolationService\',\n  \'LIBRARY_PAGE_MODES\', \'LIBRARY_TILE_WIDTH_PX\', \'AlertsService\',\n  \'LearnerDashboardIdsBackendApiService\',\n  \'LearnerDashboardActivityIdsObjectFactory\', \'LearnerPlaylistService\',\n  function(\n      $scope, $http, $log, $uibModal, $rootScope, $window, $timeout,\n      ConstructTranslationIdsService, UrlService, ALL_CATEGORIES,\n      SearchService, WindowDimensionsService, UrlInterpolationService,\n      LIBRARY_PAGE_MODES, LIBRARY_TILE_WIDTH_PX, AlertsService,\n      LearnerDashboardIdsBackendApiService,\n      LearnerDashboardActivityIdsObjectFactory, LearnerPlaylistService) {\n    $rootScope.loadingMessage = \'I18N_LIBRARY_LOADING\';\n    var possibleBannerFilenames = [\n      \'banner1.svg\', \'banner2.svg\', \'banner3.svg\', \'banner4.svg\'];\n    $scope.bannerImageFilename = possibleBannerFilenames[\n      Math.floor(Math.random() * possibleBannerFilenames.length)];\n\n    $scope.bannerImageFileUrl = UrlInterpolationService.getStaticImageUrl(\n      \'/library/\' + $scope.bannerImageFilename);\n\n    $scope.activeGroupIndex = null;\n\n    $scope.pageMode = GLOBALS.PAGE_MODE;\n    $scope.LIBRARY_PAGE_MODES = LIBRARY_PAGE_MODES;\n\n    // Keeps track of the index of the left-most visible card of each group.\n    $scope.leftmostCardIndices = [];\n\n    if ($scope.pageMode === LIBRARY_PAGE_MODES.GROUP) {\n      var pathnameArray = $window.location.pathname.split(\'/\');\n      $scope.groupName = pathnameArray[2];\n\n      $http.get(\'/librarygrouphandler\', {\n        params: {\n          group_name: $scope.groupName\n        }\n      }).success(\n        function(data) {\n          $scope.activityList = data.activity_list;\n\n          $scope.groupHeaderI18nId = data.header_i18n_id;\n\n          $rootScope.$broadcast(\n            \'preferredLanguageCodesLoaded\', data.preferred_language_codes);\n\n          $rootScope.loadingMessage = \'\';\n        });\n    } else {\n      $http.get(\'/libraryindexhandler\').success(function(data) {\n        $scope.libraryGroups = data.activity_summary_dicts_by_category;\n\n        $scope.userIsLoggedIn = GLOBALS.userIsLoggedIn;\n        $scope.activitiesOwned = {explorations: {}, collections: {}};\n        if ($scope.userIsLoggedIn) {\n          $http.get(\'/creatordashboardhandler/data\')\n            .then(function(response) {\n              $scope.libraryGroups.forEach(function(libraryGroup) {\n                var activitySummaryDicts = libraryGroup.activity_summary_dicts;\n\n                var ACTIVITY_TYPE_EXPLORATION = \'exploration\';\n                var ACTIVITY_TYPE_COLLECTION = \'collection\';\n                activitySummaryDicts.forEach(function(activitySummaryDict) {\n                  if (activitySummaryDict.activity_type === (\n                    ACTIVITY_TYPE_EXPLORATION)) {\n                    $scope.activitiesOwned.explorations[\n                      activitySummaryDict.id] = false;\n                  } else if (activitySummaryDict.activity_type === (\n                    ACTIVITY_TYPE_COLLECTION)) {\n                    $scope.activitiesOwned.collections[\n                      activitySummaryDict.id] = false;\n                  } else {\n                    $log.error(\'INVALID ACTIVITY TYPE: Activity\' +\n                    \'(id: \' + activitySummaryDict.id +\n                    \', name: \' + activitySummaryDict.title +\n                    \', type: \' + activitySummaryDict.activity_type +\n                    \') has an invalid activity type, which could \' +\n                    \'not be recorded as an exploration or a collection.\');\n                  }\n                });\n\n                response.data.explorations_list\n                  .forEach(function(ownedExplorations) {\n                    $scope.activitiesOwned.explorations[\n                      ownedExplorations.id] = true;\n                  });\n\n                response.data.collections_list\n                  .forEach(function(ownedCollections) {\n                    $scope.activitiesOwned.collections[\n                      ownedCollections.id] = true;\n                  });\n              });\n            });\n        }\n\n        $rootScope.$broadcast(\n          \'preferredLanguageCodesLoaded\', data.preferred_language_codes);\n\n        $rootScope.loadingMessage = \'\';\n\n        // Initialize the carousel(s) on the library index page.\n        // Pause is necessary to ensure all elements have loaded.\n        $timeout(initCarousels, 390);\n\n\n        // Check if actual and expected widths are the same.\n        // If not produce an error that would be caught by e2e tests.\n        $timeout(function() {\n          var actualWidth = $(\'exploration-summary-tile\').width();\n          if (actualWidth && actualWidth !== LIBRARY_TILE_WIDTH_PX) {\n            console.error(\n              \'The actual width of tile is different than the expected width.\' +\n              \' Actual size: \' + actualWidth + \', Expected size: \' +\n              LIBRARY_TILE_WIDTH_PX);\n          }\n        }, 3000);\n        // The following initializes the tracker to have all\n        // elements flush left.\n        // Transforms the group names into translation ids\n        $scope.leftmostCardIndices = [];\n        for (i = 0; i < $scope.libraryGroups.length; i++) {\n          $scope.leftmostCardIndices.push(0);\n        }\n      });\n    }\n\n    $scope.setActiveGroup = function(groupIndex) {\n      $scope.activeGroupIndex = groupIndex;\n    };\n\n    $scope.clearActiveGroup = function() {\n      $scope.activeGroupIndex = null;\n    };\n\n    // If the value below is changed, the following CSS values in oppia.css\n    // must be changed:\n    // - .oppia-exp-summary-tiles-container: max-width\n    // - .oppia-library-carousel: max-width\n    var MAX_NUM_TILES_PER_ROW = 4;\n    $scope.tileDisplayCount = 0;\n\n    var initCarousels = function() {\n      // This prevents unnecessary execution of this method immediately after\n      // a window resize event is fired.\n      if (!$scope.libraryGroups) {\n        return;\n      }\n\n      var windowWidth = $(window).width() * 0.85;\n      // The number 20 is added to LIBRARY_TILE_WIDTH_PX in order to compensate\n      // for padding and margins. 20 is just an arbitrary number.\n      $scope.tileDisplayCount = Math.min(\n        Math.floor(windowWidth / (LIBRARY_TILE_WIDTH_PX + 20)),\n        MAX_NUM_TILES_PER_ROW);\n\n      $(\'.oppia-library-carousel\').css({\n        width: ($scope.tileDisplayCount * LIBRARY_TILE_WIDTH_PX) + \'px\'\n      });\n\n      // The following determines whether to enable left scroll after resize.\n      for (var i = 0; i < $scope.libraryGroups.length; i++) {\n        var carouselJQuerySelector = (\n          \'.oppia-library-carousel-tiles:eq(n)\'.replace(\'n\', i));\n        var carouselScrollPositionPx = $(carouselJQuerySelector).scrollLeft();\n        var index = Math.ceil(carouselScrollPositionPx / LIBRARY_TILE_WIDTH_PX);\n        $scope.leftmostCardIndices[i] = index;\n      }\n    };\n\n    var isAnyCarouselCurrentlyScrolling = false;\n\n    $scope.scroll = function(ind, isLeftScroll) {\n      if (isAnyCarouselCurrentlyScrolling) {\n        return;\n      }\n      var carouselJQuerySelector = (\n        \'.oppia-library-carousel-tiles:eq(n)\'.replace(\'n\', ind));\n\n      var direction = isLeftScroll ? -1 : 1;\n      var carouselScrollPositionPx = $(carouselJQuerySelector).scrollLeft();\n\n      // Prevent scrolling if there more carousel pixed widths than\n      // there are tile widths.\n      if ($scope.libraryGroups[ind].activity_summary_dicts.length <=\n          $scope.tileDisplayCount) {\n        return;\n      }\n\n      carouselScrollPositionPx = Math.max(0, carouselScrollPositionPx);\n\n      if (isLeftScroll) {\n        $scope.leftmostCardIndices[ind] = Math.max(\n          0, $scope.leftmostCardIndices[ind] - $scope.tileDisplayCount);\n      } else {\n        $scope.leftmostCardIndices[ind] = Math.min(\n          $scope.libraryGroups[ind].activity_summary_dicts.length -\n            $scope.tileDisplayCount + 1,\n          $scope.leftmostCardIndices[ind] + $scope.tileDisplayCount);\n      }\n\n      var newScrollPositionPx = carouselScrollPositionPx +\n        ($scope.tileDisplayCount * LIBRARY_TILE_WIDTH_PX * direction);\n\n      $(carouselJQuerySelector).animate({\n        scrollLeft: newScrollPositionPx\n      }, {\n        duration: 800,\n        queue: false,\n        start: function() {\n          isAnyCarouselCurrentlyScrolling = true;\n        },\n        complete: function() {\n          isAnyCarouselCurrentlyScrolling = false;\n        }\n      });\n    };\n\n    // The carousels do not work when the width is 1 card long, so we need to\n    // handle this case discretely.\n    $scope.incrementLeftmostCardIndex = function(ind) {\n      $scope.leftmostCardIndices[ind]++;\n    };\n    $scope.decrementLeftmostCardIndex = function(ind) {\n      $scope.leftmostCardIndices[ind]--;\n    };\n\n    $(window).resize(function() {\n      initCarousels();\n      // This is needed, otherwise $scope.tileDisplayCount takes a long time\n      // (several seconds) to update.\n      $scope.$apply();\n    });\n\n    var activateSearchMode = function() {\n      if ($scope.pageMode !== LIBRARY_PAGE_MODES.SEARCH) {\n        $(\'.oppia-library-container\').fadeOut(function() {\n          $scope.pageMode = LIBRARY_PAGE_MODES.SEARCH;\n          $timeout(function() {\n            $(\'.oppia-library-container\').fadeIn();\n          }, 50);\n        });\n      }\n    };\n\n    // The following loads explorations belonging to a particular group. If\n    // fullResultsUrl is given it loads the page corresponding to the url.\n    // Otherwise, it will initiate a search query for the given list of\n    // categories.\n    $scope.showFullResultsPage = function(categories, fullResultsUrl) {\n      if (fullResultsUrl) {\n        $window.location.href = fullResultsUrl;\n      } else {\n        var selectedCategories = {};\n        for (i = 0; i < categories.length; i++) {\n          selectedCategories[categories[i]] = true;\n        }\n\n        var targetSearchQueryUrl = SearchService.getSearchUrlQueryString(\n          \'\', selectedCategories, {});\n        $window.location.href = \'/search/find?q=\' + targetSearchQueryUrl;\n      }\n    };\n\n    var libraryWindowCutoffPx = 530;\n    $scope.libraryWindowIsNarrow = (\n      WindowDimensionsService.getWidth() <= libraryWindowCutoffPx);\n\n    WindowDimensionsService.registerOnResizeHook(function() {\n      $scope.libraryWindowIsNarrow = (\n        WindowDimensionsService.getWidth() <= libraryWindowCutoffPx);\n      $scope.$apply();\n    });\n  }\n]);'

blocks = {}
debug_info = ''
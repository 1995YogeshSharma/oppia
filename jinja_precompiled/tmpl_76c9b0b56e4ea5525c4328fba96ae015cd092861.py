from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/ExplorationPropertyService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Services for storing exploration properties for\n * displaying and editing them in multiple places in the UI,\n * with base class as ExplorationPropertyService.\n */\n\noppia.factory(\'ExplorationPropertyService\', [\n  \'$rootScope\', \'$log\', \'ChangeListService\', \'AlertsService\',\n  function($rootScope, $log, ChangeListService, AlertsService) {\n    // Public base API for data services corresponding to exploration properties\n    // (title, category, etc.)\n\n    var BACKEND_CONVERSIONS = {\n      param_changes: function(paramChanges) {\n        return paramChanges.map(function(paramChange) {\n          return paramChange.toBackendDict();\n        });\n      },\n      param_specs: function(paramSpecs) {\n        return paramSpecs.toBackendDict();\n      },\n    };\n\n    return {\n      init: function(value) {\n        if (this.propertyName === null) {\n          throw \'Exploration property name cannot be null.\';\n        }\n\n        $log.info(\'Initializing exploration \' + this.propertyName + \':\', value);\n\n        // The current value of the property (which may not have been saved to\n        // the frontend yet). In general, this will be bound directly to the UI.\n        this.displayed = angular.copy(value);\n        // The previous (saved-in-the-frontend) value of the property. Here,\n        // \'saved\' means that this is the latest value of the property as\n        // determined by the frontend change list.\n        this.savedMemento = angular.copy(value);\n\n        $rootScope.$broadcast(\'explorationPropertyChanged\');\n      },\n      // Returns whether the current value has changed from the memento.\n      hasChanged: function() {\n        return !angular.equals(this.savedMemento, this.displayed);\n      },\n      // The backend name for this property. THIS MUST BE SPECIFIED BY\n      // SUBCLASSES.\n      propertyName: null,\n      // Transforms the given value into a normalized form. THIS CAN BE\n      // OVERRIDDEN BY SUBCLASSES. The default behavior is to do nothing.\n      _normalize: function(value) {\n        return value;\n      },\n      // Validates the given value and returns a boolean stating whether it\n      // is valid or not. THIS CAN BE OVERRIDDEN BY SUBCLASSES. The default\n      // behavior is to always return true.\n      _isValid: function(value) {\n        return true;\n      },\n      // Normalizes the displayed value. Then, if the memento and the displayed\n      // value are the same, does nothing. Otherwise, creates a new entry in the\n      // change list, and updates the memento to the displayed value.\n      saveDisplayedValue: function() {\n        if (this.propertyName === null) {\n          throw \'Exploration property name cannot be null.\';\n        }\n\n        this.displayed = this._normalize(this.displayed);\n\n        if (!this._isValid(this.displayed) || !this.hasChanged()) {\n          this.restoreFromMemento();\n          return;\n        }\n\n        if (angular.equals(this.displayed, this.savedMemento)) {\n          return;\n        }\n\n        AlertsService.clearWarnings();\n\n        var newBackendValue = angular.copy(this.displayed);\n        var oldBackendValue = angular.copy(this.savedMemento);\n\n        if (BACKEND_CONVERSIONS.hasOwnProperty(this.propertyName)) {\n          newBackendValue =\n            BACKEND_CONVERSIONS[this.propertyName](this.displayed);\n          oldBackendValue =\n            BACKEND_CONVERSIONS[this.propertyName](this.savedMemento);\n        }\n\n        ChangeListService.editExplorationProperty(\n          this.propertyName, newBackendValue, oldBackendValue);\n        this.savedMemento = angular.copy(this.displayed);\n\n        $rootScope.$broadcast(\'explorationPropertyChanged\');\n      },\n      // Reverts the displayed value to the saved memento.\n      restoreFromMemento: function() {\n        this.displayed = angular.copy(this.savedMemento);\n      }\n    };\n  }\n]);\n\n// A data service that stores the current exploration title so that it can be\n// displayed and edited in multiple places in the UI.\noppia.factory(\'ExplorationTitleService\', [\n  \'ExplorationPropertyService\', \'$filter\', \'ValidatorsService\',\n  \'ExplorationRightsService\',\n  function(\n      ExplorationPropertyService, $filter, ValidatorsService,\n      ExplorationRightsService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'title\';\n    child._normalize = $filter(\'normalizeWhitespace\');\n    child._isValid = function(value) {\n      return ValidatorsService.isValidEntityName(\n        value, true, ExplorationRightsService.isPrivate());\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the current exploration category so that it can be\n// displayed and edited in multiple places in the UI.\noppia.factory(\'ExplorationCategoryService\', [\n  \'ExplorationPropertyService\', \'$filter\', \'ValidatorsService\',\n  \'ExplorationRightsService\',\n  function(\n      ExplorationPropertyService, $filter, ValidatorsService,\n      ExplorationRightsService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'category\';\n    child._normalize = $filter(\'normalizeWhitespace\');\n    child._isValid = function(value) {\n      return ValidatorsService.isValidEntityName(\n        value, true, ExplorationRightsService.isPrivate());\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the current exploration objective so that it can\n// be displayed and edited in multiple places in the UI.\noppia.factory(\'ExplorationObjectiveService\', [\n  \'ExplorationPropertyService\', \'$filter\', \'ValidatorsService\',\n  \'ExplorationRightsService\',\n  function(\n      ExplorationPropertyService, $filter, ValidatorsService,\n      ExplorationRightsService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'objective\';\n    child._normalize = $filter(\'normalizeWhitespace\');\n    child._isValid = function(value) {\n      return (\n        ExplorationRightsService.isPrivate() ||\n        ValidatorsService.isNonempty(value, false));\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the exploration language code.\noppia.factory(\'ExplorationLanguageCodeService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'language_code\';\n    child.getAllLanguageCodes = function() {\n      // TODO(sll): Update this once the App Engine search service supports\n      // 3-letter language codes.\n      return constants.ALL_LANGUAGE_CODES.filter(function(languageCodeDict) {\n        return languageCodeDict.code.length === 2;\n      });\n    };\n    child.getCurrentLanguageDescription = function() {\n      for (var i = 0; i < constants.ALL_LANGUAGE_CODES.length; i++) {\n        if (constants.ALL_LANGUAGE_CODES[i].code === child.displayed) {\n          return constants.ALL_LANGUAGE_CODES[i].description;\n        }\n      }\n    };\n    child._isValid = function(value) {\n      return constants.ALL_LANGUAGE_CODES.some(function(elt) {\n        // TODO(sll): Remove the second clause once the App Engine search\n        // service supports 3-letter language codes.\n        return elt.code === value && elt.code.length === 2;\n      });\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the name of the exploration\'s initial state.\n// NOTE: This service does not perform validation. Users of this service\n// should ensure that new initial state names passed to the service are\n// valid.\noppia.factory(\'ExplorationInitStateNameService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'init_state_name\';\n    return child;\n  }\n]);\n\n// A data service that stores tags for the exploration.\noppia.factory(\'ExplorationTagsService\', [\n  \'ExplorationPropertyService\',\n  function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'tags\';\n    child._normalize = function(value) {\n      for (var i = 0; i < value.length; i++) {\n        value[i] = value[i].trim().replace(/\\s+/g, \' \');\n      }\n      // TODO(sll): Prevent duplicate tags from being added.\n      return value;\n    };\n    child._isValid = function(value) {\n      // Every tag should match the TAG_REGEX.\n      for (var i = 0; i < value.length; i++) {\n        var tagRegex = new RegExp(GLOBALS.TAG_REGEX);\n        if (!value[i].match(tagRegex)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n    return child;\n  }\n]);\n\noppia.factory(\'ExplorationParamSpecsService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'param_specs\';\n    return child;\n  }\n]);\n\noppia.factory(\'ExplorationParamChangesService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'param_changes\';\n    return child;\n  }\n]);\n\noppia.factory(\'ExplorationAutomaticTextToSpeechService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'auto_tts_enabled\';\n\n    child._isValid = function(value) {\n      return (typeof value === \'boolean\');\n    };\n\n    child.isAutomaticTextToSpeechEnabled = function() {\n      return child.savedMemento;\n    };\n\n    child.toggleAutomaticTextToSpeech = function() {\n      child.displayed = !child.displayed;\n      child.saveDisplayedValue();\n    };\n\n    return child;\n  }\n]);\n\noppia.factory(\'ExplorationCorrectnessFeedbackService\', [\n  \'ExplorationPropertyService\', function(ExplorationPropertyService) {\n    var child = Object.create(ExplorationPropertyService);\n    child.propertyName = \'correctness_feedback_enabled\';\n\n    child._isValid = function(value) {\n      return (typeof value === \'boolean\');\n    };\n\n    child.isEnabled = function() {\n      return child.savedMemento;\n    };\n\n    child.toggleCorrectnessFeedback = function() {\n      child.displayed = !child.displayed;\n      child.saveDisplayedValue();\n    };\n\n    return child;\n  }\n]);\n\n// Data service for keeping track of the exploration\'s states. Note that this\n// is unlike the other exploration property services, in that it keeps no\n// mementos.\noppia.factory(\'ExplorationStatesService\', [\n  \'$log\', \'$uibModal\', \'$filter\', \'$location\', \'$rootScope\', \'$injector\', \'$q\',\n  \'ExplorationInitStateNameService\', \'AlertsService\', \'ChangeListService\',\n  \'EditorStateService\', \'ValidatorsService\', \'StatesObjectFactory\',\n  \'SolutionValidityService\', \'AngularNameService\',\n  \'AnswerClassificationService\', \'ExplorationContextService\',\n  \'UrlInterpolationService\',\n  function(\n      $log, $uibModal, $filter, $location, $rootScope, $injector, $q,\n      ExplorationInitStateNameService, AlertsService, ChangeListService,\n      EditorStateService, ValidatorsService, StatesObjectFactory,\n      SolutionValidityService, AngularNameService,\n      AnswerClassificationService, ExplorationContextService,\n      UrlInterpolationService) {\n    var _states = null;\n    // Properties that have a different backend representation from the\n    // frontend and must be converted.\n\n    var BACKEND_CONVERSIONS = {\n      answer_groups: function(answerGroups) {\n        return answerGroups.map(function(answerGroup) {\n          return answerGroup.toBackendDict();\n        });\n      },\n      content: function(content) {\n        return content.toBackendDict();\n      },\n      default_outcome: function(defaultOutcome) {\n        if (defaultOutcome) {\n          return defaultOutcome.toBackendDict();\n        } else {\n          return null;\n        }\n      },\n      hints: function(hints) {\n        return hints.map(function(hint) {\n          return hint.toBackendDict();\n        });\n      },\n      param_changes: function(paramChanges) {\n        return paramChanges.map(function(paramChange) {\n          return paramChange.toBackendDict();\n        });\n      },\n      param_specs: function(paramSpecs) {\n        return paramSpecs.toBackendDict();\n      },\n      solution: function(solution) {\n        if (solution) {\n          return solution.toBackendDict();\n        } else {\n          return null;\n        }\n      }\n    };\n\n    // Maps backend names to the corresponding frontend dict accessor lists.\n    var PROPERTY_REF_DATA = {\n      answer_groups: [\'interaction\', \'answerGroups\'],\n      confirmed_unclassified_answers: [\n        \'interaction\', \'confirmedUnclassifiedAnswers\'],\n      content: [\'content\'],\n      default_outcome: [\'interaction\', \'defaultOutcome\'],\n      param_changes: [\'paramChanges\'],\n      param_specs: [\'paramSpecs\'],\n      hints: [\'interaction\', \'hints\'],\n      solution: [\'interaction\', \'solution\'],\n      widget_id: [\'interaction\', \'id\'],\n      widget_customization_args: [\'interaction\', \'customizationArgs\']\n    };\n\n    var _setState = function(stateName, stateData, refreshGraph) {\n      _states.setState(stateName, angular.copy(stateData));\n      if (refreshGraph) {\n        $rootScope.$broadcast(\'refreshGraph\');\n      }\n    };\n\n    var getStatePropertyMemento = function(stateName, backendName) {\n      var accessorList = PROPERTY_REF_DATA[backendName];\n      var propertyRef = _states.getState(stateName);\n      accessorList.forEach(function(key) {\n        propertyRef = propertyRef[key];\n      });\n\n      return angular.copy(propertyRef);\n    };\n\n    var saveStateProperty = function(stateName, backendName, newValue) {\n      var oldValue = getStatePropertyMemento(stateName, backendName);\n      var newBackendValue = angular.copy(newValue);\n      var oldBackendValue = angular.copy(oldValue);\n\n      if (BACKEND_CONVERSIONS.hasOwnProperty(backendName)) {\n        newBackendValue = convertToBackendRepresentation(newValue, backendName);\n        oldBackendValue = convertToBackendRepresentation(oldValue, backendName);\n      }\n\n      if (!angular.equals(oldValue, newValue)) {\n        ChangeListService.editStateProperty(\n          stateName, backendName, newBackendValue, oldBackendValue);\n\n        var newStateData = _states.getState(stateName);\n        var accessorList = PROPERTY_REF_DATA[backendName];\n\n        var propertyRef = newStateData;\n        for (var i = 0; i < accessorList.length - 1; i++) {\n          propertyRef = propertyRef[accessorList[i]];\n        }\n\n        propertyRef[accessorList[accessorList.length - 1]] = angular.copy(\n          newValue);\n\n        // We do not refresh the state editor immediately after the interaction\n        // id alone is saved, because the customization args dict will be\n        // temporarily invalid. A change in interaction id will always entail\n        // a change in the customization args dict anyway, so the graph will\n        // get refreshed after both properties have been updated.\n        var refreshGraph = (backendName !== \'widget_id\');\n        _setState(stateName, newStateData, refreshGraph);\n      }\n    };\n\n    var convertToBackendRepresentation = function(frontendValue, backendName) {\n      var conversionFunction = BACKEND_CONVERSIONS[backendName];\n      return conversionFunction(frontendValue);\n    };\n\n    // TODO(sll): Add unit tests for all get/save methods.\n    return {\n      init: function(statesBackendDict) {\n        _states = StatesObjectFactory.createFromBackendDict(statesBackendDict);\n        // Initialize the solutionValidityService.\n        SolutionValidityService.init(_states.getStateNames());\n        _states.getStateNames().forEach(function(stateName) {\n          var solution = _states.getState(stateName).interaction.solution;\n          if (solution) {\n            var result = (\n              AnswerClassificationService.getMatchingClassificationResult(\n                ExplorationContextService.getExplorationId(),\n                stateName,\n                _states.getState(stateName),\n                solution.correctAnswer,\n                $injector.get(\n                  AngularNameService.getNameOfInteractionRulesService(\n                    _states.getState(stateName).interaction.id))));\n            var solutionIsValid = stateName !== result.outcome.dest;\n            SolutionValidityService.updateValidity(\n              stateName, solutionIsValid);\n          }\n        });\n      },\n      getStates: function() {\n        return angular.copy(_states);\n      },\n      getStateNames: function() {\n        return _states.getStateNames();\n      },\n      hasState: function(stateName) {\n        return _states.hasState(stateName);\n      },\n      getState: function(stateName) {\n        return angular.copy(_states.getState(stateName));\n      },\n      setState: function(stateName, stateData) {\n        _setState(stateName, stateData, true);\n      },\n      isNewStateNameValid: function(newStateName, showWarnings) {\n        if (_states.hasState(newStateName)) {\n          if (showWarnings) {\n            AlertsService.addWarning(\'A state with this name already exists.\');\n          }\n          return false;\n        }\n        return (\n          ValidatorsService.isValidStateName(newStateName, showWarnings));\n      },\n      isSolutionValid: function(stateName) {\n        return SolutionValidityService.isSolutionValid(stateName);\n      },\n      updateSolutionValidity: function(stateName, solutionIsValid) {\n        SolutionValidityService.updateValidity(stateName, solutionIsValid);\n      },\n      deleteSolutionValidity: function(stateName) {\n        SolutionValidityService.deleteSolutionValidity(stateName);\n      },\n      getStateContentMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'content\');\n      },\n      saveStateContent: function(stateName, newContent) {\n        saveStateProperty(stateName, \'content\', newContent);\n      },\n      getStateParamChangesMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'param_changes\');\n      },\n      saveStateParamChanges: function(stateName, newParamChanges) {\n        saveStateProperty(stateName, \'param_changes\', newParamChanges);\n      },\n      getInteractionIdMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'widget_id\');\n      },\n      saveInteractionId: function(stateName, newInteractionId) {\n        saveStateProperty(stateName, \'widget_id\', newInteractionId);\n      },\n      getInteractionCustomizationArgsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'widget_customization_args\');\n      },\n      saveInteractionCustomizationArgs: function(\n          stateName, newCustomizationArgs) {\n        saveStateProperty(\n          stateName, \'widget_customization_args\', newCustomizationArgs);\n      },\n      getInteractionAnswerGroupsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'answer_groups\');\n      },\n      saveInteractionAnswerGroups: function(stateName, newAnswerGroups) {\n        saveStateProperty(stateName, \'answer_groups\', newAnswerGroups);\n      },\n      getConfirmedUnclassifiedAnswersMemento: function(stateName) {\n        return getStatePropertyMemento(\n          stateName, \'confirmed_unclassified_answers\');\n      },\n      saveConfirmedUnclassifiedAnswers: function(stateName, newAnswers) {\n        saveStateProperty(\n          stateName, \'confirmed_unclassified_answers\', newAnswers);\n      },\n      getInteractionDefaultOutcomeMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'default_outcome\');\n      },\n      saveInteractionDefaultOutcome: function(stateName, newDefaultOutcome) {\n        saveStateProperty(stateName, \'default_outcome\', newDefaultOutcome);\n      },\n      getHintsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'hints\');\n      },\n      saveHints: function(stateName, newHints) {\n        saveStateProperty(stateName, \'hints\', newHints);\n      },\n      getSolutionMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'solution\');\n      },\n      saveSolution: function(stateName, newSolution) {\n        saveStateProperty(stateName, \'solution\', newSolution);\n      },\n      isInitialized: function() {\n        return _states !== null;\n      },\n      addState: function(newStateName, successCallback) {\n        newStateName = $filter(\'normalizeWhitespace\')(newStateName);\n        if (!ValidatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (_states.hasState(newStateName)) {\n          AlertsService.addWarning(\'A state with this name already exists.\');\n          return;\n        }\n        AlertsService.clearWarnings();\n\n        _states.addState(newStateName);\n\n        ChangeListService.addState(newStateName);\n        $rootScope.$broadcast(\'refreshGraph\');\n        if (successCallback) {\n          successCallback(newStateName);\n        }\n      },\n      deleteState: function(deleteStateName) {\n        AlertsService.clearWarnings();\n\n        var initStateName = ExplorationInitStateNameService.displayed;\n        if (deleteStateName === initStateName) {\n          return;\n        }\n        if (!_states.hasState(deleteStateName)) {\n          AlertsService.addWarning(\n            \'No state with name \' + deleteStateName + \' exists.\');\n          return;\n        }\n\n        $uibModal.open({\n          templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_editor/editor_tab/\' +\n            \'confirm_delete_state_modal_directive.html\'),\n          backdrop: true,\n          resolve: {\n            deleteStateName: function() {\n              return deleteStateName;\n            }\n          },\n          controller: [\n            \'$scope\', \'$uibModalInstance\', \'deleteStateName\',\n            function($scope, $uibModalInstance, deleteStateName) {\n              $scope.deleteStateWarningText = (\n                \'Are you sure you want to delete the card "\' +\n                deleteStateName + \'"?\');\n\n              $scope.reallyDelete = function() {\n                $uibModalInstance.close(deleteStateName);\n              };\n\n              $scope.cancel = function() {\n                $uibModalInstance.dismiss(\'cancel\');\n                AlertsService.clearWarnings();\n              };\n            }\n          ]\n        }).result.then(function(deleteStateName) {\n          _states.deleteState(deleteStateName);\n\n          ChangeListService.deleteState(deleteStateName);\n\n          if (EditorStateService.getActiveStateName() === deleteStateName) {\n            EditorStateService.setActiveStateName(\n              ExplorationInitStateNameService.savedMemento);\n          }\n\n          $location.path(\'/gui/\' + EditorStateService.getActiveStateName());\n          $rootScope.$broadcast(\'refreshGraph\');\n          // This ensures that if the deletion changes rules in the current\n          // state, they get updated in the view.\n          $rootScope.$broadcast(\'refreshStateEditor\');\n        });\n      },\n      renameState: function(oldStateName, newStateName) {\n        newStateName = $filter(\'normalizeWhitespace\')(newStateName);\n        if (!ValidatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (_states.hasState(newStateName)) {\n          AlertsService.addWarning(\'A state with this name already exists.\');\n          return;\n        }\n        AlertsService.clearWarnings();\n\n        _states.renameState(oldStateName, newStateName);\n\n        EditorStateService.setActiveStateName(newStateName);\n        // The \'rename state\' command must come before the \'change\n        // init_state_name\' command in the change list, otherwise the backend\n        // will raise an error because the new initial state name does not\n        // exist.\n        ChangeListService.renameState(newStateName, oldStateName);\n        // Amend initStateName appropriately, if necessary. Note that this\n        // must come after the state renaming, otherwise saving will lead to\n        // a complaint that the new name is not a valid state name.\n        if (ExplorationInitStateNameService.displayed === oldStateName) {\n          ExplorationInitStateNameService.displayed = newStateName;\n          ExplorationInitStateNameService.saveDisplayedValue(newStateName);\n        }\n        $rootScope.$broadcast(\'refreshGraph\');\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
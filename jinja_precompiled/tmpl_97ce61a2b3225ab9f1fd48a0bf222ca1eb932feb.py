from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/ChangeListService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A service that maintains a provisional list of changes to be\n * committed to the server.\n */\n\noppia.factory(\'ChangeListService\', [\n  \'$rootScope\', \'$log\', \'AlertsService\', \'ExplorationDataService\',\n  \'AutosaveInfoModalsService\',\n  function(\n      $rootScope, $log, AlertsService, ExplorationDataService,\n      AutosaveInfoModalsService) {\n    // TODO(sll): Implement undo, redo functionality. Show a message on each\n    // step saying what the step is doing.\n    // TODO(sll): Allow the user to view the list of changes made so far, as\n    // well as the list of changes in the undo stack.\n\n    // Temporary buffer for changes made to the exploration.\n    var explorationChangeList = [];\n    // Stack for storing undone changes. The last element is the most recently\n    // undone change.\n    var undoneChangeStack = [];\n\n    // All these constants should correspond to those in exp_domain.py.\n    // TODO(sll): Enforce this in code.\n    var CMD_ADD_STATE = \'add_state\';\n    var CMD_RENAME_STATE = \'rename_state\';\n    var CMD_DELETE_STATE = \'delete_state\';\n    var CMD_EDIT_STATE_PROPERTY = \'edit_state_property\';\n    var CMD_EDIT_EXPLORATION_PROPERTY = \'edit_exploration_property\';\n\n    var ALLOWED_EXPLORATION_BACKEND_NAMES = {\n      category: true,\n      init_state_name: true,\n      language_code: true,\n      objective: true,\n      param_changes: true,\n      param_specs: true,\n      tags: true,\n      title: true,\n      auto_tts_enabled: true,\n      correctness_feedback_enabled: true\n    };\n\n    var ALLOWED_STATE_BACKEND_NAMES = {\n      answer_groups: true,\n      confirmed_unclassified_answers: true,\n      content: true,\n      default_outcome: true,\n      hints: true,\n      param_changes: true,\n      param_specs: true,\n      solution: true,\n      state_name: true,\n      widget_customization_args: true,\n      widget_id: true\n    };\n\n    var autosaveChangeListOnChange = function(explorationChangeList) {\n      // Asynchronously send an autosave request, and check for errors in the\n      // response:\n      // If error is present -> Check for the type of error occurred\n      // (Display the corresponding modals in both cases, if not already\n      // opened):\n      // - Version Mismatch.\n      // - Non-strict Validation Fail.\n      ExplorationDataService.autosaveChangeList(\n        explorationChangeList,\n        function(response) {\n          if (!response.data.is_version_of_draft_valid) {\n            if (!AutosaveInfoModalsService.isModalOpen()) {\n              AutosaveInfoModalsService.showVersionMismatchModal(\n                explorationChangeList);\n            }\n          }\n        },\n        function() {\n          AlertsService.clearWarnings();\n          $log.error(\n            \'nonStrictValidationFailure: \' +\n            JSON.stringify(explorationChangeList));\n          if (!AutosaveInfoModalsService.isModalOpen()) {\n            AutosaveInfoModalsService.showNonStrictValidationFailModal();\n          }\n        }\n      );\n    };\n\n    var addChange = function(changeDict) {\n      if ($rootScope.loadingMessage) {\n        return;\n      }\n      explorationChangeList.push(changeDict);\n      undoneChangeStack = [];\n      autosaveChangeListOnChange(explorationChangeList);\n    };\n\n    return {\n      /**\n       * Saves a change dict that represents adding a new state. It is the\n       * responsbility of the caller to check that the new state name is valid.\n       *\n       * @param {string} stateName - The name of the newly-added state\n       */\n      addState: function(stateName) {\n        addChange({\n          cmd: CMD_ADD_STATE,\n          state_name: stateName\n        });\n      },\n      /**\n       * Saves a change dict that represents deleting a new state. It is the\n       * responsbility of the caller to check that the deleted state name\n       * corresponds to an existing state.\n       *\n       * @param {string} stateName - The name of the deleted state.\n       */\n      deleteState: function(stateName) {\n        addChange({\n          cmd: CMD_DELETE_STATE,\n          state_name: stateName\n        });\n      },\n      discardAllChanges: function() {\n        explorationChangeList = [];\n        undoneChangeStack = [];\n        ExplorationDataService.discardDraft();\n      },\n      /**\n       * Saves a change dict that represents a change to an exploration\n       * property (such as its title, category, ...). It is the responsibility\n       * of the caller to check that the old and new values are not equal.\n       *\n       * @param {string} backendName - The backend name of the property\n       *   (e.g. title, category)\n       * @param {string} newValue - The new value of the property\n       * @param {string} oldValue - The previous value of the property\n       */\n      editExplorationProperty: function(backendName, newValue, oldValue) {\n        if (!ALLOWED_EXPLORATION_BACKEND_NAMES.hasOwnProperty(backendName)) {\n          AlertsService.addWarning(\n            \'Invalid exploration property: \' + backendName);\n          return;\n        }\n        addChange({\n          cmd: CMD_EDIT_EXPLORATION_PROPERTY,\n          new_value: angular.copy(newValue),\n          old_value: angular.copy(oldValue),\n          property_name: backendName\n        });\n      },\n      /**\n       * Saves a change dict that represents a change to a state property. It\n       * is the responsibility of the caller to check that the old and new\n       * values are not equal.\n       *\n       * @param {string} stateName - The name of the state that is being edited\n       * @param {string} backendName - The backend name of the edited property\n       * @param {string} newValue - The new value of the property\n       * @param {string} oldValue - The previous value of the property\n       */\n      editStateProperty: function(stateName, backendName, newValue, oldValue) {\n        if (!ALLOWED_STATE_BACKEND_NAMES.hasOwnProperty(backendName)) {\n          AlertsService.addWarning(\'Invalid state property: \' + backendName);\n          return;\n        }\n        addChange({\n          cmd: CMD_EDIT_STATE_PROPERTY,\n          new_value: angular.copy(newValue),\n          old_value: angular.copy(oldValue),\n          property_name: backendName,\n          state_name: stateName\n        });\n      },\n      getChangeList: function() {\n        return angular.copy(explorationChangeList);\n      },\n      isExplorationLockedForEditing: function() {\n        return explorationChangeList.length > 0;\n      },\n      /**\n       * Initializes the current changeList with the one received from backend.\n       * This behavior exists only in case of an autosave.\n       *\n       * @param {object} changeList - Autosaved changeList data\n       */\n      loadAutosavedChangeList: function(changeList) {\n        explorationChangeList = changeList;\n      },\n      /**\n       * Saves a change dict that represents the renaming of a state. This\n       * is also intended to change the initial state name if necessary\n       * (that is, the latter change is implied and does not have to be\n       * recorded separately in another change dict). It is the responsibility\n       * of the caller to check that the two names are not equal.\n       *\n       * @param {string} newStateName - The new name of the state\n       * @param {string} oldStateName - The previous name of the state\n       */\n      renameState: function(newStateName, oldStateName) {\n        addChange({\n          cmd: CMD_RENAME_STATE,\n          new_state_name: newStateName,\n          old_state_name: oldStateName\n        });\n      },\n      undoLastChange: function() {\n        if (explorationChangeList.length === 0) {\n          AlertsService.addWarning(\'There are no changes to undo.\');\n          return;\n        }\n        var lastChange = explorationChangeList.pop();\n        undoneChangeStack.push(lastChange);\n        autosaveChangeListOnChange(explorationChangeList);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
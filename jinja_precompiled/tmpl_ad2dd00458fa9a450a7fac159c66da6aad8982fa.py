from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/StateNameEditorDirectiveSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the controller of the \'State Editor\'.\n */\n\ndescribe(\'Sidebar state name controller\', function() {\n  describe(\'SidebarStateName\', function() {\n    var scope, filter, ctrl, ecs, fs, ess;\n    var $httpBackend;\n    var mockExplorationData;\n\n    var autosaveDraftUrl = \'createhandler/autosave_draft/0\';\n    var validAutosaveResponse = {\n      is_version_of_draft_valid: true\n    };\n\n    beforeEach(module(\'directiveTemplates\'));\n    beforeEach(function() {\n      module(\'oppia\');\n    });\n\n    beforeEach(function() {\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value(\'ExplorationDataService\', [mockExplorationData][0]);\n        $provide.constant(\'INVALID_NAME_CHARS\', \'#@&^%$\');\n      });\n      spyOn(mockExplorationData, \'autosaveChangeList\');\n    });\n\n    beforeEach(inject(function(\n        $compile, $filter, $injector, $rootScope, $templateCache) {\n      filter = $filter;\n      rootScope = $rootScope;\n      ecs = $injector.get(\'StateEditorService\');\n      fs = $injector.get(\'FocusManagerService\');\n      ess = $injector.get(\'ExplorationStatesService\');\n      $httpBackend = $injector.get(\'$httpBackend\');\n\n      ess.init({\n        \'First State\': {\n          content: {\n            content_id: \'content\',\n            html: \'First State Content\'\n          },\n          content_ids_to_audio_translations: {\n            content: {},\n            default_outcome: {}\n          },\n          interaction: {\n            answer_groups: [],\n            default_outcome: {\n              dest: \'Second State\',\n              feedback: {\n                content_id: \'default_outcome\',\n                html: \'\'\n              },\n              param_changes: []\n            },\n            hints: []\n          },\n          param_changes: []\n        },\n        \'Second State\': {\n          content: {\n            content_id: \'content\',\n            html: \'Second State Content\'\n          },\n          content_ids_to_audio_translations: {\n            content: {},\n            default_outcome: {}\n          },\n          interaction: {\n            answer_groups: [],\n            default_outcome: {\n              dest: \'Second State\',\n              feedback: {\n                content_id: \'default_outcome\',\n                html: \'\'\n              },\n              param_changes: []\n            },\n            hints: []\n          },\n          param_changes: []\n        },\n        \'Third State\': {\n          content: {\n            content_id: \'content\',\n            html: \'This is some content.\'\n          },\n          content_ids_to_audio_translations: {\n            content: {},\n            default_outcome: {}\n          },\n          interaction: {\n            answer_groups: [],\n            default_outcome: {\n              dest: \'Second State\',\n              feedback: {\n                content_id: \'default_outcome\',\n                html: \'\'\n              },\n              param_changes: []\n            },\n            hints: []\n          },\n          param_changes: [{\n            name: \'comparison\',\n            generator_id: \'Copier\',\n            customization_args: {\n              value: \'something clever\',\n              parse_with_jinja: false\n            }\n          }]\n        }\n      });\n\n      var templateHtml = $templateCache.get(\n        \'/pages/exploration_editor/editor_tab/\' +\n        \'state_name_editor_directive.html\');\n      $compile(templateHtml, $rootScope);\n      $rootScope.$digest();\n\n      outerScope = $rootScope.$new();\n      var elem = angular.element(\n        \'<state-name-editor></state-name-editor>\');\n      var compiledElem = $compile(elem)(outerScope);\n      outerScope.$digest();\n      scope = compiledElem[0].getControllerScope();\n    }));\n\n    it(\'should correctly normalize whitespace in a state name\', function() {\n      expect(scope._getNormalizedStateName(\'   First     State  \'))\n        .toEqual(\'First State\');\n      expect(scope._getNormalizedStateName(\'Fourth     State       \'))\n        .toEqual(\'Fourth State\');\n      expect(scope._getNormalizedStateName(\'Fourth State\'))\n        .toEqual(\'Fourth State\');\n      expect(scope._getNormalizedStateName(\'    \')).toEqual(\'\');\n      expect(scope._getNormalizedStateName(\'Z    \')).toEqual(\'Z\');\n      expect(scope._getNormalizedStateName(\'    .\')).toEqual(\'.\');\n    });\n\n    it(\'should not save state names longer than 50 characters\', function() {\n      expect(\n        scope.saveStateName(\n          \'babababababababababababababababababababababababababab\')\n      ).toBe(false);\n    });\n\n    it(\'should not save invalid names\', function() {\n      ecs.setActiveStateName(\'Third State\');\n      scope.initStateNameEditor();\n      expect(scope.saveStateName(\'#\')).toBe(false);\n      expect(ecs.getActiveStateName()).toBe(\'Third State\');\n    });\n\n    it(\'should not save duplicate state names\', function() {\n      expect(scope.saveStateName(\'Second State\')).toBe(false);\n    });\n\n    it(\'should check that state names are changeable\', function() {\n      ecs.setActiveStateName(\'First State\');\n      scope.initStateNameEditor();\n      expect(scope.stateName).toEqual(\'First State\');\n      expect(ecs.getActiveStateName()).toEqual(\'First State\');\n\n      scope.saveStateName(\'Fourth State\');\n      expect(scope.stateName).toEqual(\'Fourth State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Fourth State\');\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n\n      scope.saveStateName(\'Fifth State\');\n      expect(scope.stateName).toEqual(\'Fifth State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Fifth State\');\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it(\'should allow state names to be variations of \\\'END\\\'\', function() {\n      ecs.setActiveStateName(\'First State\');\n      scope.initStateNameEditor();\n\n      expect(scope.saveStateName(\'END\')).toBe(true);\n      expect(scope.saveStateName(\'enD\')).toBe(true);\n      expect(scope.saveStateName(\'end\')).toBe(true);\n    });\n\n    it(\'should check that state name edits are independent\', function() {\n      ecs.setActiveStateName(\'Third State\');\n      scope.saveStateName(\'Fourth State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Fourth State\');\n      expect(ess.getState(\'Fourth State\')).toBeTruthy();\n      expect(ess.getState(\'Third State\')).toBeFalsy();\n\n      ecs.setActiveStateName(\'First State\');\n      scope.saveStateName(\'Fifth State\');\n      expect(ess.getState(\'Fifth State\')).toBeTruthy();\n      expect(ess.getState(\'First State\')).toBeFalsy();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it(\'should not re-save unedited state names\', function() {\n      ecs.setActiveStateName(\'Second State\');\n      scope.initStateNameEditor();\n      scope.openStateNameEditor();\n      expect(scope.saveStateName(\'Second State\')).toBe(false);\n    });\n\n    it(\'should not change state name if state name edits fail\', function() {\n      ecs.setActiveStateName(\'Third State\');\n      scope.initStateNameEditor();\n      scope.openStateNameEditor();\n\n      // This is not a valid state name.\n      scope.saveStateName(\'#!% State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Third State\');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n\n      // Long state names will not save.\n      scope.saveStateName(\n        \'This state name is too long to be saved. Try to be brief next time.\'\n      );\n      expect(ecs.getActiveStateName()).toEqual(\'Third State\');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n\n      // This will not save because it is an already existing state name.\n      scope.saveStateName(\'First State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Third State\');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n\n      // Will not save because the memento is the same as the new state name.\n      scope.saveStateName(\'Third State\');\n      expect(ecs.getActiveStateName()).toEqual(\'Third State\');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n    });\n  });\n});'

blocks = {}
debug_info = ''
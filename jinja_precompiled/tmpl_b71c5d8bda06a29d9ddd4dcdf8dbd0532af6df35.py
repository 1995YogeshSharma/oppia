from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'expressions/ExpressionEvaluatorService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file defines the evaluation engine as well as the system operators.\n// The evaluator takes the output of the parser (i.e. parse tree) as defined in\n// parser.pegjs and produces a javaScript primitive value when the evaluation is\n// performed correctly.\n// Two cases that can throw an exception (i.e. an Error object):\n// - Variable look-up (\'#\' operator) failure. (ExprUndefinedVarError)\n// - Wrong number of arguments in the node for the given operator.\n//   (ExprWrongNumArgsError)\n// Both errors are children of ExpressionError, so caller can use\n// ExpressionError to catch only these expected error cases.\n//\n// An expression is evaluated in a context consisting of predefined system\n// variables, system operators, and system functions. In the input language,\n// operators are predefined set of characters in infix, postfix, or ternary\n// format (there is currently no postfix operators) while functions have the\n// form of function calls (e.g. "abs(10)"). In the parse tree, there is no\n// difference between operators and functions. User defined parameters may\n// override the meaning of system variables and functions (but not operators).\n// Users also can define parameters with new names. Referencing a variable which\n// is not defined as a system variable, system function, or user parameter will\n// result in ExprUndefinedVarError to be thrown.\n//\n// All system variables, system operators, and system functions are defined\n// as \'system\' variable in this file.\n//\n// TODO(kashida): Split the following section into two:\n//     - A general overview of operators (including some concrete examples)\n//     - A numbered sequence of steps which a new contributor should follow in\n//         order to define a new operator.\n// Defining new operators and functions:\n// Operators and functions are given an array of arguments which are already all\n// evaluated. E.g. for an expression "1 + 2 * 3", the "+" plus operator receives\n// values 1 and 6 (i.e. "2 * 3" already evaluated).\n// The operators and functions should verify that the argument array\n// has the required number of arguments. Operators and functions can coerse the\n// input arguments to the desired typed values, or throw an exception if wrong\n// type of argument is given.\n// type of inputs. This does not prevent operators to eror on wrong parameter\n// values (e.g. getting negative number for an index).\n// When successful, operators and functions may return any valid JavaScript\n// values. In general, an operator always returns the same type of value, but\n// there are exceptions (e.g. "+" operator may return a number or a string\n// depending on the types of the input arguments).\n// Constraints on the input arguments (number, types, and any other\n// constraints) as well as the output value and type should be documented.\n\n// Service for expression evaluation.\noppia.factory(\'ExpressionEvaluatorService\', [\n  \'$log\', \'ExpressionParserService\', \'ExpressionSyntaxTreeService\',\n  function($log, ExpressionParserService, ExpressionSyntaxTreeService) {\n    var evaluateExpression = function(expression, envs) {\n      return ExpressionSyntaxTreeService.applyFunctionToParseTree(\n        ExpressionParserService.parse(expression), envs, evaluate);\n    };\n\n    /**\n     * @param {*} parsed Parse output from the parser. See parser.pegjs for\n     *     the data structure.\n     * @param {!Array.<!Object>} envs Represents a nested name space\n     *     environment to look up the name in. The first element is looked up\n     *     first (i.e. has higher precedence).\n     */\n    var evaluate = function(parsed, envs) {\n      // The intermediate nodes of the parse tree are arrays. The terminal\n      // nodes are JavaScript primitives (as described in the "Parser output"\n      // section of parser.pegjs).\n      if (parsed instanceof Array) {\n        if (parsed.length === 0) {\n          throw \'Parser generated an intermediate node with zero children\';\n        }\n\n        if (parsed[0] === \'#\') {\n          return ExpressionSyntaxTreeService.lookupEnvs(parsed[1], envs);\n        }\n\n        // Evaluate rest of the elements, i.e. the arguments.\n        var args = parsed.slice(1).map(function(item) {\n          return evaluate(item, envs);\n        });\n        // The first element should be a function name.\n        return ExpressionSyntaxTreeService.lookupEnvs(\n          parsed[0], envs).eval(args);\n      }\n\n      // This should be a terminal node with the actual value.\n      return parsed;\n    };\n\n    var validateExpression = function(expression, envs) {\n      try {\n        return validate(ExpressionParserService.parse(expression),\n          envs.concat(system));\n      } catch (err) {\n        return false;\n      }\n    };\n\n    /**\n     * @param {*} parsed Parse output from the parser. See parser.pegjs for\n     *     the data structure.\n     * @param {!Array.<!Object>} envs Represents a nested name space\n     *     environment to look up the name in. The first element is looked\n     *     up first (i.e. has higher precedence).\n     * @return {boolean} True when validation succeeds.\n     */\n    var validate = function(parsed, envs) {\n      if (!(parsed instanceof Array)) {\n        return true;\n      }\n\n      if (parsed.length === 0) {\n        // This should not happen.\n        return false;\n      }\n\n      // Make sure we can find the operator.\n      ExpressionSyntaxTreeService.lookupEnvs(parsed[0], envs);\n\n      // Evaluate rest of the elements, i.e. the arguments.\n      var args = parsed.slice(1).map(function(item) {\n        return validate(item, envs);\n      });\n\n      // If it is a name look up, make sure the name exists.\n      // TODO: Validate args for other operators.\n      if (parsed[0] === \'#\') {\n        ExpressionSyntaxTreeService.lookupEnvs(parsed[1], envs);\n      }\n      return true;\n    };\n\n    return {\n      evaluate: evaluate,\n      evaluateExpression: evaluateExpression,\n      validate: validate,\n      validateExpression: validateExpression\n    };\n  }\n]);'

blocks = {}
debug_info = ''
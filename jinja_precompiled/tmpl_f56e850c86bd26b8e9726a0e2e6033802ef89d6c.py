from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/HintsAndSolutionManagerService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utility service for Hints in the learner\'s view.\n */\n\noppia.factory(\'HintsAndSolutionManagerService\', [\n  \'$timeout\', \'$rootScope\',\n  \'DELAY_FOR_HINT_FEEDBACK_MSEC\', \'HINT_REQUEST_STRING_I18N_IDS\',\n  \'WAIT_FOR_FIRST_HINT_MSEC\', \'WAIT_FOR_SUBSEQUENT_HINTS_MSEC\',\n  \'EVENT_NEW_CARD_AVAILABLE\',\n  function(\n      $timeout, $rootScope,\n      DELAY_FOR_HINT_FEEDBACK_MSEC, HINT_REQUEST_STRING_I18N_IDS,\n      WAIT_FOR_FIRST_HINT_MSEC, WAIT_FOR_SUBSEQUENT_HINTS_MSEC,\n      EVENT_NEW_CARD_AVAILABLE) {\n    var timeout = null;\n    var ACCELERATED_HINT_WAIT_TIME_MSEC = 10000;\n    var WAIT_FOR_TOOLTIP_TO_BE_SHOWN_MSEC = 60000;\n\n    var numHintsReleased = 0;\n    var numHintsConsumed = 0;\n    var solutionReleased = false;\n    var solutionConsumed = false;\n    var hintsForLatestCard = [];\n    var solutionForLatestCard = null;\n    var wrongAnswersSinceLastHintConsumed = 0;\n    var correctAnswerSubmitted = false;\n\n    // tooltipIsOpen is a flag which says that the tooltip is currently\n    // visible to the learner.\n    var tooltipIsOpen = false;\n    // This is set to true as soon as a hint/solution is clicked or when the\n    // tooltip has been triggered.\n    var hintsDiscovered = false;\n    var tooltipTimeout = null;\n\n\n    $rootScope.$on(EVENT_NEW_CARD_AVAILABLE, function() {\n      correctAnswerSubmitted = true;\n      // This prevents tooltip to hide the Continue button of the help card in\n      // mobile view.\n      tooltipIsOpen = false;\n    });\n\n    // This replaces any timeouts that are already queued.\n    var enqueueTimeout = function(func, timeToWaitMsec) {\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(func, timeToWaitMsec);\n    };\n\n    var showTooltip = function() {\n      tooltipIsOpen = true;\n      hintsDiscovered = true;\n    };\n\n    var releaseHint = function() {\n      if (!correctAnswerSubmitted) {\n        numHintsReleased++;\n        if (!hintsDiscovered && !tooltipTimeout) {\n          tooltipTimeout = $timeout(\n            showTooltip, WAIT_FOR_TOOLTIP_TO_BE_SHOWN_MSEC);\n        }\n      }\n    };\n    var releaseSolution = function() {\n      solutionReleased = true;\n    };\n    var accelerateHintRelease = function() {\n      enqueueTimeout(releaseHint, ACCELERATED_HINT_WAIT_TIME_MSEC);\n    };\n\n    var areAllHintsExhausted = function() {\n      return numHintsReleased === hintsForLatestCard.length;\n    };\n    var isAHintWaitingToBeViewed = function() {\n      return numHintsConsumed < numHintsReleased;\n    };\n\n    var consumeHint = function() {\n      hintsDiscovered = true;\n      tooltipIsOpen = false;\n      if (tooltipTimeout) {\n        $timeout.cancel(tooltipTimeout);\n      }\n\n      numHintsConsumed++;\n      wrongAnswersSinceLastHintConsumed = 0;\n\n      var funcToEnqueue = null;\n      if (!areAllHintsExhausted()) {\n        funcToEnqueue = releaseHint;\n      } else if (!!solutionForLatestCard && !solutionReleased) {\n        funcToEnqueue = releaseSolution;\n      }\n      if (funcToEnqueue) {\n        enqueueTimeout(funcToEnqueue, WAIT_FOR_SUBSEQUENT_HINTS_MSEC);\n      }\n    };\n\n    return {\n      reset: function(newHints, newSolution) {\n        numHintsReleased = 0;\n        numHintsConsumed = 0;\n        solutionReleased = false;\n        solutionConsumed = false;\n        hintsForLatestCard = newHints;\n        solutionForLatestCard = newSolution;\n        wrongAnswersSinceLastHintConsumed = 0;\n        correctAnswerSubmitted = false;\n        if (timeout) {\n          $timeout.cancel(timeout);\n        }\n        if (tooltipTimeout) {\n          $timeout.cancel(tooltipTimeout);\n        }\n\n        if (hintsForLatestCard.length > 0) {\n          enqueueTimeout(releaseHint, WAIT_FOR_FIRST_HINT_MSEC);\n        }\n      },\n      // WARNING: This method has a side-effect. If the retrieved hint is a\n      // pending hint that\'s being viewed, it starts the timer for the next\n      // hint.\n      displayHint: function(index) {\n        if (index === numHintsConsumed && numHintsConsumed < numHintsReleased) {\n          // The latest hint has been consumed. Start the timer.\n          consumeHint();\n        }\n\n        if (index < numHintsReleased) {\n          return hintsForLatestCard[index].hintContent;\n        }\n        return null;\n      },\n      displaySolution: function() {\n        hintsDiscovered = true;\n        solutionConsumed = true;\n        if (tooltipTimeout) {\n          $timeout.cancel(tooltipTimeout);\n        }\n        return solutionForLatestCard;\n      },\n      getNumHints: function() {\n        return hintsForLatestCard.length;\n      },\n      isHintViewable: function(index) {\n        return index < numHintsReleased;\n      },\n      isHintConsumed: function(index) {\n        return index < numHintsConsumed;\n      },\n      isHintTooltipOpen: function() {\n        return tooltipIsOpen;\n      },\n      isSolutionViewable: function() {\n        return solutionReleased;\n      },\n      isSolutionConsumed: function() {\n        return solutionConsumed;\n      },\n      recordWrongAnswer: function() {\n        if (isAHintWaitingToBeViewed()) {\n          return;\n        }\n\n        wrongAnswersSinceLastHintConsumed++;\n        if (!areAllHintsExhausted() && !isAHintWaitingToBeViewed()) {\n          if (numHintsReleased === 0 &&\n              wrongAnswersSinceLastHintConsumed >= 2) {\n            accelerateHintRelease();\n          } else if (\n            numHintsReleased > 0 && wrongAnswersSinceLastHintConsumed >= 1) {\n            accelerateHintRelease();\n          }\n        }\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/ExplorationWarningsService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A service that lists all the exploration warnings.\n */\n\n// When an unresolved answer\'s frequency exceeds this threshold, an exploration\n// will be blocked from being published until the answer is resolved.\noppia.constant(\'UNRESOLVED_ANSWER_FREQUENCY_THRESHOLD\', 5);\n\noppia.factory(\'ExplorationWarningsService\', [\n  \'$injector\', \'ExplorationParamChangesService\', \'ExplorationStatesService\',\n  \'ExpressionInterpolationService\', \'GraphDataService\',\n  \'ParameterMetadataService\', \'StateTopAnswersStatsService\',\n  \'SolutionValidityService\', \'INTERACTION_SPECS\', \'STATE_ERROR_MESSAGES\',\n  \'UNRESOLVED_ANSWER_FREQUENCY_THRESHOLD\', \'WARNING_TYPES\',\n  function(\n      $injector, ExplorationParamChangesService, ExplorationStatesService,\n      ExpressionInterpolationService, GraphDataService,\n      ParameterMetadataService, StateTopAnswersStatsService,\n      SolutionValidityService, INTERACTION_SPECS, STATE_ERROR_MESSAGES,\n      UNRESOLVED_ANSWER_FREQUENCY_THRESHOLD, WARNING_TYPES) {\n    var _warningsList = [];\n    var stateWarnings = {};\n    var hasCriticalStateWarning = false;\n\n    var _getStatesWithoutInteractionIds = function() {\n      var statesWithoutInteractionIds = [];\n\n      var states = ExplorationStatesService.getStates();\n\n      states.getStateNames().forEach(function(stateName) {\n        if (!states.getState(stateName).interaction.id) {\n          statesWithoutInteractionIds.push(stateName);\n        }\n      });\n\n      return statesWithoutInteractionIds;\n    };\n\n    var _getStatesWithIncorrectSolution = function() {\n      var statesWithIncorrectSolution = [];\n\n      var states = ExplorationStatesService.getStates();\n      states.getStateNames().forEach(function(stateName) {\n        if (states.getState(stateName).interaction.solution &&\n            !SolutionValidityService.isSolutionValid(stateName)) {\n          statesWithIncorrectSolution.push(stateName);\n        }\n      });\n      return statesWithIncorrectSolution;\n    };\n\n    // Returns a list of names of all nodes which are unreachable from the\n    // initial node.\n    //\n    // Args:\n    // - initNodeIds: a list of initial node ids\n    // - nodes: an object whose keys are node ids, and whose values are node\n    //     names\n    // - edges: a list of edges, each of which is an object with keys \'source\',\n    //     and \'target\'.\n    var _getUnreachableNodeNames = function(initNodeIds, nodes, edges) {\n      var queue = initNodeIds;\n      var seen = {};\n      for (var i = 0; i < initNodeIds.length; i++) {\n        seen[initNodeIds[i]] = true;\n      }\n      while (queue.length > 0) {\n        var currNodeId = queue.shift();\n        edges.forEach(function(edge) {\n          if (edge.source === currNodeId && !seen.hasOwnProperty(edge.target)) {\n            seen[edge.target] = true;\n            queue.push(edge.target);\n          }\n        });\n      }\n\n      var unreachableNodeNames = [];\n      for (var nodeId in nodes) {\n        if (!(seen.hasOwnProperty(nodes[nodeId]))) {\n          unreachableNodeNames.push(nodes[nodeId]);\n        }\n      }\n\n      return unreachableNodeNames;\n    };\n\n    // Given an array of objects with two keys \'source\' and \'target\', returns\n    // an array with the same objects but with the values of \'source\' and\n    // \'target\' switched. (The objects represent edges in a graph, and this\n    // operation amounts to reversing all the edges.)\n    var _getReversedLinks = function(links) {\n      return links.map(function(link) {\n        return {\n          source: link.target,\n          target: link.source,\n        };\n      });\n    };\n\n    // Verify that all parameters referred to in a state are guaranteed to\n    // have been set beforehand.\n    var _verifyParameters = function(initNodeIds) {\n      var unsetParametersInfo = (\n        ParameterMetadataService.getUnsetParametersInfo(initNodeIds));\n\n      var paramWarningsList = [];\n      unsetParametersInfo.forEach(function(unsetParameterData) {\n        if (!unsetParameterData.stateName) {\n          // The parameter value is required in the initial list of parameter\n          // changes.\n          paramWarningsList.push({\n            type: WARNING_TYPES.CRITICAL,\n            message: (\n              \'Please ensure the value of parameter "\' +\n              unsetParameterData.paramName +\n              \'" is set before it is referred to in the initial list of \' +\n              \'parameter changes.\')\n          });\n        } else {\n          // The parameter value is required in a subsequent state.\n          paramWarningsList.push({\n            type: WARNING_TYPES.CRITICAL,\n            message: (\n              \'Please ensure the value of parameter "\' +\n              unsetParameterData.paramName +\n              \'" is set before using it in "\' + unsetParameterData.stateName +\n              \'".\')\n          });\n        }\n      });\n\n      return paramWarningsList;\n    };\n\n    var _getAnswerGroupIndexesWithEmptyClassifiers = function(state) {\n      var indexes = [];\n      var answerGroups = state.interaction.answerGroups;\n      for (var i = 0; i < answerGroups.length; i++) {\n        var group = answerGroups[i];\n        if (group.rules.length === 0 &&\n            group.trainingData.length === 0) {\n          indexes.push(i);\n        }\n      }\n      return indexes;\n    };\n\n    var _getStatesAndAnswerGroupsWithEmptyClassifiers = function() {\n      var results = [];\n\n      var states = ExplorationStatesService.getStates();\n\n      states.getStateNames().forEach(function(stateName) {\n        var groupIndexes = _getAnswerGroupIndexesWithEmptyClassifiers(\n          states.getState(stateName));\n        if (groupIndexes.length > 0) {\n          results.push({\n            groupIndexes: groupIndexes,\n            stateName: stateName\n          });\n        }\n      });\n\n      return results;\n    };\n\n    var _getStatesWithAnswersThatMustBeResolved = function() {\n      var stass = StateTopAnswersStatsService;\n      return stass.getStateNamesWithStats().filter(function(stateName) {\n        return stass.getUnresolvedStateStats(stateName).some(function(answer) {\n          return answer.frequency >= UNRESOLVED_ANSWER_FREQUENCY_THRESHOLD;\n        });\n      });\n    };\n\n    var _updateWarningsList = function() {\n      _warningsList = [];\n      stateWarnings = {};\n      hasCriticalStateWarning = false;\n\n      var _extendStateWarnings = function(stateName, newWarning) {\n        if (stateWarnings.hasOwnProperty(stateName)) {\n          stateWarnings[stateName].push(newWarning);\n        } else {\n          stateWarnings[stateName] = [newWarning];\n        }\n      };\n\n      GraphDataService.recompute();\n      var _graphData = GraphDataService.getGraphData();\n\n      var _states = ExplorationStatesService.getStates();\n      _states.getStateNames().forEach(function(stateName) {\n        var interaction = _states.getState(stateName).interaction;\n        if (interaction.id) {\n          var validatorServiceName =\n            _states.getState(stateName).interaction.id + \'ValidationService\';\n          var validatorService = $injector.get(validatorServiceName);\n          var interactionWarnings = validatorService.getAllWarnings(\n            stateName, interaction.customizationArgs,\n            interaction.answerGroups, interaction.defaultOutcome);\n\n          for (var j = 0; j < interactionWarnings.length; j++) {\n            _extendStateWarnings(stateName, interactionWarnings[j].message);\n\n            if (interactionWarnings[j].type === WARNING_TYPES.CRITICAL) {\n              hasCriticalStateWarning = true;\n            }\n          }\n        }\n      });\n\n      var statesWithoutInteractionIds = _getStatesWithoutInteractionIds();\n      angular.forEach(\n        statesWithoutInteractionIds, function(stateWithoutInteractionIds) {\n          _extendStateWarnings(\n            stateWithoutInteractionIds, STATE_ERROR_MESSAGES.ADD_INTERACTION);\n        });\n\n      var statesWithAnswersThatMustBeResolved =\n        _getStatesWithAnswersThatMustBeResolved();\n      angular.forEach(statesWithAnswersThatMustBeResolved, function(stateName) {\n        _extendStateWarnings(stateName, STATE_ERROR_MESSAGES.UNRESOLVED_ANSWER);\n      });\n\n      var statesWithIncorrectSolution = _getStatesWithIncorrectSolution();\n      angular.forEach(statesWithIncorrectSolution, function(state) {\n        _extendStateWarnings(state, STATE_ERROR_MESSAGES.INCORRECT_SOLUTION);\n      });\n\n      if (_graphData) {\n        var unreachableStateNames = _getUnreachableNodeNames(\n          [_graphData.initStateId], _graphData.nodes, _graphData.links, true);\n\n        if (unreachableStateNames.length) {\n          angular.forEach(\n            unreachableStateNames, function(unreachableStateName) {\n              _extendStateWarnings(\n                unreachableStateName, STATE_ERROR_MESSAGES.STATE_UNREACHABLE);\n            });\n        } else {\n          // Only perform this check if all states are reachable.\n          var deadEndStates = _getUnreachableNodeNames(\n            _graphData.finalStateIds, _graphData.nodes,\n            _getReversedLinks(_graphData.links), false);\n          if (deadEndStates.length) {\n            angular.forEach(deadEndStates, function(deadEndState) {\n              _extendStateWarnings(\n                deadEndState, STATE_ERROR_MESSAGES.UNABLE_TO_END_EXPLORATION);\n            });\n          }\n        }\n\n        _warningsList = _warningsList.concat(_verifyParameters([\n          _graphData.initStateId]));\n      }\n\n      if (Object.keys(stateWarnings).length) {\n        var errorString = (\n          Object.keys(stateWarnings).length > 1 ? \'cards have\' : \'card has\');\n        _warningsList.push({\n          type: WARNING_TYPES.ERROR,\n          message: (\n            \'The following \' + errorString + \' errors: \' +\n            Object.keys(stateWarnings).join(\', \') + \'.\')\n        });\n      }\n\n      var statesWithAnswerGroupsWithEmptyClassifiers = (\n        _getStatesAndAnswerGroupsWithEmptyClassifiers());\n      statesWithAnswerGroupsWithEmptyClassifiers.forEach(function(result) {\n        var warningMessage = \'In \\\'\' + result.stateName + \'\\\'\';\n        if (result.groupIndexes.length !== 1) {\n          warningMessage += \', the following answer groups have classifiers \';\n          warningMessage += \'with no training data: \';\n        } else {\n          warningMessage += \', the following answer group has a classifier \';\n          warningMessage += \'with no training data: \';\n        }\n        warningMessage += result.groupIndexes.join(\', \');\n\n        _warningsList.push({\n          message: warningMessage,\n          type: WARNING_TYPES.ERROR\n        });\n      });\n    };\n\n    return {\n      countWarnings: function() {\n        return _warningsList.length;\n      },\n      getAllStateRelatedWarnings: function() {\n        return stateWarnings;\n      },\n      getWarnings: function() {\n        return _warningsList;\n      },\n      hasCriticalWarnings: function() {\n        return hasCriticalStateWarning || _warningsList.some(function(warning) {\n          return warning.type === WARNING_TYPES.CRITICAL;\n        });\n      },\n      updateWarnings: function() {\n        _updateWarningsList();\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
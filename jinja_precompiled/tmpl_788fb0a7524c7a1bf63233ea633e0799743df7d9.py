from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/question/QuestionObjectFactorySpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Tests for QuestionContentsObjectFactory.\n */\n\ndescribe(\'Question object factory\', function() {\n  var QuestionObjectFactory = null;\n  var _sampleQuestion = null;\n  var _sampleQuestionBackendDict = null;\n\n  beforeEach(module(\'oppia\'));\n\n  beforeEach(function() {\n    module(function($provide) {\n      $provide.constant(\'INTERACTION_SPECS\', {\n        TextInput: {\n          can_have_solution: true\n        }\n      });\n    });\n  });\n\n  beforeEach(inject(function($injector) {\n    QuestionObjectFactory = $injector.get(\'QuestionObjectFactory\');\n    MisconceptionObjectFactory = $injector.get(\'MisconceptionObjectFactory\');\n\n    _sampleQuestionBackendDict = {\n      id: \'question_id\',\n      question_state_data: {\n        content: {\n          html: \'Question 1\',\n          content_id: \'content_1\'\n        },\n        interaction: {\n          answer_groups: [{\n            outcome: {\n              dest: \'outcome 1\',\n              feedback: {\n                content_id: \'content_5\',\n                html: \'\'\n              },\n              labelled_as_correct: true,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }],\n          }],\n          confirmed_unclassified_answers: [],\n          customization_args: {},\n          default_outcome: {\n            dest: null,\n            feedback: {\n              html: \'Correct Answer\',\n              content_id: \'content_2\'\n            },\n            param_changes: [],\n            labelled_as_correct: false\n          },\n          hints: [\n            {\n              hint_content: {\n                html: \'Hint 1\',\n                content_id: \'content_3\'\n              }\n            }\n          ],\n          solution: {\n            correct_answer: \'This is the correct answer\',\n            answer_is_exclusive: false,\n            explanation: {\n              html: \'Solution explanation\',\n              content_id: \'content_4\'\n            }\n          },\n          id: \'TextInput\'\n        },\n        param_changes: [],\n        content_ids_to_audio_translations: {\n          content_1: {},\n          content_2: {},\n          content_3: {},\n          content_4: {},\n          content_5: {}\n        }\n      },\n      language_code: \'en\',\n      version: 1\n    };\n    _sampleQuestion = QuestionObjectFactory.createFromBackendDict(\n      _sampleQuestionBackendDict);\n  }));\n\n  it(\'should correctly get various fields of the question\', function() {\n    expect(_sampleQuestion.getId()).toEqual(\'question_id\');\n    expect(_sampleQuestion.getLanguageCode()).toEqual(\'en\');\n    var stateData = _sampleQuestion.getStateData();\n    expect(stateData.name).toEqual(\'question\');\n    expect(stateData.content.getHtml()).toEqual(\'Question 1\');\n    var interaction = stateData.interaction;\n    expect(interaction.id).toEqual(\'TextInput\');\n    expect(interaction.hints[0].hintContent.getHtml()).toEqual(\'Hint 1\');\n    expect(interaction.solution.explanation.getHtml()).toEqual(\n      \'Solution explanation\');\n    expect(interaction.solution.correctAnswer).toEqual(\n      \'This is the correct answer\');\n    var defaultOutcome = interaction.defaultOutcome;\n    expect(defaultOutcome.labelledAsCorrect).toEqual(false);\n    expect(defaultOutcome.feedback.getHtml()).toEqual(\'Correct Answer\');\n  });\n\n  it(\'should correctly get backend dict\', function() {\n    expect(\n      _sampleQuestion.toBackendDict(true).question_state_schema_version\n    ).toEqual(25);\n\n    expect(_sampleQuestion.toBackendDict(true, 25).id).toEqual(null);\n    expect(_sampleQuestion.toBackendDict(false).id).toEqual(\'question_id\');\n  });\n\n  it(\'should correctly validate question\', function() {\n    var interaction = _sampleQuestion.getStateData().interaction;\n    var misconception1 = MisconceptionObjectFactory.create(\n      \'id\', \'name\', \'notes\', \'feedback\');\n    var misconception2 = MisconceptionObjectFactory.create(\n      \'id_2\', \'name_2\', \'notes\', \'feedback\');\n    expect(_sampleQuestion.validate([misconception1, misconception2])).toEqual(\n      \'The following misconceptions should also be caught: name, name_2\');\n\n    interaction.answerGroups[0].outcome.labelledAsCorrect = false;\n    expect(_sampleQuestion.validate([])).toEqual(\n      \'At least one answer should be marked correct\');\n\n    interaction.solution = null;\n    expect(_sampleQuestion.validate([])).toEqual(\n      \'A solution must be specified\');\n\n    interaction.hints = [];\n    expect(_sampleQuestion.validate([])).toEqual(\n      \'At least 1 hint should be specfied\');\n  });\n});'

blocks = {}
debug_info = ''
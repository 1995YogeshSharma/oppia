from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/question/QuestionObjectFactory.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating and mutating instances of frontend\n * question domain objects.\n */\n\noppia.factory(\'QuestionObjectFactory\', [\n  \'StateObjectFactory\', \'INTERACTION_SPECS\',\n  function(StateObjectFactory, INTERACTION_SPECS) {\n    var Question = function(id, stateData, languageCode, version) {\n      this._id = id;\n      this._stateData = stateData;\n      this._languageCode = languageCode;\n      this._version = version;\n    };\n\n    // Instance methods\n\n    Question.prototype.getId = function() {\n      return this._id;\n    };\n\n    Question.prototype.getStateData = function() {\n      return this._stateData;\n    };\n\n    Question.prototype.getLanguageCode = function() {\n      return this._languageCode;\n    };\n\n    Question.prototype.setLanguageCode = function(languageCode) {\n      this._languageCode = languageCode;\n    };\n\n    Question.prototype.getVersion = function() {\n      return this._version;\n    };\n\n    Question.createDefaultQuestion = function() {\n      return new Question(\n        null, StateObjectFactory.createDefaultState(null),\n        constants.DEFAULT_LANGUAGE_CODE, 1);\n    };\n\n    Question.prototype.validate = function(misconceptions) {\n      var interaction = this._stateData.interaction;\n      if (interaction.hints.length === 0) {\n        return \'At least 1 hint should be specfied\';\n      }\n      if (\n        !interaction.solution &&\n        INTERACTION_SPECS[interaction.id].can_have_solution) {\n        return \'A solution must be specified\';\n      }\n      var answerGroups = this._stateData.interaction.answerGroups;\n      var taggedMisconceptionIds = {};\n      var atLeastOneAnswerCorrect = false;\n      for (var i = 0; i < answerGroups.length; i++) {\n        if (answerGroups[i].outcome.labelledAsCorrect) {\n          atLeastOneAnswerCorrect = true;\n          continue;\n        }\n        if (answerGroups[i].taggedMisconceptionId !== null) {\n          taggedMisconceptionIds[answerGroups[i].taggedMisconceptionId] = true;\n        }\n      }\n      if (!atLeastOneAnswerCorrect) {\n        return \'At least one answer should be marked correct\';\n      }\n      var pendingMisconceptionNamesToTag = [];\n      for (var i = 0; i < misconceptions.length; i++) {\n        if (!taggedMisconceptionIds[misconceptions[i].getId()]) {\n          pendingMisconceptionNamesToTag.push(misconceptions[i].getName());\n        }\n      }\n      if (pendingMisconceptionNamesToTag.length > 0) {\n        var returnString =\n          \'The following misconceptions should also be caught:\';\n        pendingMisconceptionNamesToTag.forEach(function(misconceptionName) {\n          returnString = returnString + \' \' + misconceptionName + \',\';\n        });\n        return returnString.slice(0, -1);\n      }\n      return false;\n    };\n\n    Question.createFromBackendDict = function(questionBackendDict) {\n      return new Question(\n        questionBackendDict.id,\n        StateObjectFactory.createFromBackendDict(\n          \'question\', questionBackendDict.question_state_data),\n        questionBackendDict.language_code, questionBackendDict.version\n      );\n    };\n\n    Question.prototype.toBackendDict = function(isNewQuestion, schemaVersion) {\n      var questionBackendDict = {\n        id: null,\n        question_state_data: this._stateData.toBackendDict(),\n        language_code: this._languageCode,\n        question_state_schema_version: constants.CURRENT_STATES_SCHEMA_VERSION,\n        version: 1\n      };\n      if (!isNewQuestion) {\n        questionBackendDict.id = this._id;\n        questionBackendDict.version = this._version;\n      }\n      return questionBackendDict;\n    };\n\n    return Question;\n  }\n]);'

blocks = {}
debug_info = ''
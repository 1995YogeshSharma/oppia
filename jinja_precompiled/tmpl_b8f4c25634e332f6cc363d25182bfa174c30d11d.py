from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/ExplorationStatesService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Data service for keeping track of the exploration\'s states.\n * Note that this is unlike the other exploration property services, in that it\n * keeps no mementos.\n */\n\noppia.factory(\'ExplorationStatesService\', [\n  \'$log\', \'$uibModal\', \'$filter\', \'$location\', \'$rootScope\', \'$injector\', \'$q\',\n  \'ExplorationInitStateNameService\', \'AlertsService\', \'ChangeListService\',\n  \'StateEditorService\', \'ValidatorsService\', \'StatesObjectFactory\',\n  \'SolutionValidityService\', \'AngularNameService\',\n  \'AnswerClassificationService\', \'ContextService\',\n  \'UrlInterpolationService\',\n  function(\n      $log, $uibModal, $filter, $location, $rootScope, $injector, $q,\n      ExplorationInitStateNameService, AlertsService, ChangeListService,\n      StateEditorService, ValidatorsService, StatesObjectFactory,\n      SolutionValidityService, AngularNameService,\n      AnswerClassificationService, ContextService,\n      UrlInterpolationService) {\n    var _states = null;\n\n    var stateAddedCallbacks = [];\n    var stateDeletedCallbacks = [];\n    var stateRenamedCallbacks = [];\n    var stateAnswerGroupsSavedCallbacks = [];\n\n    // Properties that have a different backend representation from the\n    // frontend and must be converted.\n    var BACKEND_CONVERSIONS = {\n      answer_groups: function(answerGroups) {\n        return answerGroups.map(function(answerGroup) {\n          return answerGroup.toBackendDict();\n        });\n      },\n      content: function(content) {\n        return content.toBackendDict();\n      },\n      content_ids_to_audio_translations: function(\n          contentIdsToAudioTranslations) {\n        return contentIdsToAudioTranslations.toBackendDict();\n      },\n      default_outcome: function(defaultOutcome) {\n        if (defaultOutcome) {\n          return defaultOutcome.toBackendDict();\n        } else {\n          return null;\n        }\n      },\n      hints: function(hints) {\n        return hints.map(function(hint) {\n          return hint.toBackendDict();\n        });\n      },\n      param_changes: function(paramChanges) {\n        return paramChanges.map(function(paramChange) {\n          return paramChange.toBackendDict();\n        });\n      },\n      param_specs: function(paramSpecs) {\n        return paramSpecs.toBackendDict();\n      },\n      solution: function(solution) {\n        if (solution) {\n          return solution.toBackendDict();\n        } else {\n          return null;\n        }\n      }\n    };\n\n    // Maps backend names to the corresponding frontend dict accessor lists.\n    var PROPERTY_REF_DATA = {\n      answer_groups: [\'interaction\', \'answerGroups\'],\n      confirmed_unclassified_answers: [\n        \'interaction\', \'confirmedUnclassifiedAnswers\'],\n      content: [\'content\'],\n      content_ids_to_audio_translations: [\'contentIdsToAudioTranslations\'],\n      default_outcome: [\'interaction\', \'defaultOutcome\'],\n      param_changes: [\'paramChanges\'],\n      param_specs: [\'paramSpecs\'],\n      hints: [\'interaction\', \'hints\'],\n      solution: [\'interaction\', \'solution\'],\n      widget_id: [\'interaction\', \'id\'],\n      widget_customization_args: [\'interaction\', \'customizationArgs\']\n    };\n\n    var _setState = function(stateName, stateData, refreshGraph) {\n      _states.setState(stateName, angular.copy(stateData));\n      if (refreshGraph) {\n        $rootScope.$broadcast(\'refreshGraph\');\n      }\n    };\n\n    var getStatePropertyMemento = function(stateName, backendName) {\n      var accessorList = PROPERTY_REF_DATA[backendName];\n      var propertyRef = _states.getState(stateName);\n      accessorList.forEach(function(key) {\n        propertyRef = propertyRef[key];\n      });\n\n      return angular.copy(propertyRef);\n    };\n\n    var saveStateProperty = function(stateName, backendName, newValue) {\n      var oldValue = getStatePropertyMemento(stateName, backendName);\n      var newBackendValue = angular.copy(newValue);\n      var oldBackendValue = angular.copy(oldValue);\n\n      if (BACKEND_CONVERSIONS.hasOwnProperty(backendName)) {\n        newBackendValue = convertToBackendRepresentation(newValue, backendName);\n        oldBackendValue = convertToBackendRepresentation(oldValue, backendName);\n      }\n\n      if (!angular.equals(oldValue, newValue)) {\n        ChangeListService.editStateProperty(\n          stateName, backendName, newBackendValue, oldBackendValue);\n\n        var newStateData = _states.getState(stateName);\n        var accessorList = PROPERTY_REF_DATA[backendName];\n\n        var propertyRef = newStateData;\n        for (var i = 0; i < accessorList.length - 1; i++) {\n          propertyRef = propertyRef[accessorList[i]];\n        }\n\n        propertyRef[accessorList[accessorList.length - 1]] = angular.copy(\n          newValue);\n\n        // We do not refresh the state editor immediately after the interaction\n        // id alone is saved, because the customization args dict will be\n        // temporarily invalid. A change in interaction id will always entail\n        // a change in the customization args dict anyway, so the graph will\n        // get refreshed after both properties have been updated.\n        var refreshGraph = (backendName !== \'widget_id\');\n        _setState(stateName, newStateData, refreshGraph);\n      }\n    };\n\n    var convertToBackendRepresentation = function(frontendValue, backendName) {\n      var conversionFunction = BACKEND_CONVERSIONS[backendName];\n      return conversionFunction(frontendValue);\n    };\n\n    // TODO(sll): Add unit tests for all get/save methods.\n    return {\n      init: function(statesBackendDict) {\n        _states = StatesObjectFactory.createFromBackendDict(statesBackendDict);\n        // Initialize the solutionValidityService.\n        SolutionValidityService.init(_states.getStateNames());\n        _states.getStateNames().forEach(function(stateName) {\n          var solution = _states.getState(stateName).interaction.solution;\n          if (solution) {\n            var result = (\n              AnswerClassificationService.getMatchingClassificationResult(\n                stateName,\n                _states.getState(stateName).interaction,\n                solution.correctAnswer,\n                $injector.get(\n                  AngularNameService.getNameOfInteractionRulesService(\n                    _states.getState(stateName).interaction.id))));\n            var solutionIsValid = stateName !== result.outcome.dest;\n            SolutionValidityService.updateValidity(\n              stateName, solutionIsValid);\n          }\n        });\n      },\n      getStates: function() {\n        return angular.copy(_states);\n      },\n      getStateNames: function() {\n        return _states.getStateNames();\n      },\n      hasState: function(stateName) {\n        return _states.hasState(stateName);\n      },\n      getState: function(stateName) {\n        return angular.copy(_states.getState(stateName));\n      },\n      setState: function(stateName, stateData) {\n        _setState(stateName, stateData, true);\n      },\n      isNewStateNameValid: function(newStateName, showWarnings) {\n        if (_states.hasState(newStateName)) {\n          if (showWarnings) {\n            AlertsService.addWarning(\'A state with this name already exists.\');\n          }\n          return false;\n        }\n        return (\n          ValidatorsService.isValidStateName(newStateName, showWarnings));\n      },\n      getStateContentMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'content\');\n      },\n      saveStateContent: function(stateName, newContent) {\n        saveStateProperty(stateName, \'content\', newContent);\n      },\n      getStateParamChangesMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'param_changes\');\n      },\n      saveStateParamChanges: function(stateName, newParamChanges) {\n        saveStateProperty(stateName, \'param_changes\', newParamChanges);\n      },\n      getInteractionIdMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'widget_id\');\n      },\n      saveInteractionId: function(stateName, newInteractionId) {\n        saveStateProperty(stateName, \'widget_id\', newInteractionId);\n      },\n      getInteractionCustomizationArgsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'widget_customization_args\');\n      },\n      saveInteractionCustomizationArgs: function(\n          stateName, newCustomizationArgs) {\n        saveStateProperty(\n          stateName, \'widget_customization_args\', newCustomizationArgs);\n      },\n      getInteractionAnswerGroupsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'answer_groups\');\n      },\n      saveInteractionAnswerGroups: function(stateName, newAnswerGroups) {\n        saveStateProperty(stateName, \'answer_groups\', newAnswerGroups);\n        stateAnswerGroupsSavedCallbacks.forEach(function(callback) {\n          callback(stateName);\n        });\n      },\n      getConfirmedUnclassifiedAnswersMemento: function(stateName) {\n        return getStatePropertyMemento(\n          stateName, \'confirmed_unclassified_answers\');\n      },\n      saveConfirmedUnclassifiedAnswers: function(stateName, newAnswers) {\n        saveStateProperty(\n          stateName, \'confirmed_unclassified_answers\', newAnswers);\n      },\n      getInteractionDefaultOutcomeMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'default_outcome\');\n      },\n      saveInteractionDefaultOutcome: function(stateName, newDefaultOutcome) {\n        saveStateProperty(stateName, \'default_outcome\', newDefaultOutcome);\n      },\n      getHintsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'hints\');\n      },\n      saveHints: function(stateName, newHints) {\n        saveStateProperty(stateName, \'hints\', newHints);\n      },\n      getSolutionMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, \'solution\');\n      },\n      saveSolution: function(stateName, newSolution) {\n        saveStateProperty(stateName, \'solution\', newSolution);\n      },\n      getContentIdsToAudioTranslationsMemento: function(stateName) {\n        return getStatePropertyMemento(\n          stateName, \'content_ids_to_audio_translations\');\n      },\n      saveContentIdsToAudioTranslations: function(\n          stateName, newContentIdsToAudioTranslations) {\n        saveStateProperty(\n          stateName, \'content_ids_to_audio_translations\',\n          newContentIdsToAudioTranslations);\n      },\n      isInitialized: function() {\n        return _states !== null;\n      },\n      addState: function(newStateName, successCallback) {\n        newStateName = $filter(\'normalizeWhitespace\')(newStateName);\n        if (!ValidatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (_states.hasState(newStateName)) {\n          AlertsService.addWarning(\'A state with this name already exists.\');\n          return;\n        }\n        AlertsService.clearWarnings();\n\n        _states.addState(newStateName);\n\n        ChangeListService.addState(newStateName);\n        stateAddedCallbacks.forEach(function(callback) {\n          callback(newStateName);\n        });\n        $rootScope.$broadcast(\'refreshGraph\');\n        if (successCallback) {\n          successCallback(newStateName);\n        }\n      },\n      deleteState: function(deleteStateName) {\n        AlertsService.clearWarnings();\n\n        var initStateName = ExplorationInitStateNameService.displayed;\n        if (deleteStateName === initStateName) {\n          return;\n        }\n        if (!_states.hasState(deleteStateName)) {\n          AlertsService.addWarning(\n            \'No state with name \' + deleteStateName + \' exists.\');\n          return;\n        }\n\n        return $uibModal.open({\n          templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_editor/editor_tab/\' +\n            \'confirm_delete_state_modal_directive.html\'),\n          backdrop: true,\n          resolve: {\n            deleteStateName: function() {\n              return deleteStateName;\n            }\n          },\n          controller: [\n            \'$scope\', \'$uibModalInstance\', \'deleteStateName\',\n            function($scope, $uibModalInstance, deleteStateName) {\n              $scope.deleteStateWarningText = (\n                \'Are you sure you want to delete the card "\' +\n                deleteStateName + \'"?\');\n\n              $scope.reallyDelete = function() {\n                $uibModalInstance.close(deleteStateName);\n              };\n\n              $scope.cancel = function() {\n                $uibModalInstance.dismiss(\'cancel\');\n                AlertsService.clearWarnings();\n              };\n            }\n          ]\n        }).result.then(function(deleteStateName) {\n          _states.deleteState(deleteStateName);\n\n          ChangeListService.deleteState(deleteStateName);\n\n          if (StateEditorService.getActiveStateName() === deleteStateName) {\n            StateEditorService.setActiveStateName(\n              ExplorationInitStateNameService.savedMemento);\n          }\n\n          $location.path(\'/gui/\' + StateEditorService.getActiveStateName());\n          stateDeletedCallbacks.forEach(function(callback) {\n            callback(deleteStateName);\n          });\n          $rootScope.$broadcast(\'refreshGraph\');\n          // This ensures that if the deletion changes rules in the current\n          // state, they get updated in the view.\n          $rootScope.$broadcast(\'refreshStateEditor\');\n        });\n      },\n      renameState: function(oldStateName, newStateName) {\n        newStateName = $filter(\'normalizeWhitespace\')(newStateName);\n        if (!ValidatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (_states.hasState(newStateName)) {\n          AlertsService.addWarning(\'A state with this name already exists.\');\n          return;\n        }\n        AlertsService.clearWarnings();\n\n        _states.renameState(oldStateName, newStateName);\n\n        StateEditorService.setActiveStateName(newStateName);\n        // The \'rename state\' command must come before the \'change\n        // init_state_name\' command in the change list, otherwise the backend\n        // will raise an error because the new initial state name does not\n        // exist.\n        ChangeListService.renameState(newStateName, oldStateName);\n        SolutionValidityService.onRenameState(newStateName, oldStateName);\n        // Amend initStateName appropriately, if necessary. Note that this\n        // must come after the state renaming, otherwise saving will lead to\n        // a complaint that the new name is not a valid state name.\n        if (ExplorationInitStateNameService.displayed === oldStateName) {\n          ExplorationInitStateNameService.displayed = newStateName;\n          ExplorationInitStateNameService.saveDisplayedValue(newStateName);\n        }\n        stateRenamedCallbacks.forEach(function(callback) {\n          callback(oldStateName, newStateName);\n        });\n        $rootScope.$broadcast(\'refreshGraph\');\n      },\n      registerOnStateAddedCallback: function(callback) {\n        stateAddedCallbacks.push(callback);\n      },\n      registerOnStateDeletedCallback: function(callback) {\n        stateDeletedCallbacks.push(callback);\n      },\n      registerOnStateRenamedCallback: function(callback) {\n        stateRenamedCallbacks.push(callback);\n      },\n      registerOnStateAnswerGroupsSavedCallback: function(callback) {\n        stateAnswerGroupsSavedCallbacks.push(callback);\n      },\n    };\n  }\n]);'

blocks = {}
debug_info = ''
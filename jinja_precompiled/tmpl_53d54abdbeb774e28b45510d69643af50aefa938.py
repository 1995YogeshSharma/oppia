from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'components/top_navigation_bar/TopNavigationBarDirective.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directive for the top navigation bar. This excludes the part\n * of the navbar that is used for local navigation (such as the various tabs in\n * the editor pages).\n */\n\noppia.directive(\'topNavigationBar\', [\n  \'UrlInterpolationService\', function(UrlInterpolationService) {\n    return {\n      restrict: \'E\',\n      scope: {},\n      templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n        \'/components/top_navigation_bar/\' +\n        \'top_navigation_bar_directive.html\'),\n      controller: [\n        \'$scope\', \'$http\', \'$window\', \'$timeout\', \'$translate\',\n        \'SidebarStatusService\', \'LABEL_FOR_CLEARING_FOCUS\', \'UserService\',\n        \'siteAnalyticsService\', \'WindowDimensionsService\', \'DebouncerService\',\n        \'DeviceInfoService\',\n        function(\n            $scope, $http, $window, $timeout, $translate,\n            SidebarStatusService, LABEL_FOR_CLEARING_FOCUS, UserService,\n            siteAnalyticsService, WindowDimensionsService, DebouncerService,\n            DeviceInfoService) {\n          if (GLOBALS.userIsLoggedIn && GLOBALS.preferredSiteLanguageCode) {\n            $translate.use(GLOBALS.preferredSiteLanguageCode);\n          }\n          var NAV_MODE_SIGNUP = \'signup\';\n          var NAV_MODES_WITH_CUSTOM_LOCAL_NAV = [\n            \'create\', \'explore\', \'collection\', \'topics_and_skills_dashboard\',\n            \'topic_editor\', \'story_editor\'];\n          $scope.NAV_MODE = GLOBALS.NAV_MODE;\n          $scope.LABEL_FOR_CLEARING_FOCUS = LABEL_FOR_CLEARING_FOCUS;\n          $scope.getStaticImageUrl = UrlInterpolationService.getStaticImageUrl;\n          $scope.activeMenuName = \'\';\n          $scope.username = GLOBALS.username;\n          UserService.getProfileImageDataUrlAsync().then(function(dataUrl) {\n            $scope.profilePictureDataUrl = dataUrl;\n          });\n          $scope.isAdmin = GLOBALS.isAdmin;\n          $scope.isModerator = GLOBALS.isModerator;\n          $scope.isSuperAdmin = GLOBALS.isSuperAdmin;\n          $scope.logoutUrl = GLOBALS.logoutUrl;\n          $scope.ACTION_OPEN = \'open\';\n          $scope.ACTION_CLOSE = \'close\';\n          $scope.KEYBOARD_EVENT_TO_KEY_CODES = {\n            enter: {\n              shiftKeyIsPressed: false,\n              keyCode: 13\n            },\n            tab: {\n              shiftKeyIsPressed: false,\n              keyCode: 9\n            },\n            shiftTab: {\n              shiftKeyIsPressed: true,\n              keyCode: 9\n            }\n          };\n          if ($scope.username) {\n            $scope.profilePageUrl = UrlInterpolationService.interpolateUrl(\n              \'/profile/<username>\', {\n                username: $scope.username\n              });\n          }\n          $scope.userMenuIsShown = ($scope.NAV_MODE !== NAV_MODE_SIGNUP);\n          $scope.standardNavIsShown = (\n            NAV_MODES_WITH_CUSTOM_LOCAL_NAV.indexOf($scope.NAV_MODE) === -1);\n\n          $scope.onLoginButtonClicked = function() {\n            siteAnalyticsService.registerStartLoginEvent(\'loginButton\');\n            $timeout(function() {\n              $window.location = GLOBALS.loginUrl;\n            }, 150);\n          };\n\n          $scope.googleSignInIconUrl = (\n            UrlInterpolationService.getStaticImageUrl(\n              \'/google_signin_buttons/google_signin.svg\'));\n          $scope.onLogoutButtonClicked = function() {\n            $window.localStorage.removeItem(\'last_uploaded_audio_lang\');\n          };\n\n          /**\n           * Opens the submenu.\n           * @param {object} evt\n           * @param {String} menuName - name of menu, on which\n           * open/close action to be performed (aboutMenu,profileMenu).\n           */\n          $scope.openSubmenu = function(evt, menuName) {\n            // Focus on the current target before opening its submenu.\n            angular.element(evt.currentTarget).focus();\n            $scope.activeMenuName = menuName;\n          };\n          $scope.blurNavigationLinks = function(evt) {\n            // This is required because if about submenu is in open state\n            // and when you hover on library, both will be highlighted,\n            // To avoid that, blur all the a\'s in nav, so that only one\n            // will be highlighted.\n            $(\'nav a\').blur();\n          };\n          $scope.closeSubmenu = function(evt) {\n            $scope.activeMenuName = \'\';\n            angular.element(evt.currentTarget).closest(\'li\')\n              .find(\'a\').blur();\n          };\n          $scope.closeSubmenuIfNotMobile = function(evt) {\n            if (DeviceInfoService.isMobileDevice()) {\n              return;\n            }\n            $scope.closeSubmenu(evt);\n          };\n          /**\n           * Handles keydown events on menus.\n           * @param {object} evt\n           * @param {String} menuName - name of menu to perform action\n           * on(aboutMenu/profileMenu)\n           * @param {object} eventsTobeHandled - Map keyboard events(\'Enter\') to\n           * corresponding actions to be performed(open/close).\n           *\n           * @example\n           *  onMenuKeypress($event, \'aboutMenu\', {enter: \'open\'})\n           */\n          $scope.onMenuKeypress = function(evt, menuName, eventsTobeHandled) {\n            var targetEvents = Object.keys(eventsTobeHandled);\n            for (var i = 0; i < targetEvents.length; i++) {\n              var keyCodeSpec =\n                $scope.KEYBOARD_EVENT_TO_KEY_CODES[targetEvents[i]];\n              if (keyCodeSpec.keyCode === evt.keyCode &&\n                evt.shiftKey === keyCodeSpec.shiftKeyIsPressed) {\n                if (eventsTobeHandled[targetEvents[i]] === $scope.ACTION_OPEN) {\n                  $scope.openSubmenu(evt, menuName);\n                } else if (eventsTobeHandled[targetEvents[i]] ===\n                  $scope.ACTION_CLOSE) {\n                  $scope.closeSubmenu(evt);\n                } else {\n                  throw Error(\'Invalid action type.\');\n                }\n              }\n            }\n          };\n          // Close the submenu if focus or click occurs anywhere outside of\n          // the menu or outside of its parent (which opens submenu on hover).\n          angular.element(document).on(\'click\', function(evt) {\n            if (!angular.element(evt.target).closest(\'li\').length) {\n              $scope.activeMenuName = \'\';\n              $scope.$apply();\n            }\n          });\n\n          if (GLOBALS.userIsLoggedIn) {\n            // Show the number of unseen notifications in the navbar and page\n            // title, unless the user is already on the dashboard page.\n            $http.get(\'/notificationshandler\').then(function(response) {\n              var data = response.data;\n              if ($window.location.pathname !== \'/\') {\n                $scope.numUnseenNotifications = data.num_unseen_notifications;\n                if ($scope.numUnseenNotifications > 0) {\n                  $window.document.title = (\n                    \'(\' + $scope.numUnseenNotifications + \') \' +\n                    $window.document.title);\n                }\n              }\n            });\n          }\n\n          $scope.windowIsNarrow = WindowDimensionsService.isWindowNarrow();\n          var currentWindowWidth = WindowDimensionsService.getWidth();\n          $scope.navElementsVisibilityStatus = {};\n          // The order of the elements in this array specifies the order in\n          // which they will be hidden. Earlier elements will be hidden first.\n          var NAV_ELEMENTS_ORDER = [\n            \'I18N_TOPNAV_DONATE\', \'I18N_TOPNAV_ABOUT\',\n            \'I18N_CREATE_EXPLORATION_CREATE\', \'I18N_TOPNAV_LIBRARY\'];\n          for (var i = 0; i < NAV_ELEMENTS_ORDER.length; i++) {\n            $scope.navElementsVisibilityStatus[NAV_ELEMENTS_ORDER[i]] = true;\n          }\n\n          WindowDimensionsService.registerOnResizeHook(function() {\n            $scope.windowIsNarrow = WindowDimensionsService.isWindowNarrow();\n            $scope.$apply();\n            // If window is resized larger, try displaying the hidden elements.\n            if (currentWindowWidth < WindowDimensionsService.getWidth()) {\n              for (var i = 0; i < NAV_ELEMENTS_ORDER.length; i++) {\n                if (\n                  !$scope.navElementsVisibilityStatus[NAV_ELEMENTS_ORDER[i]]) {\n                  $scope.navElementsVisibilityStatus[NAV_ELEMENTS_ORDER[i]] =\n                    true;\n                }\n              }\n            }\n\n            // Close the sidebar, if necessary.\n            SidebarStatusService.closeSidebar();\n            $scope.sidebarIsShown = SidebarStatusService.isSidebarShown();\n            currentWindowWidth = WindowDimensionsService.getWidth();\n            truncateNavbarDebounced();\n          });\n          $scope.isSidebarShown = function() {\n            if (SidebarStatusService.isSidebarShown()) {\n              angular.element(document.body).addClass(\'oppia-stop-scroll\');\n            } else {\n              angular.element(document.body).removeClass(\'oppia-stop-scroll\');\n            }\n            return SidebarStatusService.isSidebarShown();\n          };\n          $scope.toggleSidebar = function() {\n            SidebarStatusService.toggleSidebar();\n          };\n\n          /**\n           * Checks if i18n has been run.\n           * If i18n has not yet run, the <a> and <span> tags will have\n           * no text content, so their innerText.length value will be 0.\n           * @returns {boolean}\n           */\n          var checkIfI18NCompleted = function() {\n            var i18nCompleted = true;\n            var tabs = document.querySelectorAll(\'.oppia-navbar-tab-content\');\n            for (var i = 0; i < tabs.length; i++) {\n              if (tabs[i].innerText.length === 0) {\n                i18nCompleted = false;\n                break;\n              }\n            }\n            return i18nCompleted;\n          };\n\n          /**\n           * Checks if window is >768px and i18n is completed, then checks\n           * for overflow. If overflow is detected, hides the least important\n           * tab and then calls itself again after a 50ms delay.\n           */\n          var truncateNavbar = function() {\n            // If the window is narrow, the standard nav tabs are not shown.\n            if (WindowDimensionsService.isWindowNarrow()) {\n              return;\n            }\n\n            // If i18n hasn\'t completed, retry after 100ms.\n            if (!checkIfI18NCompleted()) {\n              $timeout(truncateNavbar, 100);\n              return;\n            }\n\n            // The value of 60px used here comes from measuring the normal\n            // height of the navbar (56px) in Chrome\'s inspector and rounding\n            // up. If the height of the navbar is changed in the future this\n            // will need to be updated.\n            if (document.querySelector(\'div.collapse.navbar-collapse\')\n              .clientHeight > 60) {\n              for (var i = 0; i < NAV_ELEMENTS_ORDER.length; i++) {\n                if (\n                  $scope.navElementsVisibilityStatus[NAV_ELEMENTS_ORDER[i]]) {\n                  // Hide one element, then check again after 50ms.\n                  // This gives the browser time to render the visibility\n                  // change.\n                  $scope.navElementsVisibilityStatus[NAV_ELEMENTS_ORDER[i]] =\n                    false;\n                  // Force a digest cycle to hide element immediately.\n                  // Otherwise it would be hidden after the next call.\n                  // This is due to setTimeout use in debounce.\n                  $scope.$apply();\n                  $timeout(truncateNavbar, 50);\n                  return;\n                }\n              }\n            }\n          };\n\n          var truncateNavbarDebounced =\n            DebouncerService.debounce(truncateNavbar, 500);\n\n          // The function needs to be run after i18n. A timeout of 0 appears to\n          // run after i18n in Chrome, but not other browsers. The function will\n          // check if i18n is complete and set a new timeout if it is not. Since\n          // a timeout of 0 works for at least one browser, it is used here.\n          $timeout(truncateNavbar, 0);\n          $scope.$on(\'searchBarLoaded\', function() {\n            $timeout(truncateNavbar, 100);\n          });\n        }\n      ]\n    };\n  }]);'

blocks = {}
debug_info = ''
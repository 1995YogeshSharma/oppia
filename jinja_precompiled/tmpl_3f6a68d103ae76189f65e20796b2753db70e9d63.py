from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/topic_editor/TopicEditorStateServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for TopicEditorStateService.\n */\n\ndescribe(\'Topic editor state service\', function() {\n  var TopicEditorStateService = null;\n  var TopicObjectFactory = null;\n  var SubtopicPageObjectFactory = null;\n  var TopicRightsObjectFactory = null;\n  var TopicUpdateService = null;\n  var fakeEditableTopicBackendApiService = null;\n  var fakeTopicRightsBackendApiService = null;\n\n  var FakeEditableTopicBackendApiService = function() {\n    var self = {};\n\n    var _fetchOrUpdateTopic = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.newBackendTopicObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    var _fetchStories = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.backendStorySummariesObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    var _fetchSubtopicPage = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.newBackendSubtopicPageObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.newBackendSubtopicPageObject = {};\n    self.newBackendTopicObject = {};\n    self.backendStorySummariesObject = [];\n    self.failure = null;\n    self.fetchTopic = _fetchOrUpdateTopic;\n    self.fetchSubtopicPage = _fetchSubtopicPage;\n    self.updateTopic = _fetchOrUpdateTopic;\n    self.fetchStories = _fetchStories;\n\n    return self;\n  };\n\n  var FakeTopicRightsBackendApiService = function() {\n    var self = {};\n\n    var _fetchTopicRights = function() {\n      return $q(function(resolve, reject) {\n        if (!self.failure) {\n          resolve(self.backendTopicRightsObject);\n        } else {\n          reject();\n        }\n      });\n    };\n\n    self.backendTopicRightsObject = {};\n    self.failure = null;\n    self.fetchTopicRights = _fetchTopicRights;\n\n    return self;\n  };\n\n  beforeEach(module(\'oppia\'));\n  beforeEach(module(\'oppia\', GLOBALS.TRANSLATOR_PROVIDER_FOR_TESTS));\n  beforeEach(module(\'oppia\', function($provide) {\n    fakeEditableTopicBackendApiService = (\n      new FakeEditableTopicBackendApiService());\n    $provide.value(\n      \'EditableTopicBackendApiService\',\n      [fakeEditableTopicBackendApiService][0]);\n\n    fakeTopicRightsBackendApiService = (\n      new FakeTopicRightsBackendApiService());\n    $provide.value(\n      \'TopicRightsBackendApiService\',\n      [fakeTopicRightsBackendApiService][0]);\n  }));\n\n  beforeEach(inject(function($injector) {\n    TopicEditorStateService = $injector.get(\n      \'TopicEditorStateService\');\n    TopicObjectFactory = $injector.get(\'TopicObjectFactory\');\n    SubtopicPageObjectFactory = $injector.get(\'SubtopicPageObjectFactory\');\n    TopicRightsObjectFactory = $injector.get(\n      \'TopicRightsObjectFactory\');\n    TopicUpdateService = $injector.get(\'TopicUpdateService\');\n    $q = $injector.get(\'$q\');\n    $rootScope = $injector.get(\'$rootScope\');\n    $scope = $rootScope.$new();\n\n    fakeEditableTopicBackendApiService.newBackendTopicObject = {\n      topicDict: {\n        id: \'0\',\n        name: \'Topic Name\',\n        description: \'Topic Description\',\n        canonical_story_ids: [\'story_1\'],\n        additional_story_ids: [\'story_2\'],\n        uncategorized_skill_ids: [\'skill_1\'],\n        subtopics: [],\n        language_code: \'en\',\n        next_subtopic_id: 1,\n        subtopic_schema_version: \'1\',\n        version: \'1\'\n      },\n      skillIdToDescriptionDict: {\n        skill_1: \'Description 1\'\n      }\n    };\n\n    secondBackendTopicObject = {\n      topicDict: {\n        id: \'0\',\n        name: \'Topic Name 2\',\n        description: \'Topic Description 2\',\n        canonical_story_ids: [\'story_3\'],\n        additional_story_ids: [\'story_4\'],\n        uncategorized_skill_ids: [\'skill_5\'],\n        subtopics: [\n          {\n            id: 1,\n            title: \'Title\',\n            skill_ids: [\'skill_2\']\n          }, {\n            id: 2,\n            title: \'Title 2\',\n            skill_ids: [\'skill_3\']\n          }\n        ],\n        language_code: \'en\',\n        next_subtopic_id: 3,\n        subtopic_schema_version: \'1\',\n        version: \'1\'\n      },\n      skillIdToDescriptionDict: {\n        skill_2: \'Description 2\',\n        skill_3: \'Description 3\',\n        skill_5: \'Description 5\'\n      }\n    };\n\n    topicRightsObject = {\n      id: \'0\',\n      can_edit_topic: \'true\',\n      is_published: \'true\',\n      can_publish_topic: \'true\'\n    };\n    fakeTopicRightsBackendApiService.backendTopicRightsObject = (\n      topicRightsObject);\n\n    secondTopicRightsObject = {\n      id: \'0\',\n      can_edit_topic: \'true\',\n      is_published: \'false\',\n      can_publish_topic: \'false\'\n    };\n\n    subtopicPageObject = {\n      id: \'validTopicId-0\',\n      topic_id: \'validTopicId\',\n      html_data: \'<p>Data</p>\',\n      language_code: \'en\'\n    };\n    fakeEditableTopicBackendApiService.newBackendSubtopicPageObject = (\n      subtopicPageObject);\n\n    secondSubtopicPageObject = {\n      id: \'validTopicId-0\',\n      topic_id: \'validTopicId\',\n      html_data: \'<p>Data</p>\',\n      language_code: \'en\'\n    };\n  }));\n\n  it(\'should request to load the topic from the backend\', function() {\n    spyOn(\n      fakeEditableTopicBackendApiService, \'fetchTopic\').and.callThrough();\n\n    TopicEditorStateService.loadTopic(5);\n    expect(fakeEditableTopicBackendApiService.fetchTopic).toHaveBeenCalled();\n  });\n\n  it(\'should request to load the subtopic page from the backend\', function() {\n    spyOn(\n      fakeEditableTopicBackendApiService, \'fetchSubtopicPage\'\n    ).and.callThrough();\n\n    TopicEditorStateService.loadSubtopicPage(\'validTopicId\', 1);\n    expect(\n      fakeEditableTopicBackendApiService.fetchSubtopicPage).toHaveBeenCalled();\n  });\n\n  it(\'should not request to load the subtopic page from the backend after \' +\n     \'loading it once\', function() {\n    spyOn(\n      fakeEditableTopicBackendApiService, \'fetchSubtopicPage\'\n    ).and.callThrough();\n\n    subtopicPage = SubtopicPageObjectFactory.createFromBackendDict(\n      secondSubtopicPageObject);\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    TopicEditorStateService.loadSubtopicPage(\'validTopicId\', 0);\n    expect(\n      fakeEditableTopicBackendApiService.fetchSubtopicPage\n    ).not.toHaveBeenCalled();\n  });\n\n  it(\'should not add duplicate subtopic pages to the local cache\', function() {\n    subtopicPage = SubtopicPageObjectFactory.createFromBackendDict(\n      secondSubtopicPageObject);\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(1);\n    subtopicPage.setHtmlData(\'<p>New Data</p>\');\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(1);\n    expect(\n      TopicEditorStateService.getSubtopicPage().getHtmlData()\n    ).toEqual(\'<p>New Data</p>\');\n  });\n\n  it(\'should correctly delete newly created subtopic pages from the \' +\n    \'local cache\', function() {\n    subtopicPage = SubtopicPageObjectFactory.createFromBackendDict(\n      secondSubtopicPageObject);\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    subtopicPage.setId(\'validTopicId-1\');\n    subtopicPage.setHtmlData(\'<p>Data 1</p>\');\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    subtopicPage.setId(\'validTopicId-2\');\n    subtopicPage.setHtmlData(\'<p>Data 2</p>\');\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(3);\n    TopicEditorStateService.deleteSubtopicPage(\'validTopicId\', 1);\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(2);\n\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getId()\n    ).toEqual(\'validTopicId-0\');\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getHtmlData()\n    ).toEqual(\'<p>Data</p>\');\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[1].getId()\n    ).toEqual(\'validTopicId-1\');\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[1].getHtmlData()\n    ).toEqual(\'<p>Data 2</p>\');\n  });\n\n  it(\'should correctly delete new subtopic pages without changing already \' +\n    \'existing subtopic pages from the local cache\', function() {\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n    subtopicPage = SubtopicPageObjectFactory.createFromBackendDict(\n      secondSubtopicPageObject);\n    subtopicPage.setId(\'validTopicId-1\');\n    subtopicPage.setHtmlData(\'<p>Data 1</p>\');\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    TopicEditorStateService.loadSubtopicPage(\'validTopicId\', 0);\n    $rootScope.$apply();\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\'subtopicPageLoaded\');\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toBe(2);\n    TopicEditorStateService.deleteSubtopicPage(\'validTopicId\', 1);\n\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(1);\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getId()\n    ).toEqual(\'validTopicId-0\');\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getHtmlData()\n    ).toEqual(\'<p>Data</p>\');\n  });\n\n  it(\'should correctly delete already existing subtopic pages without \' +\n    \'changing newly created subtopic pages from the local cache\', function() {\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n    subtopicPage = SubtopicPageObjectFactory.createFromBackendDict(\n      secondSubtopicPageObject);\n    subtopicPage.setId(\'validTopicId-1\');\n    subtopicPage.setHtmlData(\'<p>Data 1</p>\');\n    TopicEditorStateService.setSubtopicPage(subtopicPage);\n    TopicEditorStateService.loadSubtopicPage(\'validTopicId\', 0);\n    $rootScope.$apply();\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\'subtopicPageLoaded\');\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toBe(2);\n    TopicEditorStateService.deleteSubtopicPage(\'validTopicId\', 0);\n\n    expect(TopicEditorStateService.getCachedSubtopicPages().length).toEqual(1);\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getId()\n    ).toEqual(\'validTopicId-1\');\n    expect(\n      TopicEditorStateService.getCachedSubtopicPages()[0].getHtmlData()\n    ).toEqual(\'<p>Data 1</p>\');\n  });\n\n  it(\'should request to load the topic rights from the backend\',\n    function() {\n      spyOn(fakeTopicRightsBackendApiService, \'fetchTopicRights\')\n        .and.callThrough();\n\n      TopicEditorStateService.loadTopic(5);\n      expect(fakeTopicRightsBackendApiService.fetchTopicRights)\n        .toHaveBeenCalled();\n    }\n  );\n\n  it(\'should fire an init event after loading the first topic\',\n    function() {\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n      TopicEditorStateService.loadTopic(5);\n      $rootScope.$apply();\n\n      expect($rootScope.$broadcast).toHaveBeenCalledWith(\'topicInitialized\');\n    }\n  );\n\n  it(\'should fire a loaded event after loading a new subtopic page\',\n    function() {\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n      TopicEditorStateService.loadSubtopicPage(\'validTopicId\', 1);\n      $rootScope.$apply();\n\n      expect($rootScope.$broadcast).toHaveBeenCalledWith(\'subtopicPageLoaded\');\n    }\n  );\n\n  it(\'should fire an update event after loading more topics\', function() {\n    // Load initial topic.\n    TopicEditorStateService.loadTopic(5);\n    $rootScope.$apply();\n\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n\n    // Load a second topic.\n    TopicEditorStateService.loadTopic(1);\n    $rootScope.$apply();\n\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\'topicReinitialized\');\n  });\n\n  it(\'should track whether it is currently loading the topic\', function() {\n    expect(TopicEditorStateService.isLoadingTopic()).toBe(false);\n\n    TopicEditorStateService.loadTopic(5);\n    expect(TopicEditorStateService.isLoadingTopic()).toBe(true);\n\n    $rootScope.$apply();\n    expect(TopicEditorStateService.isLoadingTopic()).toBe(false);\n  });\n\n  it(\'should indicate a topic is no longer loading after an error\',\n    function() {\n      expect(TopicEditorStateService.isLoadingTopic()).toBe(false);\n      fakeEditableTopicBackendApiService.failure = \'Internal 500 error\';\n\n      TopicEditorStateService.loadTopic(5);\n      expect(TopicEditorStateService.isLoadingTopic()).toBe(true);\n\n      $rootScope.$apply();\n      expect(TopicEditorStateService.isLoadingTopic()).toBe(false);\n    }\n  );\n\n  it(\'it should report that a topic has loaded through loadTopic()\',\n    function() {\n      expect(TopicEditorStateService.hasLoadedTopic()).toBe(false);\n\n      TopicEditorStateService.loadTopic(5);\n      expect(TopicEditorStateService.hasLoadedTopic()).toBe(false);\n\n      $rootScope.$apply();\n      expect(TopicEditorStateService.hasLoadedTopic()).toBe(true);\n    }\n  );\n\n  it(\'it should report that a topic has loaded through setTopic()\',\n    function() {\n      expect(TopicEditorStateService.hasLoadedTopic()).toBe(false);\n\n      var newTopic = TopicObjectFactory.create(\n        secondBackendTopicObject.topicDict,\n        secondBackendTopicObject.skillIdToDescriptionDict);\n      TopicEditorStateService.setTopic(newTopic);\n      expect(TopicEditorStateService.hasLoadedTopic()).toBe(true);\n    }\n  );\n\n  it(\'should initially return an interstitial topic\', function() {\n    var topic = TopicEditorStateService.getTopic();\n    expect(topic.getId()).toEqual(null);\n    expect(topic.getName()).toEqual(\'Topic name loading\');\n    expect(topic.getDescription()).toEqual(\'Topic description loading\');\n    expect(topic.getCanonicalStoryIds()).toEqual([]);\n    expect(topic.getAdditionalStoryIds()).toEqual([]);\n    expect(topic.getUncategorizedSkillSummaries()).toEqual([]);\n    expect(topic.getSubtopics()).toEqual([]);\n  });\n\n  it(\'should initially return an interstitial subtopic page\', function() {\n    var subtopicPage = TopicEditorStateService.getSubtopicPage();\n    expect(subtopicPage.getId()).toEqual(null);\n    expect(subtopicPage.getTopicId()).toEqual(null);\n    expect(subtopicPage.getHtmlData()).toEqual(null);\n    expect(subtopicPage.getLanguageCode()).toEqual(\'en\');\n  });\n\n  it(\'should initially return an interstitial topic rights object\', function() {\n    var topicRights = TopicEditorStateService.getTopicRights();\n    expect(topicRights.isPublished()).toEqual(false);\n    expect(topicRights.canEditTopic()).toEqual(false);\n    expect(topicRights.canPublishTopic()).toEqual(false);\n  });\n\n  it(\'should be able to set a new topic with an in-place copy\',\n    function() {\n      var previousTopic = TopicEditorStateService.getTopic();\n      var expectedTopic = TopicObjectFactory.create(\n        secondBackendTopicObject.topicDict,\n        secondBackendTopicObject.skillIdToDescriptionDict\n      );\n      expect(previousTopic).not.toEqual(expectedTopic);\n\n      TopicEditorStateService.setTopic(expectedTopic);\n\n      var actualTopic = TopicEditorStateService.getTopic();\n      expect(actualTopic).toEqual(expectedTopic);\n\n      expect(actualTopic).toBe(previousTopic);\n      expect(actualTopic).not.toBe(expectedTopic);\n    }\n  );\n\n  it(\'should be able to set a new topic rights with an in-place copy\',\n    function() {\n      var previousTopicRights = TopicEditorStateService.getTopicRights();\n      var expectedTopicRights = TopicRightsObjectFactory.createFromBackendDict(\n        secondTopicRightsObject);\n      expect(previousTopicRights).not.toEqual(expectedTopicRights);\n\n      TopicEditorStateService.setTopicRights(expectedTopicRights);\n\n      var actualTopicRights = TopicEditorStateService.getTopicRights();\n      expect(actualTopicRights).toEqual(expectedTopicRights);\n\n      expect(actualTopicRights).toBe(previousTopicRights);\n      expect(actualTopicRights).not.toBe(expectedTopicRights);\n    }\n  );\n\n  it(\'should fail to save the topic without first loading one\',\n    function() {\n      expect(function() {\n        TopicEditorStateService.saveTopic(\'Commit message\');\n      }).toThrow();\n    }\n  );\n\n  it(\'should not save the topic if there are no pending changes\',\n    function() {\n      TopicEditorStateService.loadTopic(5);\n      $rootScope.$apply();\n\n      spyOn($rootScope, \'$broadcast\').and.callThrough();\n      expect(TopicEditorStateService.saveTopic(\n        \'Commit message\')).toBe(false);\n      expect($rootScope.$broadcast).not.toHaveBeenCalled();\n    }\n  );\n\n  it(\'should be able to save the topic and pending changes\', function() {\n    spyOn(\n      fakeEditableTopicBackendApiService,\n      \'updateTopic\').and.callThrough();\n\n    TopicEditorStateService.loadTopic(0);\n    TopicUpdateService.setTopicName(\n      TopicEditorStateService.getTopic(), \'New name\');\n    $rootScope.$apply();\n\n    expect(TopicEditorStateService.saveTopic(\n      \'Commit message\')).toBe(true);\n    $rootScope.$apply();\n\n    var expectedId = \'0\';\n    var expectedVersion = \'1\';\n    var expectedCommitMessage = \'Commit message\';\n    var updateTopicSpy = (\n      fakeEditableTopicBackendApiService.updateTopic);\n    expect(updateTopicSpy).toHaveBeenCalledWith(\n      expectedId, expectedVersion, expectedCommitMessage, jasmine.any(Object));\n  });\n\n  it(\'should fire an update event after saving the topic\', function() {\n    TopicEditorStateService.loadTopic(5);\n    TopicUpdateService.setTopicName(\n      TopicEditorStateService.getTopic(), \'New name\');\n    $rootScope.$apply();\n\n    spyOn($rootScope, \'$broadcast\').and.callThrough();\n    TopicEditorStateService.saveTopic(\'Commit message\');\n    $rootScope.$apply();\n\n    expect($rootScope.$broadcast).toHaveBeenCalledWith(\n      \'topicReinitialized\');\n  });\n\n  it(\'should track whether it is currently saving the topic\', function() {\n    TopicEditorStateService.loadTopic(5);\n    TopicUpdateService.setTopicName(\n      TopicEditorStateService.getTopic(), \'New name\');\n    $rootScope.$apply();\n\n    expect(TopicEditorStateService.isSavingTopic()).toBe(false);\n    TopicEditorStateService.saveTopic(\'Commit message\');\n    expect(TopicEditorStateService.isSavingTopic()).toBe(true);\n\n    $rootScope.$apply();\n    expect(TopicEditorStateService.isSavingTopic()).toBe(false);\n  });\n\n  it(\'should indicate a topic is no longer saving after an error\',\n    function() {\n      TopicEditorStateService.loadTopic(5);\n      TopicUpdateService.setTopicName(\n        TopicEditorStateService.getTopic(), \'New name\');\n      $rootScope.$apply();\n\n      expect(TopicEditorStateService.isSavingTopic()).toBe(false);\n      fakeEditableTopicBackendApiService.failure = \'Internal 500 error\';\n\n      TopicEditorStateService.saveTopic(\'Commit message\');\n      expect(TopicEditorStateService.isSavingTopic()).toBe(true);\n\n      $rootScope.$apply();\n      expect(TopicEditorStateService.isSavingTopic()).toBe(false);\n    }\n  );\n});'

blocks = {}
debug_info = ''
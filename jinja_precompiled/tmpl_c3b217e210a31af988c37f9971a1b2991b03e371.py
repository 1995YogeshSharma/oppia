from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/TrainingDataServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the training data service.\n */\n\ndescribe(\'TrainingDataService\', function() {\n  var $httpBackend;\n  var scope, siis, ecs, cls, rs, tds, ess, IS, oof;\n  var mockExplorationData;\n\n  beforeEach(module(\'oppia\', GLOBALS.TRANSLATOR_PROVIDER_FOR_TESTS));\n\n  beforeEach(function() {\n    module(\'oppia\');\n    // Set a global value for INTERACTION_SPECS that will be used by all the\n    // descendant dependencies.\n    module(function($provide) {\n      $provide.constant(\'INTERACTION_SPECS\', {\n        TextInput: {\n          display_mode: \'inline\',\n          is_terminal: false\n        }\n      });\n    });\n    mockExplorationData = {\n      explorationId: 0,\n      autosaveChangeList: function() {}\n    };\n    module(function($provide) {\n      $provide.value(\'ExplorationDataService\', [mockExplorationData][0]);\n    });\n    spyOn(mockExplorationData, \'autosaveChangeList\');\n  });\n\n  beforeEach(inject(function($injector, $rootScope) {\n    scope = $rootScope.$new();\n    $httpBackend = $injector.get(\'$httpBackend\');\n    siis = $injector.get(\'StateInteractionIdService\');\n    ecs = $injector.get(\'StateEditorService\');\n    cls = $injector.get(\'ChangeListService\');\n    ess = $injector.get(\'ExplorationStatesService\');\n    rs = $injector.get(\'ResponsesService\');\n    tds = $injector.get(\'TrainingDataService\');\n    IS = $injector.get(\'INTERACTION_SPECS\');\n    oof = $injector.get(\'OutcomeObjectFactory\');\n\n    // Set the currently loaded interaction ID.\n    siis.savedMemento = \'TextInput\';\n\n    ess.init({\n      State: {\n        content: {\n          content_id: \'content\',\n          html: \'State Content\'\n        },\n        content_ids_to_audio_translations: {\n          content: {},\n          default_outcome: {},\n          feedback_1: {}\n        },\n        interaction: {\n          id: \'TextInput\',\n          answer_groups: [{\n            rule_specs: [{\n              rule_type: \'Contains\',\n              inputs: {\n                x: \'Test\'\n              }\n            }],\n            outcome: {\n              dest: \'State\',\n              feedback: {\n                content_id: \'feedback_1\',\n                html: \'Feedback\'\n              },\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null,\n              missing_prerequisite_skill_id: null\n            },\n            training_data: [],\n            tagged_misconception_id: null\n          }],\n          default_outcome: {\n            dest: \'State\',\n            feedback: {\n              content_id: \'default_outcome\',\n              html: \'Default\'\n            },\n            labelled_as_correct: false,\n            param_changes: [],\n            refresher_exploration_id: null,\n            missing_prerequisite_skill_id: null\n          },\n          hints: [],\n          confirmed_unclassified_answers: []\n        },\n        param_changes: []\n      }\n    });\n\n    var state = ess.getState(\'State\');\n    rs.init({\n      answerGroups: state.interaction.answerGroups,\n      defaultOutcome: state.interaction.defaultOutcome,\n      confirmedUnclassifiedAnswers: (\n        state.interaction.confirmedUnclassifiedAnswers)\n    });\n\n    ecs.setActiveStateName(\'State\');\n  }));\n\n  it(\'should be able to train answer groups and the default response\',\n    function() {\n      // Training the first answer of a group should add a new classifier.\n      tds.associateWithAnswerGroup(0, \'text answer\');\n      var state = ess.getState(\'State\');\n      expect(state.interaction.answerGroups[0].trainingData).toEqual([\n        \'text answer\'\n      ]);\n\n      // Training a second answer to the same group should append the answer\n      // to the training data.\n      tds.associateWithAnswerGroup(0, \'second answer\');\n      state = ess.getState(\'State\');\n      expect(state.interaction.answerGroups[0].trainingData).toEqual([\n        \'text answer\', \'second answer\'\n      ]);\n\n      // Training the default response should add information to the confirmed\n      // unclassified answers.\n      tds.associateWithDefaultResponse(\'third answer\');\n      state = ess.getState(\'State\');\n      expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n        \'third answer\'\n      ]);\n    }\n  );\n\n  it(\'should be able to retrain answers between answer groups and the \' +\n      \'default outcome\', function() {\n    // Retraining an answer from the answer group to the default outcome\n    // should remove it from the first, then add it to the second.\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    tds.associateWithAnswerGroup(0, \'second answer\');\n    tds.associateWithDefaultResponse(\'third answer\');\n\n    // Verify initial state.\n    var state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\', \'second answer\'\n    ]);\n    expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n      \'third answer\'\n    ]);\n\n    // Try to retrain the second answer (answer group -> default response).\n    tds.associateWithDefaultResponse(\'second answer\');\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\'\n    ]);\n    expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n      \'third answer\', \'second answer\'\n    ]);\n\n    // Try to retrain the third answer (default response -> answer group).\n    tds.associateWithAnswerGroup(0, \'third answer\');\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\', \'third answer\'\n    ]);\n    expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n      \'second answer\'\n    ]);\n  });\n\n  it(\'should not be able to train duplicated answers\', function() {\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    tds.associateWithDefaultResponse(\'second answer\');\n\n    // Verify initial state.\n    var state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\'\n    ]);\n    expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n      \'second answer\'\n    ]);\n\n    // Training a duplicate answer for the answer group should change nothing.\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\'\n    ]);\n\n    // Training a duplicate answer for the default response should change\n    // nothing.\n    tds.associateWithDefaultResponse(\'second answer\');\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\'\n    ]);\n  });\n\n  it(\'should get all potential outcomes of an interaction\', function() {\n    // First the answer group\'s outcome is listed, then the default.\n    expect(tds.getAllPotentialOutcomes(ess.getState(\'State\'))).toEqual([\n      oof.createNew(\'State\', \'feedback_1\', \'Feedback\', []),\n      oof.createNew(\'State\', \'default_outcome\', \'Default\', [])]);\n  });\n\n  it(\'should remove answer from training data associated with given answer \' +\n      \'group\', function() {\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    tds.associateWithAnswerGroup(0, \'second answer\');\n    tds.associateWithAnswerGroup(0, \'another answer\');\n\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\', \'second answer\', \'another answer\'\n    ]);\n\n    tds.removeAnswerFromAnswerGroupTrainingData(\'second answer\', 0);\n\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\', \'another answer\'\n    ]);\n  });\n\n  it(\'should correctly check whether answer is in confirmed unclassified \' +\n      \'answers\', function() {\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    tds.associateWithAnswerGroup(0, \'another answer\');\n    tds.associateWithDefaultResponse(\'second answer\');\n\n    state = ess.getState(\'State\');\n    expect(state.interaction.answerGroups[0].trainingData).toEqual([\n      \'text answer\', \'another answer\'\n    ]);\n    expect(state.interaction.confirmedUnclassifiedAnswers).toEqual([\n      \'second answer\'\n    ]);\n\n    expect(tds.isConfirmedUnclassifiedAnswer(\'text answer\')).toBe(false);\n    expect(tds.isConfirmedUnclassifiedAnswer(\'second answer\')).toBe(true);\n  });\n\n  it(\'should get all the training data answers\', function() {\n    tds.associateWithAnswerGroup(0, \'text answer\');\n    tds.associateWithAnswerGroup(0, \'another answer\');\n    tds.associateWithDefaultResponse(\'second answer\');\n    expect(tds.getTrainingDataAnswers()).toEqual([{\n      answerGroupIndex: 0,\n      answers: [\'text answer\', \'another answer\']\n    }]);\n  });\n});'

blocks = {}
debug_info = ''
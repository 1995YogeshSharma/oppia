from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/TrainingDataEditorPanelService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service which handles opening and closing\n * the training data editor of an answer group.\n */\n\noppia.factory(\'TrainingDataEditorPanelService\', [\n  \'$rootScope\', \'$uibModal\', \'AlertsService\', \'UrlInterpolationService\',\n  function($rootScope, $uibModal, AlertsService, UrlInterpolationService) {\n    return {\n      /**\n      * Opens training data editor for currently selected answer group.\n      */\n      openTrainingDataEditor: function() {\n        AlertsService.clearWarnings();\n        $uibModal.open({\n          templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_editor/editor_tab/\' +\n            \'training_data_editor_directive.html\'),\n          backdrop: true,\n          controller: [\n            \'$scope\', \'$injector\', \'$uibModalInstance\', \'$filter\',\n            \'ExplorationStatesService\', \'StateEditorService\', \'AlertsService\',\n            \'AnswerClassificationService\', \'ContextService\',\n            \'StateInteractionIdService\', \'AngularNameService\',\n            \'EXPLICIT_CLASSIFICATION\', \'TRAINING_DATA_CLASSIFICATION\',\n            \'ExplorationHtmlFormatterService\', \'ResponsesService\',\n            \'StateCustomizationArgsService\', \'TrainingDataService\',\n            \'TrainingModalService\', \'FocusManagerService\',\n            function($scope, $injector, $uibModalInstance, $filter,\n                ExplorationStatesService, StateEditorService, AlertsService,\n                AnswerClassificationService, ContextService,\n                StateInteractionIdService, AngularNameService,\n                EXPLICIT_CLASSIFICATION, TRAINING_DATA_CLASSIFICATION,\n                ExplorationHtmlFormatterService, ResponsesService,\n                StateCustomizationArgsService, TrainingDataService,\n                TrainingModalService, FocusManagerService) {\n              var _explorationId = ContextService.getExplorationId();\n              var _stateName = StateEditorService.getActiveStateName();\n              $scope.stateName = _stateName;\n              var _state = ExplorationStatesService.getState(_stateName);\n              var answerGroupIndex = (\n                ResponsesService.getActiveAnswerGroupIndex());\n\n              var FOCUS_LABEL_TEST_INTERACTION_INPUT = \'testInteractionInput\';\n              $scope.stateContent = _state.content.getHtml();\n              $scope.trainingData = [];\n              $scope.answerGroupHasNonEmptyRules = (\n                ResponsesService.getAnswerGroup(\n                  answerGroupIndex).rules.length > 0);\n              $scope.inputTemplate = (\n                ExplorationHtmlFormatterService.getInteractionHtml(\n                  StateInteractionIdService.savedMemento,\n                  StateCustomizationArgsService.savedMemento,\n                  false, FOCUS_LABEL_TEST_INTERACTION_INPUT));\n\n              var _rebuildTrainingData = function() {\n                $scope.trainingData = [];\n                TrainingDataService.getTrainingDataOfAnswerGroup(\n                  answerGroupIndex).forEach(function(answer) {\n                  var answerTemplate = (\n                    ExplorationHtmlFormatterService.getAnswerHtml(\n                      answer, StateInteractionIdService.savedMemento,\n                      StateCustomizationArgsService.savedMemento));\n                  $scope.trainingData.push({\n                    answer: answer,\n                    answerTemplate: answerTemplate\n                  });\n                });\n              };\n\n              $scope.init = function() {\n                _rebuildTrainingData();\n                $scope.newAnswerIsAlreadyResolved = false;\n                $scope.answerSuccessfullyAdded = false;\n                FocusManagerService.setFocus(\n                  FOCUS_LABEL_TEST_INTERACTION_INPUT);\n              };\n\n              $scope.removeAnswerFromTrainingData = function(answerIndex) {\n                var answer = $scope.trainingData[answerIndex].answer;\n                TrainingDataService.removeAnswerFromAnswerGroupTrainingData(\n                  answer, answerGroupIndex);\n                $scope.trainingData.splice(answerIndex, 1);\n              };\n\n              $scope.exit = function() {\n                $uibModalInstance.close();\n              };\n\n              $scope.submitAnswer = function(newAnswer) {\n                $scope.newAnswerIsAlreadyResolved = false;\n\n                var interactionId = StateInteractionIdService.savedMemento;\n\n                var rulesServiceName =\n                  AngularNameService.getNameOfInteractionRulesService(\n                    interactionId);\n\n                // Inject RulesService dynamically.\n                var rulesService = $injector.get(rulesServiceName);\n\n                var newAnswerTemplate = (\n                  ExplorationHtmlFormatterService.getAnswerHtml(\n                    newAnswer, StateInteractionIdService.savedMemento,\n                    StateCustomizationArgsService.savedMemento));\n\n                var classificationResult = (\n                  AnswerClassificationService.getMatchingClassificationResult(\n                    _stateName, _state.interaction, newAnswer, rulesService));\n                var newAnswerOutcomeDest = classificationResult.outcome.dest;\n                var newAnswerFeedback = classificationResult.outcome.feedback;\n                if (newAnswerOutcomeDest === _stateName) {\n                  newAnswerOutcomeDest = \'(try again)\';\n                }\n\n                $scope.newAnswerTemplate = newAnswerTemplate;\n                $scope.newAnswerFeedback = newAnswerFeedback;\n                $scope.newAnswerOutcomeDest = newAnswerOutcomeDest;\n\n                var classificationType = (\n                  classificationResult.classificationCategorization);\n\n                // If answer is explicitly classified then show the\n                // classification results to the creator.\n                if (classificationType === EXPLICIT_CLASSIFICATION ||\n                    classificationType === TRAINING_DATA_CLASSIFICATION) {\n                  $scope.newAnswerIsAlreadyResolved = true;\n                } else {\n                  TrainingDataService.associateWithAnswerGroup(\n                    answerGroupIndex, newAnswer);\n                  var truncatedAnswer = $filter(\n                    \'truncateInputBasedOnInteractionAnswerType\')(\n                    newAnswer, interactionId, 12);\n                  var successToast = (\n                    \'The answer \' + truncatedAnswer +\n                    \' has been successfully trained.\');\n                  AlertsService.addSuccessMessage(\n                    successToast, 1000);\n                  _rebuildTrainingData();\n                }\n              };\n\n              $scope.openTrainUnresolvedAnswerModal = function(answerIndex) {\n                // An answer group must have either a rule or at least one\n                // answer in training data. Don\'t allow modification of training\n                // data answers if there are no rules and only one training data\n                // answer is present.\n                if (($scope.answerGroupHasNonEmptyRules &&\n                    $scope.trainingData.length > 0) ||\n                    $scope.trainingData.length > 1) {\n                  var answer = $scope.trainingData[answerIndex].answer;\n                  var interactionId = StateInteractionIdService.savedMemento;\n                  return TrainingModalService.openTrainUnresolvedAnswerModal(\n                    answer, function() {\n                      var truncatedAnswer = $filter(\n                        \'truncateInputBasedOnInteractionAnswerType\')(\n                        answer, interactionId, 12);\n                      var successToast = (\n                        \'The answer \' + truncatedAnswer +\n                        \' has been successfully trained.\');\n                      AlertsService.addSuccessMessage(\n                        successToast, 1000);\n                      _rebuildTrainingData();\n                    });\n                }\n                return;\n              };\n\n              $scope.init();\n            }]\n        });\n        // Save the modified training data externally in state content.\n        $rootScope.$broadcast(\'externalSave\');\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
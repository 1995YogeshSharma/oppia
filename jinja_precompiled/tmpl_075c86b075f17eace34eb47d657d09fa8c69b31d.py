from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'directives.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directives that are not associated with reusable components.\n * NB: Reusable component directives should go in the components/ folder.\n */\n\n// HTML bind directive that trusts the value it is given and also evaluates\n// custom directive tags in the provided value.\noppia.directive(\'angularHtmlBind\', [\'$compile\', function($compile) {\n  return {\n    restrict: \'A\',\n    link: function(scope, elm, attrs) {\n      // Clean up old scopes if the html changes.\n      // Reference: https://stackoverflow.com/a/42927814\n      var newScope;\n      scope.$watch(attrs.angularHtmlBind, function(newValue) {\n        if (newScope) {\n          newScope.$destroy();\n        }\n        elm.empty();\n        newScope = scope.$new();\n        elm.html(newValue);\n        $compile(elm.contents())(newScope);\n      });\n    }\n  };\n}]);\n\noppia.directive(\'mathjaxBind\', [function() {\n  return {\n    restrict: \'A\',\n    controller: [\n      \'$scope\', \'$element\', \'$attrs\', function($scope, $element, $attrs) {\n        $scope.$watch($attrs.mathjaxBind, function(value) {\n          var $script = angular.element(\n            \'<script type="math/tex">\'\n          ).html(value === undefined ? \'\' : value);\n          $element.html(\'\');\n          $element.append($script);\n          MathJax.Hub.Queue([\'Reprocess\', MathJax.Hub, $element[0]]);\n        });\n      }\n    ]\n  };\n}]);\n\n// Highlights the text of an input field when it is clicked.\noppia.directive(\'selectOnClick\', [function() {\n  return {\n    restrict: \'A\',\n    link: function(scope, elm) {\n      elm.bind(\'click\', function() {\n        this.select();\n      });\n    }\n  };\n}]);\n\n// A popover that is shown when its label is hovered or clicked upon, and\n// disappears when focus moves away from its label.\noppia.directive(\'customPopover\', [\n  \'UrlInterpolationService\', \'$sce\', function(UrlInterpolationService, $sce) {\n    return {\n      restrict: \'A\',\n      templateUrl: UrlInterpolationService.getDirectiveTemplateUrl(\n        \'/custom_popover_directive.html\'),\n      link: function(scope, elt, attrs) {\n        scope.label = attrs.popoverLabel;\n        $(elt).popover({\n          trigger: \'hover\',\n          html: true,\n          content: $sce.getTrustedHtml(\n            \'<pre class="oppia-pre-wrapped-text">\' + attrs.popoverText +\n            \'</pre>\'),\n          placement: attrs.popoverPlacement\n        });\n      },\n      controller: [\'$scope\', \'$element\', function($scope, $element) {\n        $scope.isShown = false;\n\n        $element.on(\'shown.bs.popover\', function() {\n          $scope.isShown = true;\n        });\n        $element.on(\'hidden.bs.popover\', function() {\n          $scope.isShown = false;\n        });\n\n        $scope.showPopover = function() {\n          if (!$scope.isShown) {\n            $element.popover(\'show\');\n          }\n        };\n      }]\n    };\n  }\n]);\n\n// When set as an attr of an <input> element, moves focus to that element\n// when a \'focusOn\' event is broadcast.\noppia.directive(\'focusOn\', [\n  \'LABEL_FOR_CLEARING_FOCUS\', function(LABEL_FOR_CLEARING_FOCUS) {\n    return function(scope, elt, attrs) {\n      scope.$on(\'focusOn\', function(e, name) {\n        if (name === attrs.focusOn) {\n          elt[0].focus();\n        }\n\n        // If the purpose of the focus switch was to clear focus, blur the\n        // element.\n        if (name === LABEL_FOR_CLEARING_FOCUS) {\n          elt[0].blur();\n        }\n      });\n    };\n  }\n]);\n\noppia.directive(\'mobileFriendlyTooltip\', [\'$timeout\', function($timeout) {\n  return {\n    restrict: \'A\',\n    scope: true,\n    controller: [\'$scope\', \'DeviceInfoService\', function(\n        $scope, DeviceInfoService) {\n      $scope.opened = false;\n      $scope.deviceHasTouchEvents = DeviceInfoService.hasTouchEvents();\n    }],\n    link: function(scope, element) {\n      var TIME_TOOLTIP_CLOSE_DELAY_MOBILE = 1000;\n\n      if (scope.deviceHasTouchEvents) {\n        element.on(\'touchstart\', function() {\n          scope.opened = true;\n          scope.$apply();\n        });\n        element.on(\'touchend\', function() {\n          // Set time delay before tooltip close\n          $timeout(function() {\n            scope.opened = false;\n          }, TIME_TOOLTIP_CLOSE_DELAY_MOBILE);\n        });\n      } else {\n        element.on(\'mouseenter\', function() {\n          scope.opened = true;\n          scope.$apply();\n        });\n\n        element.on(\'mouseleave\', function() {\n          scope.opened = false;\n          scope.$apply();\n        });\n      }\n    }\n  };\n}]);'

blocks = {}
debug_info = ''
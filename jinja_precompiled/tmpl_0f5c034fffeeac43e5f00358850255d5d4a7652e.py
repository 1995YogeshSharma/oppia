from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/statistics_tab/StateImprovementSuggestionServiceSpec.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for statistics services.\n */\n\ndescribe(\'StateImprovementSuggestionService\', function() {\n  beforeEach(module(\'oppia\'));\n\n  // TODO(bhenning): These tests were ported from the backend tests. More tests\n  // should be added to make sure getStateImprovements() is thoroughly tested.\n\n  describe(\'getStateImprovements\', function() {\n    var IMPROVE_TYPE_INCOMPLETE = \'incomplete\';\n\n    var siss;\n    var ssof;\n\n    // A self-looping state.\n    var statesDict1 = {\n      state: {\n        content: {\n          html: \'content\',\n          audio_translations: {}\n        },\n        interaction: {\n          id: \'RuleTest\',\n          answer_groups: [{\n            outcome: {\n              dest: \'unused\',\n              feedback: [\'\'],\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }],\n          }],\n          default_outcome: {\n            dest: \'state\',\n            feedback: [],\n            param_changes: []\n          },\n          hints: []\n        },\n        param_changes: []\n      }\n    };\n\n    // A non-looping state.\n    var statesDict2 = {\n      initial: {\n        content: {\n          html: \'content\',\n          audio_translations: {}\n        },\n        interaction: {\n          id: \'RuleTest\',\n          answer_groups: [{\n            outcome: {\n              dest: \'unused\',\n              feedback: [\'\'],\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }]\n          }],\n          default_outcome: {\n            dest: \'end\',\n            feedback: [],\n            param_changes: []\n          },\n          hints: []\n        },\n        param_changes: []\n      },\n      end: {\n        content: {\n          html: \'content\',\n          audio_translations: {}\n        },\n        interaction: {\n          id: \'RuleTest\',\n          answer_groups: [{\n            outcome: {\n              dest: \'unused\',\n              feedback: [\'\'],\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }]\n          }],\n          default_outcome: {\n            dest: null,\n            feedback: [],\n            param_changes: []\n          },\n          hints: []\n        },\n        param_changes: []\n      }\n    };\n\n    // 2 states that are both self-looping\n    var statesDict3 = {\n      \'State 1\': {\n        content: {\n          html: \'content\',\n          audio_translations: {}\n        },\n        interaction: {\n          id: \'RuleTest\',\n          answer_groups: [{\n            outcome: {\n              dest: \'next state\',\n              feedback: [\'\'],\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }]\n          }],\n          default_outcome: {\n            dest: \'State 1\',\n            feedback: [],\n            param_changes: []\n          },\n          hints: []\n        },\n        param_changes: []\n      },\n      \'State 2\': {\n        content: {\n          html: \'content\',\n          audio_translations: {}\n        },\n        interaction: {\n          id: \'RuleTest\',\n          answer_groups: [{\n            outcome: {\n              dest: \'next state\',\n              feedback: [\'\'],\n              labelled_as_correct: false,\n              param_changes: [],\n              refresher_exploration_id: null\n            },\n            rule_specs: [{\n              inputs: {\n                x: 10\n              },\n              rule_type: \'Equals\'\n            }]\n          }],\n          default_outcome: {\n            dest: \'State 2\',\n            feedback: [],\n            param_changes: []\n          },\n          hints: []\n        },\n        param_changes: []\n      }\n    };\n\n    var _createState = function(destStateName) {\n      // Only a partial state definition is needed for these tests.\n      if (destStateName) {\n        return {\n          interaction: {\n            default_outcome: {\n              dest: destStateName\n            }\n          }\n        };\n      } else {\n        // Create an end state, which has no default_outcome.\n        return {\n          interaction: { }\n        };\n      }\n    };\n\n    var _createDefaultStateStats = function() {\n      return {\n        total_entry_count: 0,\n        no_submitted_answer_count: 0\n      };\n    };\n\n    var _enterStateWithoutAnswer = function(stateStats) {\n      stateStats.total_entry_count++;\n    };\n    var _answerIncorrectly = function(stateStats) {\n      stateStats.total_entry_count++;\n      stateStats.no_submitted_answer_count++;\n    };\n    var _answerDefaultOutcome = function(stateStats) {\n      stateStats.total_entry_count++;\n    };\n\n    beforeEach(inject(function($injector) {\n      siss = $injector.get(\'StateImprovementSuggestionService\');\n      ssof = $injector.get(\'StatesObjectFactory\');\n    }));\n\n    it(\'should not suggest improvements for non-default answers\', function() {\n      // Create a non-looping state for testing, similar to\n      // save_new_valid_exploration.\n      var states = ssof.createFromBackendDict(statesDict2);\n\n      // Submit an answer to an answer group rather than the default answer.\n      // The end state does not have any relevant stats, either.\n      var stateStats = {\n        initial: _createDefaultStateStats(),\n        end: _createDefaultStateStats()\n      };\n      _enterStateWithoutAnswer(stateStats.initial);\n\n      // No improvements should be suggested for this situation.\n      var improvements = siss.getStateImprovements(states, stateStats);\n      expect(improvements).toEqual([]);\n    });\n\n    it(\'should suggest incomplete improvements depending on unsubmitted \' +\n       \'answer counts\', function() {\n      // Create a looping state, similar to create_default_exploration.\n      var states = ssof.createFromBackendDict(statesDict1);\n\n      // These stats represent failing to answer something twice and hitting the\n      // default outcome once.\n      var stateStats = {\n        state: _createDefaultStateStats(),\n      };\n      _answerIncorrectly(stateStats.state);\n      _answerIncorrectly(stateStats.state);\n      _answerDefaultOutcome(stateStats.state);\n\n      // The result should be an improvement recommendation due to the state\n      // being potentially confusing.\n      var improvements = siss.getStateImprovements(states, stateStats);\n      expect(improvements).toEqual([{\n        rank: 2,\n        stateName: \'state\',\n        type: IMPROVE_TYPE_INCOMPLETE\n      }]);\n    });\n  });\n});'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/topic_editor/TopicEditorStateService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service to maintain the state of a single topic shared\n * throughout the topic editor. This service provides functionality for\n * retrieving the topic, saving it, and listening for changes.\n */\n\noppia.constant(\'EVENT_TOPIC_INITIALIZED\', \'topicInitialized\');\noppia.constant(\'EVENT_TOPIC_REINITIALIZED\', \'topicReinitialized\');\noppia.constant(\'EVENT_SUBTOPIC_PAGE_LOADED\', \'subtopicPageLoaded\');\noppia.constant(\n  \'EVENT_STORY_SUMMARIES_INITIALIZED\', \'storySummariesInitialized\');\noppia.constant(\n  \'EVENT_QUESTION_SUMMARIES_INITIALIZED\', \'questionSummariesInitialized\');\n\noppia.factory(\'TopicEditorStateService\', [\n  \'$rootScope\', \'AlertsService\', \'TopicObjectFactory\',\n  \'TopicRightsObjectFactory\', \'SubtopicPageObjectFactory\',\n  \'TopicRightsBackendApiService\', \'UndoRedoService\',\n  \'EditableTopicBackendApiService\', \'EditableStoryBackendApiService\',\n  \'EVENT_TOPIC_INITIALIZED\', \'EVENT_TOPIC_REINITIALIZED\',\n  \'EVENT_SUBTOPIC_PAGE_LOADED\', \'EVENT_STORY_SUMMARIES_INITIALIZED\',\n  \'EVENT_QUESTION_SUMMARIES_INITIALIZED\', function(\n      $rootScope, AlertsService, TopicObjectFactory,\n      TopicRightsObjectFactory, SubtopicPageObjectFactory,\n      TopicRightsBackendApiService, UndoRedoService,\n      EditableTopicBackendApiService, EditableStoryBackendApiService,\n      EVENT_TOPIC_INITIALIZED, EVENT_TOPIC_REINITIALIZED,\n      EVENT_SUBTOPIC_PAGE_LOADED, EVENT_STORY_SUMMARIES_INITIALIZED,\n      EVENT_QUESTION_SUMMARIES_INITIALIZED) {\n    var _topic = TopicObjectFactory.createInterstitialTopic();\n    var _topicRights = TopicRightsObjectFactory.createInterstitialRights();\n    // The array that caches all the subtopic pages loaded by the user.\n    var _cachedSubtopicPages = [];\n    // The array that stores all the ids of the subtopic pages that were not\n    // loaded from the backend i.e those that correspond to newly created\n    // subtopics (and not loaded from the backend).\n    var _newSubtopicPageIds = [];\n    var _subtopicPage =\n      SubtopicPageObjectFactory.createInterstitialSubtopicPage();\n    var _topicIsInitialized = false;\n    var _topicIsLoading = false;\n    var _topicIsBeingSaved = false;\n    var _canonicalStorySummaries = [];\n    var _questionSummaries = [];\n\n    var _getSubtopicPageId = function(topicId, subtopicId) {\n      return topicId + \'-\' + subtopicId.toString();\n    };\n    var _getSubtopicIdFromSubtopicPageId = function(subtopicPageId) {\n      // The subtopic page id consists of the topic id of length 12, a hyphen\n      // and a subtopic id (which is a number).\n      return parseInt(subtopicPageId.slice(13));\n    };\n    var _setTopic = function(topic) {\n      _topic.copyFromTopic(topic);\n      // Reset the subtopic pages list after setting new topic.\n      _cachedSubtopicPages.length = 0;\n      if (_topicIsInitialized) {\n        $rootScope.$broadcast(EVENT_TOPIC_REINITIALIZED);\n      } else {\n        $rootScope.$broadcast(EVENT_TOPIC_INITIALIZED);\n        _topicIsInitialized = true;\n      }\n    };\n    var _getSubtopicPageIndex = function(subtopicPageId) {\n      for (var i = 0; i < _cachedSubtopicPages.length; i++) {\n        if (_cachedSubtopicPages[i].getId() === subtopicPageId) {\n          return i;\n        }\n      }\n      return null;\n    };\n    var _updateTopic = function(newBackendTopicDict, skillIdToDescriptionDict) {\n      _setTopic(\n        TopicObjectFactory.create(\n          newBackendTopicDict, skillIdToDescriptionDict));\n    };\n    var _setSubtopicPage = function(subtopicPage) {\n      _subtopicPage.copyFromSubtopicPage(subtopicPage);\n      _cachedSubtopicPages.push(angular.copy(subtopicPage));\n      $rootScope.$broadcast(EVENT_SUBTOPIC_PAGE_LOADED);\n    };\n    var _updateSubtopicPage = function(newBackendSubtopicPageObject) {\n      _setSubtopicPage(SubtopicPageObjectFactory.createFromBackendDict(\n        newBackendSubtopicPageObject));\n    };\n    var _setTopicRights = function(topicRights) {\n      _topicRights.copyFromTopicRights(topicRights);\n    };\n    var _updateTopicRights = function(newBackendTopicRightsObject) {\n      _setTopicRights(TopicRightsObjectFactory.createFromBackendDict(\n        newBackendTopicRightsObject));\n    };\n    var _setCanonicalStorySummaries = function(canonicalStorySummaries) {\n      _canonicalStorySummaries = angular.copy(canonicalStorySummaries);\n      $rootScope.$broadcast(EVENT_STORY_SUMMARIES_INITIALIZED);\n    };\n    var _setQuestionSummaries = function(questionSummaries) {\n      _questionSummaries = angular.copy(questionSummaries);\n      $rootScope.$broadcast(EVENT_QUESTION_SUMMARIES_INITIALIZED);\n    };\n\n    return {\n      /**\n       * Loads, or reloads, the topic stored by this service given a\n       * specified topic ID. See setTopic() for more information on\n       * additional behavior of this function.\n       */\n      loadTopic: function(topicId) {\n        _topicIsLoading = true;\n        EditableTopicBackendApiService.fetchTopic(\n          topicId).then(\n          function(newBackendTopicObject) {\n            _updateTopic(\n              newBackendTopicObject.topicDict,\n              newBackendTopicObject.skillIdToDescriptionDict\n            );\n            EditableTopicBackendApiService.fetchStories(topicId).then(\n              function(canonicalStorySummaries) {\n                _setCanonicalStorySummaries(canonicalStorySummaries);\n              });\n            EditableTopicBackendApiService.fetchQuestions(topicId).then(\n              function(questionSummaries) {\n                _setQuestionSummaries(questionSummaries);\n              });\n          },\n          function(error) {\n            AlertsService.addWarning(\n              error || \'There was an error when loading the topic.\');\n            _topicIsLoading = false;\n          });\n        TopicRightsBackendApiService.fetchTopicRights(\n          topicId).then(function(newBackendTopicRightsObject) {\n          _updateTopicRights(newBackendTopicRightsObject);\n          _topicIsLoading = false;\n        }, function(error) {\n          AlertsService.addWarning(\n            error ||\n            \'There was an error when loading the topic rights.\');\n          _topicIsLoading = false;\n        });\n      },\n\n      /**\n       * Loads, or reloads, the subtopic page stored by this service given a\n       * specified topic ID and subtopic ID.\n       */\n      loadSubtopicPage: function(topicId, subtopicId) {\n        var subtopicPageId = _getSubtopicPageId(topicId, subtopicId);\n        if (_getSubtopicPageIndex(subtopicPageId) !== null) {\n          _subtopicPage = angular.copy(\n            _cachedSubtopicPages[_getSubtopicPageIndex(subtopicPageId)]);\n          $rootScope.$broadcast(EVENT_SUBTOPIC_PAGE_LOADED);\n          return;\n        }\n        EditableTopicBackendApiService.fetchSubtopicPage(\n          topicId, subtopicId).then(\n          function(newBackendSubtopicPageObject) {\n            _updateSubtopicPage(newBackendSubtopicPageObject);\n          },\n          function(error) {\n            AlertsService.addWarning(\n              error || \'There was an error when loading the topic.\');\n          });\n      },\n\n      /**\n       * Returns whether this service is currently attempting to load the\n       * topic maintained by this service.\n       */\n      isLoadingTopic: function() {\n        return _topicIsLoading;\n      },\n\n      /**\n       * Returns whether a topic has yet been loaded using either\n       * loadTopic() or setTopic().\n       */\n      hasLoadedTopic: function() {\n        return _topicIsInitialized;\n      },\n\n      /**\n       * Returns the current topic to be shared among the topic\n       * editor. Please note any changes to this topic will be propogated\n       * to all bindings to it. This topic object will be retained for the\n       * lifetime of the editor. This function never returns null, though it may\n       * return an empty topic object if the topic has not yet been\n       * loaded for this editor instance.\n       */\n      getTopic: function() {\n        return _topic;\n      },\n\n      getCanonicalStorySummaries: function() {\n        return _canonicalStorySummaries;\n      },\n\n      getQuestionSummaries: function() {\n        return _questionSummaries;\n      },\n\n      fetchQuestionSummaries: function(topicId, callback) {\n        EditableTopicBackendApiService.fetchQuestions(topicId).then(\n          function(questionSummaries) {\n            _setQuestionSummaries(questionSummaries);\n            callback();\n          });\n      },\n\n      /**\n       * Returns the current subtopic page to be shared among the topic\n       * editor. Please note any changes to this subtopic page will be\n       * propogated to all bindings to it. This subtopic page object will be\n       * retained for the lifetime of the editor. This function never returns\n       * null, though it may return an empty subtopic page object if the topic\n       * has not yet been loaded for this editor instance.\n       */\n      getSubtopicPage: function() {\n        return _subtopicPage;\n      },\n\n      getCachedSubtopicPages: function() {\n        return _cachedSubtopicPages;\n      },\n\n      /**\n       * Returns the current topic rights to be shared among the topic\n       * editor. Please note any changes to this topic rights will be\n       * propogated to all bindings to it. This topic rights object will\n       * be retained for the lifetime of the editor. This function never returns\n       * null, though it may return an empty topic rights object if the\n       * topic rights has not yet been loaded for this editor instance.\n       */\n      getTopicRights: function() {\n        return _topicRights;\n      },\n\n\n      /**\n       * Sets the topic stored within this service, propogating changes to\n       * all bindings to the topic returned by getTopic(). The first\n       * time this is called it will fire a global event based on the\n       * EVENT_TOPIC_INITIALIZED constant. All subsequent\n       * calls will similarly fire a EVENT_TOPIC_REINITIALIZED event.\n       */\n      setTopic: function(topic) {\n        _setTopic(topic);\n      },\n\n      /**\n       * Sets the updated subtopic page object in the correct position in the\n       * _cachedSubtopicPages list.\n       */\n      setSubtopicPage: function(subtopicPage) {\n        if (_getSubtopicPageIndex(subtopicPage.getId()) !== null) {\n          _cachedSubtopicPages[_getSubtopicPageIndex(subtopicPage.getId())] =\n            angular.copy(subtopicPage);\n          _subtopicPage.copyFromSubtopicPage(subtopicPage);\n        } else {\n          _setSubtopicPage(subtopicPage);\n          _newSubtopicPageIds.push(subtopicPage.getId());\n        }\n      },\n\n      deleteSubtopicPage: function(topicId, subtopicId) {\n        var subtopicPageId = _getSubtopicPageId(topicId, subtopicId);\n        var index = _getSubtopicPageIndex(subtopicPageId);\n        var newIndex = _newSubtopicPageIds.indexOf(subtopicPageId);\n        // If index is null, that means the corresponding subtopic page was\n        // never loaded from the backend and not that the subtopic page doesn\'t\n        // exist at all. So, not required to throw an error here.\n        // Also, since newSubtopicPageIds will only have the ids of a subset of\n        // the pages in the _subtopicPages array, the former need not be edited\n        // either, in this case.\n        if (index === null) {\n          if (newIndex === -1) {\n            return;\n          } else {\n            throw Error(\'Invalid subtopic page.\');\n          }\n        }\n        _cachedSubtopicPages.splice(index, 1);\n        // If the deleted subtopic page corresponded to a newly created\n        // subtopic, then the \'subtopicId\' part of the id of all subsequent\n        // subtopic pages should be decremented to make it in sync with the\n        // their corresponding subtopic ids.\n        if (newIndex !== -1) {\n          _newSubtopicPageIds.splice(newIndex, 1);\n          for (var i = 0; i < _cachedSubtopicPages.length; i++) {\n            var newSubtopicId = _getSubtopicIdFromSubtopicPageId(\n              _cachedSubtopicPages[i].getId());\n            if (newSubtopicId > subtopicId) {\n              newSubtopicId--;\n              _cachedSubtopicPages[i].setId(\n                _getSubtopicPageId(topicId, newSubtopicId));\n            }\n          }\n          for (var i = 0; i < _newSubtopicPageIds.length; i++) {\n            var newSubtopicId = _getSubtopicIdFromSubtopicPageId(\n              _newSubtopicPageIds[i]);\n            if (newSubtopicId > subtopicId) {\n              newSubtopicId--;\n              _newSubtopicPageIds[i] = _getSubtopicPageId(\n                topicId, newSubtopicId);\n            }\n          }\n        }\n      },\n\n      /**\n       * Sets the topic rights stored within this service, propogating\n       * changes to all bindings to the topic returned by\n       * getTopicRights().\n       */\n      setTopicRights: function(topicRights) {\n        _setTopicRights(topicRights);\n      },\n\n\n      /**\n       * Attempts to save the current topic given a commit message. This\n       * function cannot be called until after a topic has been initialized\n       * in this service. Returns false if a save is not performed due to no\n       * changes pending, or true if otherwise. This function, upon success,\n       * will clear the UndoRedoService of pending changes. This function also\n       * shares behavior with setTopic(), when it succeeds.\n       */\n      saveTopic: function(commitMessage, successCallback) {\n        if (!_topicIsInitialized) {\n          AlertsService.fatalWarning(\n            \'Cannot save a topic before one is loaded.\');\n        }\n\n        // Don\'t attempt to save the topic if there are no changes pending.\n        if (!UndoRedoService.hasChanges()) {\n          return false;\n        }\n        _topicIsBeingSaved = true;\n        EditableTopicBackendApiService.updateTopic(\n          _topic.getId(), _topic.getVersion(),\n          commitMessage, UndoRedoService.getCommittableChangeList()).then(\n          function(topicBackendObject) {\n            _updateTopic(\n              topicBackendObject.topicDict,\n              topicBackendObject.skillIdToDescriptionDict\n            );\n            var changeList = UndoRedoService.getCommittableChangeList();\n            for (var i = 0; i < changeList.length; i++) {\n              if (changeList[i].property_name === \'canonical_story_ids\') {\n                if (changeList[i].new_value.length ===\n                    changeList[i].old_value.length - 1) {\n                  deletedStoryId = changeList[i].old_value.filter(\n                    function(storyId) {\n                      return changeList[i].new_value.indexOf(storyId) === -1;\n                    }\n                  )[0];\n                  EditableStoryBackendApiService.deleteStory(\n                    _topic.getId(), deletedStoryId);\n                } else if (\n                  changeList[i].new_value.length <\n                  changeList[i].old_value.length) {\n                  throw Error(\n                    \'More than one story should not be deleted at a time.\');\n                }\n              }\n            }\n            UndoRedoService.clearChanges();\n            _topicIsBeingSaved = false;\n            if (successCallback) {\n              successCallback();\n            }\n          }, function(error) {\n            AlertsService.addWarning(\n              error || \'There was an error when saving the topic.\');\n            _topicIsBeingSaved = false;\n          });\n        return true;\n      },\n\n      /**\n       * Returns whether this service is currently attempting to save the\n       * topic maintained by this service.\n       */\n      isSavingTopic: function() {\n        return _topicIsBeingSaved;\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
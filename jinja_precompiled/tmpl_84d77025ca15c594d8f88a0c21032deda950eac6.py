from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/ImagePreloaderService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2017 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service to preload image into AssetsBackendApiService\'s cache.\n */\n\noppia.factory(\'ImagePreloaderService\', [\n  \'$q\', \'$uibModal\', \'ContextService\', \'AssetsBackendApiService\',\n  \'UrlInterpolationService\', \'ComputeGraphService\',\n  \'ExtractImageFilenamesFromStateService\',\n  function($q, $uibModal, ContextService, AssetsBackendApiService,\n      UrlInterpolationService, ComputeGraphService,\n      ExtractImageFilenamesFromStateService) {\n    var MAX_NUM_IMAGE_FILES_TO_DOWNLOAD_SIMULTANEOUSLY = 3;\n\n    var _filenamesOfImageCurrentlyDownloading = [];\n    var _filenamesOfImageToBeDownloaded = [];\n    var _filenamesOfImageFailedToDownload = [];\n    var _exploration = null;\n    var _hasImagePreloaderServiceStarted = false;\n    // imageLoadedCallback is an object of objects (identified by the filenames\n    // which are being downloaded at the time they are required by the\n    // directive).The object contains the resolve method of the promise\n    // attached with getInImageUrl method.\n    var _imageLoadedCallback = {};\n    var _hasImagePreloaderServiceStarted = false;\n\n    var _init = function(exploration) {\n      _exploration = exploration;\n      _states = exploration.states;\n      _hasImagePreloaderServiceStarted = true;\n    };\n\n    /**\n     * Gets the Url for the image file.\n     * @param {string} filename - Filename of the image whose Url is to be\n     *                            created.\n     * @param {function} onLoadCallback - Function that is called when the\n     *                                    Url of the loaded image is obtained.\n     */\n    var _getImageUrl = function(filename, onLoadCallback, onErrorCallback) {\n      AssetsBackendApiService.loadImage(\n        ContextService.getExplorationId(), filename)\n        .then(function(loadedImageFile) {\n          if (_isInFailedDownload(loadedImageFile.filename)) {\n            _removeFromFailedDownload(loadedImageFile.filename);\n          }\n          var objectUrl = URL.createObjectURL(loadedImageFile.data);\n          onLoadCallback(objectUrl);\n        }, function(filename) {\n          onErrorCallback();\n        });\n    };\n\n    /**\n     * Checks if the given filename is in _filenamesOfImageFailedToDownload or\n     * not.\n     * @param {string} filename - The filename of the image which is to be\n     *                            removed from the\n     *                            _filenamesOfImageFailedToDownload array.\n     */\n    var _isInFailedDownload = function(filename) {\n      return _filenamesOfImageFailedToDownload.indexOf(filename) >= 0;\n    };\n\n    /**\n     * Removes the given filename from the _filenamesOfImageFailedToDownload.\n     * @param {string} filename - The filename of the file which is to be\n     *                            removed from the\n     *                            _filenamesOfImageFailedToDownload array.\n     */\n    var _removeFromFailedDownload = function(filename) {\n      var index = _filenamesOfImageFailedToDownload.indexOf(filename);\n      _filenamesOfImageFailedToDownload.splice(index, 1);\n    };\n\n    /**\n     * Gets image files names in Bfs order from the state.\n     * @param {string} sourceStateName - The name of the starting state\n     *                                   from which the filenames should\n     *                                   be obtained.\n     */\n    var _getImageFilenamesInBfsOrder = function(sourceStateName) {\n      var stateNamesInBfsOrder = (\n        ComputeGraphService.computeBfsTraversalOfStates(\n          _exploration.getInitialState().name,\n          _exploration.getStates(),\n          sourceStateName));\n      var imageFilenames = [];\n\n      stateNamesInBfsOrder.forEach(function(stateName) {\n        var state = _states.getState(stateName);\n        ExtractImageFilenamesFromStateService.getImageFilenamesInState(state)\n          .forEach(function(filename) {\n            imageFilenames.push(filename);\n          });\n      });\n      return imageFilenames;\n    };\n\n    /**\n     * Removes the filename from the _filenamesOfImageCurrentlyDownloading and\n     * initiates the loading of the next image file.\n     * @param {string} filename - The filename which is to be removed from the\n     *                            _filenamesOfImageCurrentlyDownloading array.\n     */\n    var _removeCurrentAndLoadNextImage = function(filename) {\n      _filenamesOfImageCurrentlyDownloading = (\n        _filenamesOfImageCurrentlyDownloading.filter(\n          function(imageFilename) {\n            return filename !== imageFilename;\n          })\n      );\n      if (_filenamesOfImageToBeDownloaded.length > 0) {\n        var nextImageFilename = _filenamesOfImageToBeDownloaded.shift();\n        _filenamesOfImageCurrentlyDownloading.push(nextImageFilename);\n        _loadImage(nextImageFilename);\n      }\n    };\n\n    /**\n     * Handles the loading of the image file.\n     * @param {string} imageFilename - The filename of the image to be loaded.\n     */\n    var _loadImage = function(imageFilename) {\n      AssetsBackendApiService.loadImage(\n        ContextService.getExplorationId(), imageFilename)\n        .then(function(loadedImage) {\n          _removeCurrentAndLoadNextImage(loadedImage.filename);\n          if (_imageLoadedCallback[loadedImage.filename]) {\n            var onLoadImageResolve = (\n              (_imageLoadedCallback[loadedImage.filename]).resolveMethod);\n            var objectUrl = URL.createObjectURL(loadedImage.data);\n            onLoadImageResolve(objectUrl);\n            _imageLoadedCallback[loadedImage.filename] = null;\n          }\n        }, function(filename) {\n          if (_imageLoadedCallback[filename]) {\n            var onFailedDownload = (\n              (_imageLoadedCallback[filename]).rejectMethod);\n            onFailedDownload();\n            _imageLoadedCallback[filename] = null;\n          }\n          _filenamesOfImageFailedToDownload.push(filename);\n          _removeCurrentAndLoadNextImage(filename);\n        });\n    };\n\n    /**\n     * Initiates the image preloader beginning from the sourceStateName.\n     * @param {string} sourceStateName - The name of the state from which\n     *                                   preloader should start.\n     */\n    var _kickOffImagePreloader = function(sourceStateName) {\n      _filenamesOfImageToBeDownloaded = (\n        _getImageFilenamesInBfsOrder(sourceStateName));\n      var imageFilesInGivenState = ExtractImageFilenamesFromStateService\n        .getImageFilenamesInState(_states.getState(sourceStateName));\n      _filenamesOfImageFailedToDownload = _filenamesOfImageFailedToDownload\n        .filter(function(filename) {\n          return imageFilesInGivenState.indexOf(filename) === -1;\n        });\n      while (_filenamesOfImageCurrentlyDownloading.length <\n          MAX_NUM_IMAGE_FILES_TO_DOWNLOAD_SIMULTANEOUSLY &&\n          _filenamesOfImageToBeDownloaded.length > 0) {\n        var imageFilename = _filenamesOfImageToBeDownloaded.shift();\n        _filenamesOfImageCurrentlyDownloading.push(imageFilename);\n        _loadImage(imageFilename);\n      }\n    };\n\n    /**\n     * Cancels the preloading of the images that are being downloaded.\n     */\n    var _cancelPreloading = function() {\n      AssetsBackendApiService.abortAllCurrentImageDownloads();\n      _filenamesOfImageCurrentlyDownloading = [];\n    };\n\n    /**\n     * When the state changes, it decides whether to restart the preloader\n     * starting from the \'stateName\' state or not.\n     * @param {string} stateName - The name of the state the user shifts to.\n     */\n    var _onStateChange = function(stateName) {\n      if (stateName !== _exploration.getInitialState().name) {\n        _imageLoadedCallback = {};\n        var imageFilenamesInState = [];\n        var noOfImageFilesCurrentlyDownloading = 0;\n        var noOfImagesNeitherInCacheNorDownloading = 0;\n\n        var state = _states.getState(stateName);\n        imageFilenamesInState = (\n          ExtractImageFilenamesFromStateService\n            .getImageFilenamesInState(state));\n        imageFilenamesInState.forEach(function(filename) {\n          var isFileCurrentlyDownloading = (\n            _filenamesOfImageCurrentlyDownloading.indexOf(filename) >= 0\n          );\n          if (!AssetsBackendApiService.isCached(filename) &&\n              !isFileCurrentlyDownloading) {\n            noOfImagesNeitherInCacheNorDownloading += 1;\n          }\n          if (isFileCurrentlyDownloading) {\n            noOfImageFilesCurrentlyDownloading += 1;\n          }\n        });\n        if (noOfImagesNeitherInCacheNorDownloading > 0 &&\n            noOfImageFilesCurrentlyDownloading <= 1) {\n          _cancelPreloading();\n          _kickOffImagePreloader(stateName);\n        }\n      }\n    };\n\n    /**\n    * Gets the dimensions of the images from the filename provided.\n    * @param {string} filename - The string from which the dimensions of the\n    *                           images should be extracted.\n    */\n    var getDimensionsOfImage = function(filename) {\n      var dimensionsRegex = RegExp(\n        \'[^/]+_height_([0-9]+)_width_([0-9]+)\\.(png|jpeg|jpg|gif)$\', \'g\');\n      imageDimensions = dimensionsRegex.exec(filename);\n      if (imageDimensions) {\n        dimensions = {\n          height: Number(imageDimensions[1]),\n          width: Number(imageDimensions[2])\n        };\n        return dimensions;\n      } else {\n        throw new Error(\n          \'The image name is invalid, it does not contain dimensions.\');\n      }\n    };\n\n    return {\n      init: _init,\n      kickOffImagePreloader: _kickOffImagePreloader,\n      getDimensionsOfImage: getDimensionsOfImage,\n      onStateChange: _onStateChange,\n      isInFailedDownload: _isInFailedDownload,\n      isLoadingImageFile: function(filename) {\n        return _filenamesOfImageCurrentlyDownloading.indexOf(filename) !== -1;\n      },\n      restartImagePreloader: function(sourceStateName) {\n        _cancelPreloading();\n        _kickOffImagePreloader(sourceStateName);\n      },\n      getFilenamesOfImageCurrentlyDownloading: function() {\n        return _filenamesOfImageCurrentlyDownloading;\n      },\n      getImageUrl: function(filename) {\n        return $q(function(resolve, reject){\n          if (AssetsBackendApiService.isCached(filename) ||\n              _isInFailedDownload(filename)) {\n            _getImageUrl(filename, resolve, reject);\n          } else {\n            _imageLoadedCallback[filename] = {\n              resolveMethod: resolve,\n              rejectMethod: reject\n            };\n          }\n        });\n      },\n      inExplorationPlayer: function() {\n        return _hasImagePreloaderServiceStarted;\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/feedback_tab/ThreadDataService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for getting thread data from the backend for the\n * feedback tab of the exploration editor.\n */\n\noppia.factory(\'ThreadDataService\', [\n  \'$http\', \'$q\', \'ExplorationDataService\', \'AlertsService\',\n  \'ACTION_ACCEPT_SUGGESTION\',\n  function(\n      $http, $q, ExplorationDataService, AlertsService,\n      ACTION_ACCEPT_SUGGESTION) {\n    var _expId = ExplorationDataService.explorationId;\n    var _FEEDBACK_STATS_HANDLER_URL = \'/feedbackstatshandler/\' + _expId;\n    var _THREAD_LIST_HANDLER_URL = \'/threadlisthandler/\' + _expId;\n    var _SUGGESTION_LIST_HANDLER_URL = \'/suggestionlisthandler/\' + _expId;\n    var _SUGGESTION_ACTION_HANDLER_URL = \'/suggestionactionhandler/\' +\n      _expId + \'/\';\n    var _THREAD_HANDLER_PREFIX = \'/threadhandler/\' + _expId + \'/\';\n    var _FEEDBACK_THREAD_VIEW_EVENT_URL = \'/feedbackhandler/thread_view_event\';\n    var _THREAD_STATUS_OPEN = \'open\';\n\n    // All the threads for this exploration. This is a list whose entries are\n    // objects, each representing threads. The \'messages\' key of this object\n    // is updated lazily.\n    var _data = {\n      feedbackThreads: [],\n      suggestionThreads: []\n    };\n\n    // Number of open threads that need action\n    var _openThreadsCount = 0;\n\n    var _fetchThreads = function(successCallback) {\n      var fPromise = $http.get(_THREAD_LIST_HANDLER_URL);\n      var sPromise = $http.get(_SUGGESTION_LIST_HANDLER_URL, {\n        params: {\n          list_type: \'all\',\n          has_suggestion: true\n        }\n      });\n\n      $q.all([fPromise, sPromise]).then(function(res) {\n        _data.feedbackThreads = res[0].data.threads;\n        _data.suggestionThreads = res[1].data.threads;\n        if (successCallback) {\n          successCallback();\n        }\n      });\n    };\n\n    var _fetchMessages = function(threadId) {\n      $http.get(_THREAD_HANDLER_PREFIX + threadId).then(function(response) {\n        var allThreads = _data.feedbackThreads.concat(_data.suggestionThreads);\n        for (var i = 0; i < allThreads.length; i++) {\n          if (allThreads[i].thread_id === threadId) {\n            allThreads[i].messages = response.data.messages;\n            allThreads[i].suggestion = response.data.suggestion;\n            break;\n          }\n        }\n      });\n    };\n\n    return {\n      data: _data,\n      fetchThreads: function(successCallback) {\n        _fetchThreads(successCallback);\n      },\n      fetchMessages: function(threadId) {\n        _fetchMessages(threadId);\n      },\n      fetchFeedbackStats: function() {\n        $http.get(_FEEDBACK_STATS_HANDLER_URL).then(function(response) {\n          _openThreadsCount = response.data.num_open_threads;\n        });\n      },\n      getOpenThreadsCount: function() {\n        return _openThreadsCount;\n      },\n      createNewThread: function(newSubject, newText, successCallback) {\n        _openThreadsCount += 1;\n        $http.post(_THREAD_LIST_HANDLER_URL, {\n          state_name: null,\n          subject: newSubject,\n          text: newText\n        }).then(function() {\n          _fetchThreads();\n          if (successCallback) {\n            successCallback();\n          }\n        }, function() {\n          _openThreadsCount -= 1;\n          AlertsService.addWarning(\'Error creating new thread.\');\n        });\n      },\n      markThreadAsSeen: function(threadId) {\n        var requestUrl = (\n          _FEEDBACK_THREAD_VIEW_EVENT_URL + \'/\' + _expId);\n        $http.post(requestUrl, {\n          thread_id: threadId\n        });\n      },\n      addNewMessage: function(\n          threadId, newMessage, newStatus, successCallback, errorCallback) {\n        var url = _THREAD_HANDLER_PREFIX + threadId;\n        var allThreads = _data.feedbackThreads.concat(_data.suggestionThreads);\n        var thread = null;\n\n        for (var i = 0; i < allThreads.length; i++) {\n          if (allThreads[i].thread_id === threadId) {\n            thread = allThreads[i];\n            break;\n          }\n        }\n\n        // This is only set if the status has changed.\n        // Assume a successful POST, in case of an error\n        // the changes are reverted in the error callback.\n        var updatedStatus = null;\n        var oldStatus = thread.status;\n        if (newStatus !== oldStatus) {\n          updatedStatus = newStatus;\n          if (oldStatus === _THREAD_STATUS_OPEN) {\n            _openThreadsCount -= 1;\n          } else if (newStatus === _THREAD_STATUS_OPEN) {\n            _openThreadsCount += 1;\n          }\n          thread.status = updatedStatus;\n        }\n\n        var payload = {\n          updated_status: updatedStatus,\n          updated_subject: null,\n          text: newMessage\n        };\n\n        $http.post(url, payload).then(function() {\n          _fetchMessages(threadId);\n\n          if (successCallback) {\n            successCallback();\n          }\n        }, function() {\n          // Revert changes\n          if (newStatus !== oldStatus) {\n            if (oldStatus === _THREAD_STATUS_OPEN) {\n              _openThreadsCount += 1;\n            } else if (newStatus === _THREAD_STATUS_OPEN) {\n              _openThreadsCount -= 1;\n            }\n            thread.status = oldStatus;\n          }\n          if (errorCallback) {\n            errorCallback();\n          }\n        });\n      },\n      resolveSuggestion: function(\n          threadId, action, commitMsg, audioUpdateRequired, onSuccess,\n          onFailure) {\n        var payload = {\n          action: action\n        };\n        if (action === ACTION_ACCEPT_SUGGESTION) {\n          payload.commit_message = commitMsg;\n          payload.audio_update_required = audioUpdateRequired;\n        }\n        _openThreadsCount -= 1;\n        $http.put(_SUGGESTION_ACTION_HANDLER_URL + threadId, payload).then(\n          onSuccess, function() {\n            _openThreadsCount += 1;\n            if (onFailure) {\n              onFailure();\n            }\n          }\n        );\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
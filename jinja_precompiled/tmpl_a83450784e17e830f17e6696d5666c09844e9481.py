from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/feedback_tab/ThreadDataService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for getting thread data from the backend for the\n * feedback tab of the exploration editor.\n */\n\noppia.factory(\'ThreadDataService\', [\n  \'$http\', \'$log\', \'$q\', \'ExplorationDataService\', \'AlertsService\',\n  \'FeedbackThreadObjectFactory\', \'SuggestionObjectFactory\',\n  \'SuggestionThreadObjectFactory\', \'ACTION_ACCEPT_SUGGESTION\',\n  function(\n      $http, $log, $q, ExplorationDataService, AlertsService,\n      FeedbackThreadObjectFactory, SuggestionObjectFactory,\n      SuggestionThreadObjectFactory, ACTION_ACCEPT_SUGGESTION) {\n    var _expId = ExplorationDataService.explorationId;\n    var _FEEDBACK_STATS_HANDLER_URL = \'/feedbackstatshandler/\' + _expId;\n    var _THREAD_LIST_HANDLER_URL = \'/threadlisthandler/\' + _expId;\n    var _SUGGESTION_LIST_HANDLER_URL = \'/generalsuggestionlisthandler\';\n    var _SUGGESTION_ACTION_HANDLER_URL = \'/generalsuggestionactionhandler/\' +\n        \'exploration/\' + _expId + \'/\';\n    var _THREAD_HANDLER_PREFIX = \'/threadhandler/\';\n    var _FEEDBACK_THREAD_VIEW_EVENT_URL = \'/feedbackhandler/thread_view_event\';\n    var _THREAD_STATUS_OPEN = \'open\';\n\n    // All the threads for this exploration. This is a list whose entries are\n    // objects, each representing threads. The \'messages\' key of this object\n    // is updated lazily.\n    var _data = {\n      feedbackThreads: [],\n      suggestionThreads: []\n    };\n\n    // Number of open threads that need action\n    var _openThreadsCount = 0;\n\n    var _fetchThreads = function(successCallback) {\n      var threadsPromise = $http.get(_THREAD_LIST_HANDLER_URL);\n      params = {\n        target_type: \'exploration\',\n        target_id: _expId\n      };\n      var suggestionsPromise = $http.get(_SUGGESTION_LIST_HANDLER_URL, {\n        params: params\n      });\n\n      $q.all([threadsPromise, suggestionsPromise]).then(function(res) {\n        _data.feedbackThreads = res[0].data.feedback_thread_dicts.map(\n          FeedbackThreadObjectFactory.createFromBackendDict);\n\n        _data.suggestionThreads = [];\n        var suggestionThreads = res[0].data.suggestion_thread_dicts;\n        if (suggestionThreads.length !== res[1].data.suggestions.length) {\n          $log.error(\'Number of suggestion threads doesn\\\'t match number of\' +\n                     \'suggestion objects\');\n        }\n        for (var i = 0; i < suggestionThreads.length; i++) {\n          for (var j = 0; j < res[1].data.suggestions.length; j++) {\n            var suggestion = (\n              SuggestionObjectFactory.createFromBackendDict(\n                res[1].data.suggestions[j]));\n            if (suggestionThreads[i].thread_id ===\n                suggestion.getThreadId()) {\n              var suggestionThread = (\n                SuggestionThreadObjectFactory.createFromBackendDicts(\n                  suggestionThreads[i], res[1].data.suggestions[j]));\n              _data.suggestionThreads.push(suggestionThread);\n              break;\n            }\n          }\n        }\n        if (successCallback) {\n          successCallback();\n        }\n      });\n    };\n\n    var _fetchMessages = function(threadId) {\n      $http.get(_THREAD_HANDLER_PREFIX + threadId).then(function(response) {\n        var allThreads = _data.feedbackThreads.concat(_data.suggestionThreads);\n        for (var i = 0; i < allThreads.length; i++) {\n          if (allThreads[i].threadId === threadId) {\n            allThreads[i].setMessages(response.data.messages);\n            break;\n          }\n        }\n      });\n    };\n\n    return {\n      data: _data,\n      fetchThreads: function(successCallback) {\n        _fetchThreads(successCallback);\n      },\n      fetchMessages: function(threadId) {\n        _fetchMessages(threadId);\n      },\n      fetchFeedbackStats: function() {\n        $http.get(_FEEDBACK_STATS_HANDLER_URL).then(function(response) {\n          _openThreadsCount = response.data.num_open_threads;\n        });\n      },\n      getOpenThreadsCount: function() {\n        return _openThreadsCount;\n      },\n      createNewThread: function(newSubject, newText, successCallback) {\n        _openThreadsCount += 1;\n        $http.post(_THREAD_LIST_HANDLER_URL, {\n          state_name: null,\n          subject: newSubject,\n          text: newText\n        }).then(function() {\n          _fetchThreads();\n          if (successCallback) {\n            successCallback();\n          }\n        }, function() {\n          _openThreadsCount -= 1;\n          AlertsService.addWarning(\'Error creating new thread.\');\n        });\n      },\n      markThreadAsSeen: function(threadId) {\n        var requestUrl = _FEEDBACK_THREAD_VIEW_EVENT_URL + \'/\' + threadId;\n        $http.post(requestUrl, {\n          thread_id: threadId\n        });\n      },\n      addNewMessage: function(\n          threadId, newMessage, newStatus, successCallback, errorCallback) {\n        var url = _THREAD_HANDLER_PREFIX + threadId;\n        var allThreads = _data.feedbackThreads.concat(_data.suggestionThreads);\n        var thread = null;\n\n        for (var i = 0; i < allThreads.length; i++) {\n          if (allThreads[i].threadId === threadId) {\n            thread = allThreads[i];\n            break;\n          }\n        }\n\n        // This is only set if the status has changed.\n        // Assume a successful POST, in case of an error\n        // the changes are reverted in the error callback.\n        var updatedStatus = null;\n        var oldStatus = thread.status;\n        if (newStatus !== oldStatus) {\n          updatedStatus = newStatus;\n          if (oldStatus === _THREAD_STATUS_OPEN) {\n            _openThreadsCount -= 1;\n          } else if (newStatus === _THREAD_STATUS_OPEN) {\n            _openThreadsCount += 1;\n          }\n          thread.status = updatedStatus;\n        }\n\n        var payload = {\n          updated_status: updatedStatus,\n          updated_subject: null,\n          text: newMessage\n        };\n\n        $http.post(url, payload).then(function() {\n          _fetchMessages(threadId);\n\n          if (successCallback) {\n            successCallback();\n          }\n        }, function() {\n          // Revert changes\n          if (newStatus !== oldStatus) {\n            if (oldStatus === _THREAD_STATUS_OPEN) {\n              _openThreadsCount += 1;\n            } else if (newStatus === _THREAD_STATUS_OPEN) {\n              _openThreadsCount -= 1;\n            }\n            thread.status = oldStatus;\n          }\n          if (errorCallback) {\n            errorCallback();\n          }\n        });\n      },\n      resolveSuggestion: function(\n          threadId, action, commitMsg, reviewMsg, audioUpdateRequired,\n          onSuccess, onFailure) {\n        var payload = {\n          action: action\n        };\n\n        if (constants.ENABLE_GENERALIZED_FEEDBACK_THREADS) {\n          suggestionId = threadId;\n        } else {\n          suggestionId = \'exploration.\' + threadId;\n        }\n        payload.review_message = reviewMsg;\n        if (action === ACTION_ACCEPT_SUGGESTION) {\n          payload.commit_message = commitMsg;\n        }\n        _openThreadsCount -= 1;\n        $http.put(\n          _SUGGESTION_ACTION_HANDLER_URL + suggestionId, payload).then(\n          onSuccess, function() {\n            _openThreadsCount += 1;\n            if (onFailure) {\n              onFailure();\n            }\n          }\n        );\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
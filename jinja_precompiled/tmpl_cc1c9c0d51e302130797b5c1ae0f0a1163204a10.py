from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/ConversationSkinDirective.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controller for the conversation skin.\n */\n\n// Note: This file should be assumed to be in an IIFE, and the constants below\n// should only be used within this file.\nvar TIME_FADEOUT_MSEC = 100;\nvar TIME_HEIGHT_CHANGE_MSEC = 500;\nvar TIME_FADEIN_MSEC = 100;\nvar TIME_NUM_CARDS_CHANGE_MSEC = 500;\n\noppia.animation(\'.conversation-skin-animate-tutor-card-on-narrow\', function() {\n  var tutorCardLeft, tutorCardWidth, tutorCardHeight, oppiaAvatarLeft;\n  var tutorCardAnimatedLeft, tutorCardAnimatedWidth;\n\n  var beforeAddClass = function(element, className, done) {\n    if (className !== \'ng-hide\') {\n      done();\n      return;\n    }\n    var tutorCard = element;\n    var supplementalCard = $(\'.conversation-skin-supplemental-card-container\');\n    var oppiaAvatar = $(\'.conversation-skin-oppia-avatar.show-tutor-card\');\n    oppiaAvatarLeft = supplementalCard.position().left +\n                      supplementalCard.width() - oppiaAvatar.width();\n    tutorCardLeft = tutorCard.position().left;\n    tutorCardWidth = tutorCard.width();\n    tutorCardHeight = tutorCard.height();\n\n    if (tutorCard.offset().left + tutorCardWidth > oppiaAvatar.offset().left) {\n      var animationLength = Math.min(\n        oppiaAvatarLeft - tutorCard.offset().left,\n        tutorCardWidth);\n      tutorCardAnimatedLeft = tutorCardLeft + animationLength;\n      tutorCardAnimatedWidth = tutorCardWidth - animationLength;\n    } else {\n      tutorCardAnimatedLeft = oppiaAvatarLeft;\n      tutorCardAnimatedWidth = 0;\n    }\n\n    oppiaAvatar.hide();\n    tutorCard.css({\n      \'min-width\': 0\n    });\n    tutorCard.animate({\n      left: tutorCardAnimatedLeft,\n      width: tutorCardAnimatedWidth,\n      height: 0,\n      opacity: 1\n    }, 500, function() {\n      oppiaAvatar.show();\n      tutorCard.css({\n        left: \'\',\n        width: \'\',\n        height: \'\',\n        opacity: \'\',\n        \'min-width\': \'\'\n      });\n      done();\n    });\n  };\n\n  var removeClass = function(element, className, done) {\n    if (className !== \'ng-hide\') {\n      done();\n      return;\n    }\n    var tutorCard = element;\n    $(\'.conversation-skin-oppia-avatar.show-tutor-card\').hide(0, function() {\n      tutorCard.css({\n        left: tutorCardAnimatedLeft,\n        width: tutorCardAnimatedWidth,\n        height: 0,\n        opacity: 0,\n        \'min-width\': 0\n      });\n      tutorCard.animate({\n        left: tutorCardLeft,\n        width: tutorCardWidth,\n        height: tutorCardHeight,\n        opacity: 1\n      }, 500, function() {\n        tutorCard.css({\n          left: \'\',\n          width: \'\',\n          height: \'\',\n          opacity: \'\',\n          \'min-width\': \'\'\n        });\n        done();\n      });\n    });\n  };\n\n  return {\n    beforeAddClass: beforeAddClass,\n    removeClass: removeClass\n  };\n});\n\noppia.animation(\'.conversation-skin-animate-tutor-card-content\', function() {\n  var animateCardChange = function(element, className, done) {\n    if (className !== \'animate-card-change\') {\n      return;\n    }\n\n    var currentHeight = element.height();\n    var expectedNextHeight = $(\n      \'.conversation-skin-future-tutor-card \' +\n      \'.conversation-skin-tutor-card-content\'\n    ).height();\n\n    // Fix the current card height, so that it does not change during the\n    // animation, even though its contents might.\n    element.css(\'height\', currentHeight);\n\n    jQuery(element).animate({\n      opacity: 0\n    }, TIME_FADEOUT_MSEC).animate({\n      height: expectedNextHeight\n    }, TIME_HEIGHT_CHANGE_MSEC).animate({\n      opacity: 1\n    }, TIME_FADEIN_MSEC, function() {\n      element.css(\'height\', \'\');\n      done();\n    });\n\n    return function(cancel) {\n      if (cancel) {\n        element.css(\'opacity\', \'1.0\');\n        element.css(\'height\', \'\');\n        element.stop();\n      }\n    };\n  };\n\n  return {\n    addClass: animateCardChange\n  };\n});\n\noppia.animation(\'.conversation-skin-animate-cards\', function() {\n  // This removes the newly-added class once the animation is finished.\n  var animateCards = function(element, className, done) {\n    var tutorCardElt = jQuery(element).find(\n      \'.conversation-skin-main-tutor-card\');\n    var supplementalCardElt = jQuery(element).find(\n      \'.conversation-skin-supplemental-card-container\');\n\n    if (className === \'animate-to-two-cards\') {\n      var supplementalWidth = supplementalCardElt.width();\n      supplementalCardElt.css({\n        width: 0,\n        \'min-width\': \'0\',\n        opacity: \'0\'\n      });\n      supplementalCardElt.animate({\n        width: supplementalWidth\n      }, TIME_NUM_CARDS_CHANGE_MSEC, function() {\n        supplementalCardElt.animate({\n          opacity: \'1\'\n        }, TIME_FADEIN_MSEC, function() {\n          supplementalCardElt.css({\n            width: \'\',\n            \'min-width\': \'\',\n            opacity: \'\'\n          });\n          jQuery(element).removeClass(\'animate-to-two-cards\');\n          done();\n        });\n      });\n\n      return function(cancel) {\n        if (cancel) {\n          supplementalCardElt.css({\n            width: \'\',\n            \'min-width\': \'\',\n            opacity: \'\'\n          });\n          supplementalCardElt.stop();\n          jQuery(element).removeClass(\'animate-to-two-cards\');\n        }\n      };\n    } else if (className === \'animate-to-one-card\') {\n      supplementalCardElt.css({\n        opacity: 0,\n        \'min-width\': 0\n      });\n      supplementalCardElt.animate({\n        width: 0\n      }, TIME_NUM_CARDS_CHANGE_MSEC, function() {\n        jQuery(element).removeClass(\'animate-to-one-card\');\n        done();\n      });\n\n      return function(cancel) {\n        if (cancel) {\n          supplementalCardElt.css({\n            opacity: \'\',\n            \'min-width\': \'\',\n            width: \'\'\n          });\n          supplementalCardElt.stop();\n\n          jQuery(element).removeClass(\'animate-to-one-card\');\n        }\n      };\n    } else {\n      return;\n    }\n  };\n\n  return {\n    addClass: animateCards\n  };\n});\n\noppia.directive(\'conversationSkin\', [\n  \'UrlService\', \'UrlInterpolationService\',\n  function(UrlService, UrlInterpolationService) {\n    return {\n      restrict: \'E\',\n      scope: {},\n      link: function(scope) {\n        var isIframed = UrlService.isIframed();\n        scope.directiveTemplate = isIframed ?\n          UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_player/\' +\n            \'conversation_skin_embed_directive.html\') :\n          UrlInterpolationService.getDirectiveTemplateUrl(\n            \'/pages/exploration_player/\' +\n            \'conversation_skin_directive.html\');\n      },\n      template: \'<div ng-include="directiveTemplate"></div>\',\n      controller: [\n        \'$scope\', \'$timeout\', \'$rootScope\', \'$window\', \'$translate\', \'$http\',\n        \'$location\', \'MessengerService\', \'ExplorationPlayerService\',\n        \'UrlService\', \'FocusManagerService\', \'LearnerViewRatingService\',\n        \'WindowDimensionsService\', \'PlayerTranscriptService\',\n        \'LearnerParamsService\', \'PlayerPositionService\',\n        \'ExplorationRecommendationsService\', \'StatsReportingService\',\n        \'siteAnalyticsService\', \'ExplorationPlayerStateService\',\n        \'CONTENT_FOCUS_LABEL_PREFIX\', \'AlertsService\',\n        \'CONTINUE_BUTTON_FOCUS_LABEL\', \'EVENT_ACTIVE_CARD_CHANGED\',\n        \'EVENT_NEW_CARD_AVAILABLE\', \'EVENT_PROGRESS_NAV_SUBMITTED\',\n        \'FatigueDetectionService\', \'NumberAttemptsService\',\n        \'PlayerCorrectnessFeedbackEnabledService\',\n        \'RefresherExplorationConfirmationModalService\',\n        \'EXPLORATION_SUMMARY_DATA_URL_TEMPLATE\', \'INTERACTION_SPECS\',\n        \'EVENT_NEW_CARD_OPENED\', \'HintsAndSolutionManagerService\',\n        \'AudioTranslationManagerService\', \'EVENT_AUTOPLAY_AUDIO\',\n        \'COMPONENT_NAME_FEEDBACK\', \'AutogeneratedAudioPlayerService\',\n        function(\n            $scope, $timeout, $rootScope, $window, $translate, $http,\n            $location, MessengerService, ExplorationPlayerService,\n            UrlService, FocusManagerService, LearnerViewRatingService,\n            WindowDimensionsService, PlayerTranscriptService,\n            LearnerParamsService, PlayerPositionService,\n            ExplorationRecommendationsService, StatsReportingService,\n            siteAnalyticsService, ExplorationPlayerStateService,\n            CONTENT_FOCUS_LABEL_PREFIX, AlertsService,\n            CONTINUE_BUTTON_FOCUS_LABEL, EVENT_ACTIVE_CARD_CHANGED,\n            EVENT_NEW_CARD_AVAILABLE, EVENT_PROGRESS_NAV_SUBMITTED,\n            FatigueDetectionService, NumberAttemptsService,\n            PlayerCorrectnessFeedbackEnabledService,\n            RefresherExplorationConfirmationModalService,\n            EXPLORATION_SUMMARY_DATA_URL_TEMPLATE, INTERACTION_SPECS,\n            EVENT_NEW_CARD_OPENED, HintsAndSolutionManagerService,\n            AudioTranslationManagerService, EVENT_AUTOPLAY_AUDIO,\n            COMPONENT_NAME_FEEDBACK, AutogeneratedAudioPlayerService) {\n          $scope.CONTINUE_BUTTON_FOCUS_LABEL = CONTINUE_BUTTON_FOCUS_LABEL;\n          // The minimum width, in pixels, needed to be able to show two cards\n          // side-by-side.\n          var TIME_PADDING_MSEC = 250;\n          var TIME_SCROLL_MSEC = 600;\n          var MIN_CARD_LOADING_DELAY_MSEC = 950;\n\n          var hasInteractedAtLeastOnce = false;\n          $scope.answerIsBeingProcessed = false;\n          var _nextFocusLabel = null;\n          // This variable is used only when viewport is narrow.\n          // Indicates whether the tutor card is displayed.\n          var tutorCardIsDisplayedIfNarrow = true;\n\n          $scope.explorationId = ExplorationPlayerService.getExplorationId();\n          $scope.isInPreviewMode = ExplorationPlayerService.isInPreviewMode();\n          $scope.isIframed = UrlService.isIframed();\n          $rootScope.loadingMessage = \'Loading\';\n          $scope.hasFullyLoaded = false;\n          $scope.recommendedExplorationSummaries = null;\n          $scope.answerIsCorrect = false;\n          $scope.pendingCardWasSeenBefore = false;\n          $scope.isCorrectnessFeedbackEnabled = function() {\n            return PlayerCorrectnessFeedbackEnabledService.isEnabled();\n          };\n\n          $scope.isCorrectnessFooterEnabled = function() {\n            return (\n              $scope.answerIsCorrect && $scope.isCorrectnessFeedbackEnabled() &&\n              PlayerPositionService.hasLearnerJustSubmittedAnAnswer());\n          };\n\n          $scope.isLearnAgainButton = function() {\n            var interaction = ExplorationPlayerService.getInteraction(\n              $scope.activeCard.stateName);\n            if (INTERACTION_SPECS[interaction.id].is_linear) {\n              return false;\n            }\n            return (\n              $scope.pendingCardWasSeenBefore && !$scope.answerIsCorrect &&\n              $scope.isCorrectnessFeedbackEnabled());\n          };\n\n          $scope.OPPIA_AVATAR_IMAGE_URL = (\n            UrlInterpolationService.getStaticImageUrl(\n              \'/avatar/oppia_avatar_100px.svg\'));\n          $scope.getStaticImageUrl = (\n            UrlInterpolationService.getStaticImageUrl);\n\n          $scope.activeCard = null;\n          var numVisibleCards = 0;\n\n          $scope.upcomingStateName = null;\n          $scope.upcomingContentHtml = null;\n          $scope.upcomingInlineInteractionHtml = null;\n\n          $scope.DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER =\n            GLOBALS.DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER;\n\n          $scope.getContentFocusLabel = function(index) {\n            return CONTENT_FOCUS_LABEL_PREFIX + index;\n          };\n\n          // If the exploration is iframed, send data to its parent about its\n          // height so that the parent can be resized as necessary.\n          $scope.lastRequestedHeight = 0;\n          $scope.lastRequestedScroll = false;\n          $scope.adjustPageHeight = function(scroll, callback) {\n            $timeout(function() {\n              var newHeight = document.body.scrollHeight;\n              if (Math.abs($scope.lastRequestedHeight - newHeight) > 50.5 ||\n                  (scroll && !$scope.lastRequestedScroll)) {\n                // Sometimes setting iframe height to the exact content height\n                // still produces scrollbar, so adding 50 extra px.\n                newHeight += 50;\n                MessengerService.sendMessage(MessengerService.HEIGHT_CHANGE, {\n                  height: newHeight,\n                  scroll: scroll\n                });\n                $scope.lastRequestedHeight = newHeight;\n                $scope.lastRequestedScroll = scroll;\n              }\n\n              if (callback) {\n                callback();\n              }\n            }, 100);\n          };\n\n          $scope.reloadExploration = function() {\n            $window.location.reload();\n          };\n\n          $scope.isOnTerminalCard = function() {\n            return $scope.activeCard &&\n              ExplorationPlayerStateService.isStateTerminal(\n                $scope.activeCard.stateName);\n          };\n\n          var isSupplementalCardNonempty = function(card) {\n            return !ExplorationPlayerStateService.isInteractionInline(\n              card.stateName);\n          };\n\n          $scope.isCurrentSupplementalCardNonempty = function() {\n            return $scope.activeCard && isSupplementalCardNonempty(\n              $scope.activeCard);\n          };\n\n          $scope.isSupplementalNavShown = function() {\n            var interaction = ExplorationPlayerService.getInteraction(\n              $scope.activeCard.stateName);\n            return (\n              Boolean(interaction.id) &&\n              INTERACTION_SPECS[interaction.id].show_generic_submit_button &&\n              $scope.isCurrentCardAtEndOfTranscript());\n          };\n\n          // Navigates to the currently-active card, and resets the\n          // \'show previous responses\' setting.\n          var _navigateToActiveCard = function() {\n            $rootScope.$broadcast(EVENT_ACTIVE_CARD_CHANGED);\n            $scope.$broadcast(EVENT_AUTOPLAY_AUDIO);\n            /* A hash value is added to URL for scrolling to Oppia feedback\n               when answer is submitted by user in mobile view. This hash value\n               has to be reset each time a new card is loaded to prevent\n               unwanted scrolling in the new card. */\n            $location.hash(null);\n            $scope.pendingCardWasSeenBefore = false;\n            // We must cancel the autogenerated audio player here, or else a\n            // bug where the autogenerated audio player generates duplicate\n            // utterances occurs.\n            AutogeneratedAudioPlayerService.cancel();\n            var index = PlayerPositionService.getActiveCardIndex();\n            $scope.activeCard = PlayerTranscriptService.getCard(index);\n            tutorCardIsDisplayedIfNarrow = true;\n            if (_nextFocusLabel && PlayerTranscriptService.isLastCard(index)) {\n              FocusManagerService.setFocusIfOnDesktop(_nextFocusLabel);\n            } else {\n              FocusManagerService.setFocusIfOnDesktop(\n                $scope.getContentFocusLabel(index));\n            }\n          };\n\n          var animateToTwoCards = function(doneCallback) {\n            $scope.isAnimatingToTwoCards = true;\n            $timeout(function() {\n              $scope.isAnimatingToTwoCards = false;\n              if (doneCallback) {\n                doneCallback();\n              }\n            }, TIME_NUM_CARDS_CHANGE_MSEC + TIME_FADEIN_MSEC +\n              TIME_PADDING_MSEC);\n          };\n\n          var animateToOneCard = function(doneCallback) {\n            $scope.isAnimatingToOneCard = true;\n            $timeout(function() {\n              $scope.isAnimatingToOneCard = false;\n              if (doneCallback) {\n                doneCallback();\n              }\n            }, TIME_NUM_CARDS_CHANGE_MSEC);\n          };\n\n          $scope.isCurrentCardAtEndOfTranscript = function() {\n            return PlayerTranscriptService.isLastCard(\n              PlayerPositionService.getActiveCardIndex());\n          };\n          var _addNewCard = function(\n              stateName, newParams, contentHtml, interactionHtml) {\n            PlayerTranscriptService.addNewCard(\n              stateName, newParams, contentHtml, interactionHtml);\n\n            if (newParams) {\n              LearnerParamsService.init(newParams);\n            }\n\n            numVisibleCards++;\n\n            var totalNumCards = PlayerTranscriptService.getNumCards();\n\n            var previousSupplementalCardIsNonempty = (\n              totalNumCards > 1 &&\n              isSupplementalCardNonempty(\n                PlayerTranscriptService.getCard(totalNumCards - 2)));\n            var nextSupplementalCardIsNonempty = isSupplementalCardNonempty(\n              PlayerTranscriptService.getLastCard());\n\n            if (\n              totalNumCards > 1 &&\n              ExplorationPlayerService.canWindowShowTwoCards() &&\n              !previousSupplementalCardIsNonempty &&\n              nextSupplementalCardIsNonempty) {\n              PlayerPositionService.setActiveCardIndex(numVisibleCards - 1);\n              animateToTwoCards(function() {});\n            } else if (\n              totalNumCards > 1 &&\n              ExplorationPlayerService.canWindowShowTwoCards() &&\n              previousSupplementalCardIsNonempty &&\n              !nextSupplementalCardIsNonempty) {\n              animateToOneCard(function() {\n                PlayerPositionService.setActiveCardIndex(numVisibleCards - 1);\n              });\n            } else {\n              PlayerPositionService.setActiveCardIndex(numVisibleCards - 1);\n            }\n\n            if (ExplorationPlayerStateService.isStateTerminal(stateName)) {\n              $scope.isRefresherExploration = false;\n              $scope.parentExplorationIds =\n                UrlService.getQueryFieldValuesAsList(\'parent\');\n              var recommendedExplorationIds = [];\n              var includeAutogeneratedRecommendations = false;\n\n              if ($scope.parentExplorationIds.length > 0) {\n                $scope.isRefresherExploration = true;\n                var parentExplorationId = $scope.parentExplorationIds[\n                  $scope.parentExplorationIds.length - 1];\n                recommendedExplorationIds.push(parentExplorationId);\n              } else {\n                recommendedExplorationIds =\n                  ExplorationPlayerStateService.getAuthorRecommendedExpIds(\n                    stateName);\n                includeAutogeneratedRecommendations = true;\n              }\n\n              ExplorationRecommendationsService.getRecommendedSummaryDicts(\n                recommendedExplorationIds,\n                includeAutogeneratedRecommendations,\n                function(summaries) {\n                  $scope.recommendedExplorationSummaries = summaries;\n                });\n            }\n          };\n\n          $scope.initializePage = function() {\n            hasInteractedAtLeastOnce = false;\n            $scope.recommendedExplorationSummaries = null;\n\n            PlayerPositionService.init(_navigateToActiveCard);\n            ExplorationPlayerService.init(function(\n                exploration, initHtml, newParams) {\n              ExplorationPlayerStateService.setExploration(exploration);\n              $scope.isLoggedIn = ExplorationPlayerService.isLoggedIn();\n              _nextFocusLabel = FocusManagerService.generateFocusLabel();\n\n              _addNewCard(\n                exploration.initStateName,\n                newParams,\n                initHtml,\n                ExplorationPlayerService.getInteractionHtml(\n                  exploration.initStateName, _nextFocusLabel));\n              $rootScope.loadingMessage = \'\';\n              $scope.hasFullyLoaded = true;\n\n              // If the exploration is embedded, use the exploration language\n              // as site language. If the exploration language is not supported\n              // as site language, English is used as default.\n              var langCodes = constants.SUPPORTED_SITE_LANGUAGES.map(\n                function(language) {\n                  return language.id;\n                });\n              if ($scope.isIframed) {\n                var explorationLanguageCode = (\n                  ExplorationPlayerService.getExplorationLanguageCode());\n                if (langCodes.indexOf(explorationLanguageCode) !== -1) {\n                  $translate.use(explorationLanguageCode);\n                } else {\n                  $translate.use(\'en\');\n                }\n              }\n              $scope.adjustPageHeight(false, null);\n              $window.scrollTo(0, 0);\n              FocusManagerService.setFocusIfOnDesktop(_nextFocusLabel);\n\n              // The timeout is needed in order to give the recipient of the\n              // broadcast sufficient time to load.\n              $timeout(function() {\n                $rootScope.$broadcast(EVENT_NEW_CARD_OPENED, {\n                  stateName: exploration.initStateName\n                });\n              });\n            });\n          };\n\n          $scope.submitAnswer = function(answer, interactionRulesService) {\n            // Safety check to prevent double submissions from occurring.\n            if ($scope.answerIsBeingProcessed ||\n              !$scope.isCurrentCardAtEndOfTranscript() ||\n              $scope.activeCard.destStateName) {\n              return;\n            }\n\n            if (!$scope.isInPreviewMode) {\n              FatigueDetectionService.recordSubmissionTimestamp();\n              if (FatigueDetectionService.isSubmittingTooFast()) {\n                FatigueDetectionService.displayTakeBreakMessage();\n                $scope.$broadcast(\'oppiaFeedbackAvailable\');\n                return;\n              }\n            }\n            NumberAttemptsService.submitAttempt();\n\n            $scope.answerIsBeingProcessed = true;\n            hasInteractedAtLeastOnce = true;\n\n            var _oldStateName = PlayerTranscriptService.getLastCard().stateName;\n            PlayerTranscriptService.addNewInput(answer, false);\n\n            var timeAtServerCall = new Date().getTime();\n            PlayerPositionService.recordAnswerSubmission();\n\n            $scope.answerIsCorrect = ExplorationPlayerService.submitAnswer(\n              answer, interactionRulesService, function(\n                  newStateName, refreshInteraction, feedbackHtml,\n                  feedbackAudioTranslations, contentHtml, newParams,\n                  refresherExplorationId) {\n                // Do not wait if the interaction is supplemental -- there\'s\n                // already a delay bringing in the help card.\n                var millisecsLeftToWait = (\n                  !ExplorationPlayerStateService.isInteractionInline(\n                    _oldStateName) ? 1.0 :\n                  Math.max(MIN_CARD_LOADING_DELAY_MSEC - (\n                    new Date().getTime() - timeAtServerCall),\n                  1.0));\n\n                $timeout(function() {\n                  $scope.$broadcast(\'oppiaFeedbackAvailable\');\n                  var pairs = (\n                    PlayerTranscriptService.getLastCard().inputResponsePairs);\n                  var lastAnswerFeedbackPair = pairs[pairs.length - 1];\n                  $scope.$broadcast(EVENT_AUTOPLAY_AUDIO, {\n                    audioTranslations: feedbackAudioTranslations,\n                    html: feedbackHtml,\n                    componentName: COMPONENT_NAME_FEEDBACK\n                  });\n\n                  if (_oldStateName === newStateName) {\n                    // Stay on the same card.\n                    HintsAndSolutionManagerService.recordWrongAnswer();\n\n                    PlayerTranscriptService.addNewResponse(feedbackHtml);\n                    if (feedbackHtml &&\n                        !ExplorationPlayerStateService.isInteractionInline(\n                          $scope.activeCard.stateName)) {\n                      $scope.$broadcast(\'helpCardAvailable\', {\n                        helpCardHtml: feedbackHtml,\n                        hasContinueButton: false\n                      });\n                    }\n                    if (refreshInteraction) {\n                      // Replace the previous interaction with another of the\n                      // same type.\n                      _nextFocusLabel =\n                        FocusManagerService.generateFocusLabel();\n                      PlayerTranscriptService.updateLatestInteractionHtml(\n                        ExplorationPlayerService.getInteractionHtml(\n                          newStateName, _nextFocusLabel) +\n                        ExplorationPlayerService.getRandomSuffix());\n                    }\n\n                    $scope.redirectToRefresherExplorationConfirmed = false;\n\n                    if (refresherExplorationId) {\n                      // TODO(bhenning): Add tests to verify the event is\n                      // properly recorded.\n                      var confirmRedirection = function() {\n                        $scope.redirectToRefresherExplorationConfirmed = true;\n                        ExplorationPlayerService.recordLeaveForRefresherExp(\n                          newStateName, refresherExplorationId);\n                      };\n                      $http.get(EXPLORATION_SUMMARY_DATA_URL_TEMPLATE, {\n                        params: {\n                          stringified_exp_ids: JSON.stringify(\n                            [refresherExplorationId])\n                        }\n                      }).then(function(response) {\n                        if (response.data.summaries.length > 0) {\n                          RefresherExplorationConfirmationModalService.\n                            displayRedirectConfirmationModal(\n                              refresherExplorationId, confirmRedirection);\n                        }\n                      });\n                    }\n                    FocusManagerService.setFocusIfOnDesktop(_nextFocusLabel);\n                    scrollToBottom();\n                  } else {\n                    // There is a new card. If there is no feedback, move on\n                    // immediately. Otherwise, give the learner a chance to read\n                    // the feedback, and display a \'Continue\' button.\n                    FatigueDetectionService.reset();\n                    NumberAttemptsService.reset();\n                    _nextFocusLabel = FocusManagerService.generateFocusLabel();\n\n                    PlayerTranscriptService.setDestination(newStateName);\n\n                    // These are used to compute the dimensions for the\n                    // next card.\n                    $scope.upcomingStateName = newStateName;\n                    $scope.upcomingParams = newParams;\n                    $scope.upcomingContentHtml = (\n                      contentHtml + ExplorationPlayerService.getRandomSuffix());\n\n                    var _isNextInteractionInline = (\n                      ExplorationPlayerStateService.isInteractionInline(\n                        newStateName));\n                    $scope.upcomingInlineInteractionHtml = (\n                      _isNextInteractionInline ?\n                        ExplorationPlayerService.getInteractionHtml(\n                          newStateName, _nextFocusLabel\n                        ) + ExplorationPlayerService.getRandomSuffix() : \'\');\n                    $scope.upcomingInteractionInstructions = (\n                      ExplorationPlayerStateService.getInteractionInstructions(\n                        $scope.upcomingStateName));\n\n                    if (feedbackHtml) {\n                      var stateHistory =\n                        PlayerTranscriptService.getStateHistory();\n                      if (stateHistory.indexOf(newStateName) !== -1) {\n                        $scope.pendingCardWasSeenBefore = true;\n                      }\n                      PlayerTranscriptService.addNewResponse(feedbackHtml);\n                      if (!ExplorationPlayerStateService.isInteractionInline(\n                        $scope.activeCard.stateName)) {\n                        $scope.$broadcast(\'helpCardAvailable\', {\n                          helpCardHtml: feedbackHtml,\n                          hasContinueButton: true\n                        });\n                      }\n                      $rootScope.$broadcast(EVENT_NEW_CARD_AVAILABLE);\n                      _nextFocusLabel = $scope.CONTINUE_BUTTON_FOCUS_LABEL;\n                      FocusManagerService.setFocusIfOnDesktop(_nextFocusLabel);\n                      scrollToBottom();\n                    } else {\n                      PlayerTranscriptService.addNewResponse(feedbackHtml);\n                      // If there is no feedback, it immediately moves on\n                      // to next card. Therefore $scope.answerIsCorrect needs\n                      // to be set to false before it proceeds to next card.\n                      $scope.answerIsCorrect = false;\n                      $scope.showPendingCard(\n                        newStateName,\n                        newParams,\n                        contentHtml +\n                        ExplorationPlayerService.getRandomSuffix());\n                    }\n                  }\n                  $scope.answerIsBeingProcessed = false;\n                }, millisecsLeftToWait);\n              }\n            );\n          };\n          $scope.startCardChangeAnimation = false;\n          $scope.showPendingCard = function(\n              newStateName, newParams, newContentHtml) {\n            $scope.startCardChangeAnimation = true;\n\n            $timeout(function() {\n              var newInteractionHtml =\n                ExplorationPlayerService.getInteractionHtml(\n                  newStateName, _nextFocusLabel);\n              // Note that newInteractionHtml may be null.\n              if (newInteractionHtml) {\n                newInteractionHtml +=\n                  ExplorationPlayerService.getRandomSuffix();\n              }\n\n              _addNewCard(\n                newStateName, newParams, newContentHtml, newInteractionHtml);\n\n              $scope.upcomingStateName = null;\n              $scope.upcomingParams = null;\n              $scope.upcomingContentHtml = null;\n              $scope.upcomingInlineInteractionHtml = null;\n              $scope.upcomingInteractionInstructions = null;\n            }, TIME_FADEOUT_MSEC + 0.1 * TIME_HEIGHT_CHANGE_MSEC);\n\n            $timeout(function() {\n              FocusManagerService.setFocusIfOnDesktop(_nextFocusLabel);\n              scrollToTop();\n            },\n            TIME_FADEOUT_MSEC + TIME_HEIGHT_CHANGE_MSEC +\n              0.5 * TIME_FADEIN_MSEC);\n\n            $timeout(function() {\n              $scope.startCardChangeAnimation = false;\n            },\n            TIME_FADEOUT_MSEC + TIME_HEIGHT_CHANGE_MSEC + TIME_FADEIN_MSEC +\n            TIME_PADDING_MSEC);\n\n            $rootScope.$broadcast(EVENT_NEW_CARD_OPENED, {\n              stateName: newStateName\n            });\n          };\n\n          $scope.showUpcomingCard = function() {\n            /* This is for the following situation:\n               if A->B->C is the arrangement of cards and C redirected to A,\n               then after this, B and C are visited cards and hence\n               pendingCardWasSeenBefore would be true during both these\n               transitions and as answerIsCorrect is set to false below,\n               Continue would briefly change to Learn Again (after it is\n               clicked) during these transitions which is not required.\n               Also, if the \'if\' check is not there, Learn Again button would\n               briefly switched to Continue before going to next card. */\n            if ($scope.answerIsCorrect) {\n              $scope.pendingCardWasSeenBefore = false;\n            }\n            $scope.answerIsCorrect = false;\n            $scope.showPendingCard(\n              $scope.upcomingStateName, $scope.upcomingParams,\n              $scope.upcomingContentHtml);\n          };\n\n          var scrollToBottom = function() {\n            $timeout(function() {\n              var tutorCard = $(\'.conversation-skin-main-tutor-card\');\n\n              if (tutorCard.length === 0) {\n                return;\n              }\n              var tutorCardBottom = (\n                tutorCard.offset().top + tutorCard.outerHeight());\n              if ($(window).scrollTop() +\n                    $(window).height() < tutorCardBottom) {\n                $(\'html, body\').animate({\n                  scrollTop: tutorCardBottom - $(window).height() + 12\n                }, {\n                  duration: TIME_SCROLL_MSEC,\n                  easing: \'easeOutQuad\'\n                });\n              }\n            }, 100);\n          };\n\n          var scrollToTop = function() {\n            $timeout(function() {\n              $(\'html, body\').animate({\n                scrollTop: 0\n              }, 800, \'easeOutQuart\');\n              return false;\n            });\n          };\n\n          $scope.submitUserRating = function(ratingValue) {\n            LearnerViewRatingService.submitUserRating(ratingValue);\n          };\n          $scope.$on(\'ratingUpdated\', function() {\n            $scope.userRating = LearnerViewRatingService.getUserRating();\n          });\n\n          $window.addEventListener(\'beforeunload\', function(e) {\n            if ($scope.redirectToRefresherExplorationConfirmed) {\n              return;\n            }\n            if (hasInteractedAtLeastOnce && !$scope.isInPreviewMode &&\n                !ExplorationPlayerStateService.isStateTerminal(\n                  PlayerTranscriptService.getLastCard().stateName)) {\n              StatsReportingService.recordMaybeLeaveEvent(\n                PlayerTranscriptService.getLastStateName(),\n                LearnerParamsService.getAllParams());\n              var confirmationMessage = (\n                \'If you navigate away from this page, your progress on the \' +\n                \'exploration will be lost.\');\n              (e || $window.event).returnValue = confirmationMessage;\n              return confirmationMessage;\n            }\n          });\n\n          $scope.canWindowShowTwoCards = function() {\n            return ExplorationPlayerService.canWindowShowTwoCards();\n          };\n\n          $window.onresize = function() {\n            $scope.adjustPageHeight(false, null);\n          };\n\n          $window.addEventListener(\'scroll\', function() {\n            fixSupplementOnScroll();\n          });\n\n          var fixSupplementOnScroll = function() {\n            var supplementCard = $(\'div.conversation-skin-supplemental-card\');\n            var topMargin = $(\'.navbar-container\').height() - 20;\n            if ($(window).scrollTop() > topMargin) {\n              supplementCard.addClass(\n                \'conversation-skin-supplemental-card-fixed\');\n            } else {\n              supplementCard.removeClass(\n                \'conversation-skin-supplemental-card-fixed\');\n            }\n          };\n\n          $scope.initializePage();\n          LearnerViewRatingService.init(function(userRating) {\n            $scope.userRating = userRating;\n          });\n\n          $scope.collectionId = GLOBALS.collectionId;\n          $scope.collectionTitle = GLOBALS.collectionTitle;\n          $scope.collectionSummary = null;\n\n          if ($scope.collectionId) {\n            $http.get(\'/collectionsummarieshandler/data\', {\n              params: {\n                stringified_collection_ids: JSON.stringify(\n                  [$scope.collectionId])\n              }\n            }).then(\n              function(response) {\n                $scope.collectionSummary = response.data.summaries[0];\n              },\n              function() {\n                AlertsService.addWarning(\n                  \'There was an error while fetching the collection summary.\');\n              }\n            );\n          }\n\n          $scope.onNavigateFromIframe = function() {\n            siteAnalyticsService.registerVisitOppiaFromIframeEvent(\n              $scope.explorationId);\n          };\n\n          // Interaction answer validity is used to enable/disable\n          // the progress-nav\'s Submit button. This logic is here because\n          // Interactions and the progress-nav are both descendants\n          // of ConversationSkinDirective.\n          $scope.interactionAnswerIsValid = true;\n          $scope.setInteractionAnswerValidity = function(answerValidity) {\n            $scope.interactionAnswerIsValid = answerValidity;\n          };\n\n          $scope.submitAnswerFromProgressNav = function() {\n            $scope.$broadcast(EVENT_PROGRESS_NAV_SUBMITTED);\n          };\n        }\n      ]\n    };\n  }]);'

blocks = {}
debug_info = ''
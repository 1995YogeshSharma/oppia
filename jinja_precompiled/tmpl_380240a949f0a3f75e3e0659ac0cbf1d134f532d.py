from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/TrainingDataService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for training data that adds a new\n * answer to training data and verifies that training data answers are unique\n * across all answer groups.\n */\n\noppia.factory(\'TrainingDataService\', [\n  \'$rootScope\', \'$http\', \'ResponsesService\', \'RuleObjectFactory\',\n  function(\n      $rootScope, $http, ResponsesService, RuleObjectFactory) {\n    var _trainingDataAnswers = [];\n    var _trainingDataFrequencies = [];\n\n    var _getIndexOfTrainingData = function(answer, trainingData) {\n      var index = -1;\n      for (var i = 0; i < trainingData.length; i++) {\n        if (angular.equals(trainingData[i], answer)) {\n          index = i;\n          break;\n        }\n      }\n      return index;\n    };\n\n    // Attempts to remove a given answer from a list of trained answers. This\n    // function returns the index of the answer that was removed if it was\n    // successfully removed from the training data, or -1 otherwise.\n    var _removeAnswerFromTrainingData = function(answer, trainingData) {\n      var index = _getIndexOfTrainingData(answer, trainingData);\n      if (index !== -1) {\n        trainingData.splice(index, 1);\n      }\n      return index;\n    };\n\n    // This removes any occurrences of the answer from any training data inputs\n    // or the confirmed unclassified answer list. It also removes the answer\n    // from the training data being presented to the user so that it does not\n    // show up again.\n    var _removeAnswer = function(answer) {\n      var answerGroups = ResponsesService.getAnswerGroups();\n      var confirmedUnclassifiedAnswers = (\n        ResponsesService.getConfirmedUnclassifiedAnswers());\n      var updatedAnswerGroups = false;\n      var updatedConfirmedUnclassifiedAnswers = false;\n\n      // Remove the answer from all answer groups.\n      for (var i = 0; i < answerGroups.length; i++) {\n        var answerGroup = answerGroups[i];\n        var rules = answerGroup.rules;\n        var trainingData = answerGroup.trainingData;\n        if (trainingData &&\n            _removeAnswerFromTrainingData(answer, trainingData) !== -1) {\n          updatedAnswerGroups = true;\n        }\n      }\n\n      // Remove the answer from the confirmed unclassified answers.\n      updatedConfirmedUnclassifiedAnswers = (_removeAnswerFromTrainingData(\n        answer, confirmedUnclassifiedAnswers) !== -1);\n\n      if (updatedAnswerGroups) {\n        ResponsesService.save(\n          answerGroups, ResponsesService.getDefaultOutcome());\n      }\n\n      if (updatedConfirmedUnclassifiedAnswers) {\n        ResponsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n      }\n\n      var index = _removeAnswerFromTrainingData(answer, _trainingDataAnswers);\n      if (index !== -1) {\n        _trainingDataFrequencies.splice(index, 1);\n        $rootScope.$broadcast(\'updatedTrainingData\');\n      }\n    };\n\n    return {\n      initializeTrainingData: function(explorationId, stateName) {\n        var answerGroups = ResponsesService.getAnswerGroups();\n        for (var i = 0; i < answerGroups.length; i++) {\n          _trainingDataAnswers.push(answerGroups[i].training_data);\n        }\n      },\n\n      getTrainingDataAnswers: function() {\n        return _trainingDataAnswers;\n      },\n\n      getTrainingDataFrequencies: function() {\n        return _trainingDataFrequencies;\n      },\n\n      getAllPotentialOutcomes: function(state) {\n        var potentialOutcomes = [];\n        var interaction = state.interaction;\n\n        for (var i = 0; i < interaction.answerGroups.length; i++) {\n          potentialOutcomes.push(interaction.answerGroups[i].outcome);\n        }\n\n        if (interaction.defaultOutcome) {\n          var outcome = interaction.defaultOutcome;\n          potentialOutcomes.push(interaction.defaultOutcome);\n        }\n\n        return potentialOutcomes;\n      },\n\n      trainAnswerGroup: function(answerGroupIndex, answer) {\n        _removeAnswer(answer);\n\n        var answerGroup = ResponsesService.getAnswerGroup(answerGroupIndex);\n        var trainingData = answerGroup.trainingData;\n\n        // Train the rule to include this answer, but only if it\'s not already\n        // in the training data.\n        if (_getIndexOfTrainingData(answer, trainingData) === -1) {\n          trainingData.push(answer);\n        }\n\n        ResponsesService.updateAnswerGroup(answerGroupIndex, {\n          trainingData: trainingData\n        });\n      },\n\n      trainDefaultResponse: function(answer) {\n        _removeAnswer(answer);\n\n        var confirmedUnclassifiedAnswers = (\n          ResponsesService.getConfirmedUnclassifiedAnswers());\n\n        if (_getIndexOfTrainingData(\n          answer, confirmedUnclassifiedAnswers) === -1) {\n          confirmedUnclassifiedAnswers.push(answer);\n        }\n\n        ResponsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_editor/editor_tab/TrainingDataService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for training data that adds a new\n * answer to training data and verifies that training data answers are unique\n * across all answer groups.\n */\n\noppia.factory(\'TrainingDataService\', [\n  \'$rootScope\', \'$http\', \'ResponsesService\', \'RuleObjectFactory\',\n  \'ExplorationStatesService\', \'StateEditorService\', \'GraphDataService\',\n  function(\n      $rootScope, $http, ResponsesService, RuleObjectFactory,\n      ExplorationStatesService, StateEditorService, GraphDataService) {\n    var _getIndexOfTrainingData = function(answer, trainingData) {\n      var index = -1;\n      for (var i = 0; i < trainingData.length; i++) {\n        if (angular.equals(trainingData[i], answer)) {\n          index = i;\n          break;\n        }\n      }\n      return index;\n    };\n\n    // Attempts to remove a given answer from a list of trained answers. This\n    // function returns the index of the answer that was removed if it was\n    // successfully removed from the training data, or -1 otherwise.\n    var _removeAnswerFromTrainingData = function(answer, trainingData) {\n      var index = _getIndexOfTrainingData(answer, trainingData);\n      if (index !== -1) {\n        trainingData.splice(index, 1);\n      }\n      return index;\n    };\n\n    // This removes any occurrences of the answer from any training data inputs\n    // or the confirmed unclassified answer list. It also removes the answer\n    // from the training data being presented to the user so that it does not\n    // show up again.\n    var _removeAnswer = function(answer) {\n      var answerGroups = ResponsesService.getAnswerGroups();\n      var confirmedUnclassifiedAnswers = (\n        ResponsesService.getConfirmedUnclassifiedAnswers());\n      var updatedAnswerGroups = false;\n      var updatedConfirmedUnclassifiedAnswers = false;\n\n      // Remove the answer from all answer groups.\n      for (var i = 0; i < answerGroups.length; i++) {\n        var answerGroup = answerGroups[i];\n        var rules = answerGroup.rules;\n        var trainingData = answerGroup.trainingData;\n        if (trainingData &&\n            _removeAnswerFromTrainingData(answer, trainingData) !== -1) {\n          updatedAnswerGroups = true;\n        }\n      }\n\n      // Remove the answer from the confirmed unclassified answers.\n      updatedConfirmedUnclassifiedAnswers = (_removeAnswerFromTrainingData(\n        answer, confirmedUnclassifiedAnswers) !== -1);\n\n      if (updatedAnswerGroups) {\n        ResponsesService.save(\n          answerGroups, ResponsesService.getDefaultOutcome(),\n          function(newAnswerGroups, newDefaultOutcome) {\n            ExplorationStatesService.saveInteractionAnswerGroups(\n              StateEditorService.getActiveStateName(),\n              angular.copy(newAnswerGroups));\n\n            ExplorationStatesService.saveInteractionDefaultOutcome(\n              StateEditorService.getActiveStateName(),\n              angular.copy(newDefaultOutcome));\n\n            GraphDataService.recompute();\n          });\n      }\n\n      if (updatedConfirmedUnclassifiedAnswers) {\n        ResponsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n        ExplorationStatesService.saveConfirmedUnclassifiedAnswers(\n          StateEditorService.getActiveStateName(),\n          angular.copy(confirmedUnclassifiedAnswers));\n      }\n    };\n\n    return {\n      getTrainingDataAnswers: function() {\n        var trainingDataAnswers = [];\n        var answerGroups = ResponsesService.getAnswerGroups();\n\n        for (var i = 0; i < answerGroups.length; i++) {\n          var answerGroup = answerGroups[i];\n          trainingDataAnswers.push({\n            answerGroupIndex: i,\n            answers: answerGroup.trainingData\n          });\n        }\n        return trainingDataAnswers;\n      },\n\n      getTrainingDataOfAnswerGroup: function(answerGroupIndex) {\n        return ResponsesService.getAnswerGroup(answerGroupIndex).trainingData;\n      },\n\n      getAllPotentialOutcomes: function(state) {\n        var potentialOutcomes = [];\n        var interaction = state.interaction;\n\n        for (var i = 0; i < interaction.answerGroups.length; i++) {\n          potentialOutcomes.push(interaction.answerGroups[i].outcome);\n        }\n\n        if (interaction.defaultOutcome) {\n          var outcome = interaction.defaultOutcome;\n          potentialOutcomes.push(interaction.defaultOutcome);\n        }\n\n        return potentialOutcomes;\n      },\n\n      associateWithAnswerGroup: function(answerGroupIndex, answer) {\n        // Remove answer from traning data of any answer group or\n        // confirmed unclassified answers.\n        _removeAnswer(answer);\n\n        var answerGroups = ResponsesService.getAnswerGroups();\n        var answerGroup = answerGroups[answerGroupIndex];\n\n        // Train the rule to include this answer.\n        answerGroup.trainingData.push(answer);\n        ResponsesService.updateAnswerGroup(answerGroupIndex, {\n          trainingData: answerGroup.trainingData\n        }, function(newAnswerGroups) {\n          ExplorationStatesService.saveInteractionAnswerGroups(\n            StateEditorService.getActiveStateName(),\n            angular.copy(newAnswerGroups));\n\n          GraphDataService.recompute();\n        });\n      },\n\n      associateWithDefaultResponse: function(answer) {\n        // Remove answer from traning data of any answer group or\n        // confirmed unclassified answers.\n        _removeAnswer(answer);\n\n        var confirmedUnclassifiedAnswers = (\n          ResponsesService.getConfirmedUnclassifiedAnswers());\n        confirmedUnclassifiedAnswers.push(answer);\n        ResponsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n        ExplorationStatesService.saveConfirmedUnclassifiedAnswers(\n          StateEditorService.getActiveStateName(),\n          angular.copy(confirmedUnclassifiedAnswers));\n      },\n\n      isConfirmedUnclassifiedAnswer: function(answer) {\n        return (_getIndexOfTrainingData(\n          answer, ResponsesService.getConfirmedUnclassifiedAnswers()) !== -1);\n      },\n\n      removeAnswerFromAnswerGroupTrainingData: function(\n          answer, answerGroupIndex) {\n        var trainingData = ResponsesService.getAnswerGroup(\n          answerGroupIndex).trainingData;\n        _removeAnswerFromTrainingData(answer, trainingData);\n\n        var answerGroups = ResponsesService.getAnswerGroups();\n        answerGroups[answerGroupIndex].trainingData = trainingData;\n\n        ResponsesService.updateAnswerGroup(answerGroupIndex, {\n          trainingData: trainingData\n        }, function(newAnswerGroups) {\n          ExplorationStatesService.saveInteractionAnswerGroups(\n            StateEditorService.getActiveStateName(),\n            angular.copy(newAnswerGroups));\n\n          GraphDataService.recompute();\n        });\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/editor/undo_redo/UndoRedoService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service which maintains a stack of changes to a domain object.\n * Changes may be undone, redone, or replaced.\n */\n\noppia.constant(\n  \'EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED\', \'undoRedoServiceChangeApplied\');\n\n/**\n * Stores a stack of changes to a domain object. Please note that only one\n * instance of this service exists at a time, so multiple undo/redo stacks are\n * not currently supported.\n */\noppia.factory(\'UndoRedoService\', [\n  \'$rootScope\', \'EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED\',\n  function($rootScope, EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED) {\n    var UndoRedoService = {};\n\n    var _appliedChanges = [];\n    var _undoneChanges = [];\n\n    var _dispatchMutation = function() {\n      $rootScope.$broadcast(EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED);\n    };\n    var _applyChange = function(changeObject, domainObject) {\n      changeObject.applyChange(domainObject);\n      _dispatchMutation();\n    };\n    var _reverseChange = function(changeObject, domainObject) {\n      changeObject.reverseChange(domainObject);\n      _dispatchMutation();\n    };\n\n    /**\n     * Pushes a change domain object onto the change stack and applies it to the\n     * provided domain object. When a new change is applied, all undone changes\n     * are lost and cannot be redone. This will fire an event as defined by the\n     * constant EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED.\n     */\n    UndoRedoService.applyChange = function(changeObject, domainObject) {\n      _applyChange(changeObject, domainObject);\n      _appliedChanges.push(changeObject);\n      _undoneChanges = [];\n    };\n\n    /**\n     * Undoes the last change to the provided domain object. This function\n     * returns false if there are no changes to undo, and true otherwise. This\n     * will fire an event as defined by the constant\n     * EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED.\n     */\n    UndoRedoService.undoChange = function(domainObject) {\n      if (_appliedChanges.length !== 0) {\n        var change = _appliedChanges.pop();\n        _undoneChanges.push(change);\n        _reverseChange(change, domainObject);\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * Reverses an undo for the given domain object. This function returns false\n     * if there are no changes to redo, and true if otherwise. This will fire an\n     * event as defined by the constant EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED.\n     */\n    UndoRedoService.redoChange = function(domainObject) {\n      if (_undoneChanges.length !== 0) {\n        var change = _undoneChanges.pop();\n        _appliedChanges.push(change);\n        _applyChange(change, domainObject);\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * Returns the current list of changes applied to the provided domain\n     * object. This list will not contain undone actions. Changes to the\n     * returned list will not be reflected in this service.\n     */\n    UndoRedoService.getChangeList = function() {\n      // TODO(bhenning): Consider integrating something like Immutable.js to\n      // avoid the slice here and ensure the returned object is truly an\n      // immutable copy.\n      return _appliedChanges.slice();\n    };\n\n    /**\n     * Returns a list of commit dict updates representing all chosen changes in\n     * this service. Changes to the returned list will not affect this service.\n     * Furthermore, the returned list is ready to be sent to the backend.\n     */\n    UndoRedoService.getCommittableChangeList = function() {\n      var committableChangeList = [];\n      for (var i = 0; i < _appliedChanges.length; i++) {\n        committableChangeList[i] = _appliedChanges[i].getBackendChangeObject();\n      }\n      return committableChangeList;\n    };\n\n    UndoRedoService.setChangeList = function(changeList) {\n      _appliedChanges = angular.copy(changeList);\n    };\n\n    /**\n     * Returns the number of changes that have been applied to the domain\n     * object.\n     */\n    UndoRedoService.getChangeCount = function() {\n      return _appliedChanges.length;\n    };\n\n    /**\n     * Returns whether this service has any applied changes.\n     */\n    UndoRedoService.hasChanges = function() {\n      return _appliedChanges.length !== 0;\n    };\n\n    /**\n     * Clears the change history. This does not reverse any of the changes\n     * applied from applyChange() or redoChange(). This will fire an event as\n     * defined by the constant EVENT_UNDO_REDO_SERVICE_CHANGE_APPLIED.\n     */\n    UndoRedoService.clearChanges = function() {\n      _appliedChanges = [];\n      _undoneChanges = [];\n      _dispatchMutation();\n    };\n\n    return UndoRedoService;\n  }\n]);'

blocks = {}
debug_info = ''
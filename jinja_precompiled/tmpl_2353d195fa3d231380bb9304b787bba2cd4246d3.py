from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'pages/exploration_player/PlaythroughService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for recording and scrutinizing playthroughs.\n */\n\noppia.constant(\n  \'STORE_PLAYTHROUGH_URL\',\n  \'/explorehandler/store_playthrough/<exploration_id>\');\n\noppia.factory(\'PlaythroughService\', [\n  \'$http\', \'LearnerActionObjectFactory\', \'PlaythroughObjectFactory\',\n  \'StopwatchObjectFactory\', \'UrlInterpolationService\',\n  \'ACTION_TYPE_ANSWER_SUBMIT\', \'ACTION_TYPE_EXPLORATION_START\',\n  \'ACTION_TYPE_EXPLORATION_QUIT\', \'CURRENT_ACTION_SCHEMA_VERSION\',\n  \'CURRENT_ISSUE_SCHEMA_VERSION\', \'EARLY_QUIT_THRESHOLD_IN_SECS\',\n  \'ISSUE_TYPE_CYCLIC_STATE_TRANSITIONS\', \'ISSUE_TYPE_EARLY_QUIT\',\n  \'ISSUE_TYPE_MULTIPLE_INCORRECT_SUBMISSIONS\',\n  \'NUM_INCORRECT_ANSWERS_THRESHOLD\', \'NUM_REPEATED_CYCLES_THRESHOLD\',\n  \'PAGE_CONTEXT\', \'STORE_PLAYTHROUGH_URL\',\n  function(\n      $http, LearnerActionObjectFactory, PlaythroughObjectFactory,\n      StopwatchObjectFactory, UrlInterpolationService,\n      ACTION_TYPE_ANSWER_SUBMIT, ACTION_TYPE_EXPLORATION_START,\n      ACTION_TYPE_EXPLORATION_QUIT, CURRENT_ACTION_SCHEMA_VERSION,\n      CURRENT_ISSUE_SCHEMA_VERSION, EARLY_QUIT_THRESHOLD_IN_SECS,\n      ISSUE_TYPE_CYCLIC_STATE_TRANSITIONS, ISSUE_TYPE_EARLY_QUIT,\n      ISSUE_TYPE_MULTIPLE_INCORRECT_SUBMISSIONS,\n      NUM_INCORRECT_ANSWERS_THRESHOLD, NUM_REPEATED_CYCLES_THRESHOLD,\n      PAGE_CONTEXT, STORE_PLAYTHROUGH_URL) {\n    var playthrough = null;\n    var expStopwatch = null;\n    var isPlayerInSamplePopulation = null;\n    var whitelistedExpIds = null;\n\n    var multipleIncorrectStateName = {};\n\n    var cycleIdentifier = {};\n    var visitedStates = [];\n\n    var misTracker = false;\n    var cstTracker = false;\n\n    var removeOldQuitAction = function() {\n      var quitAction = playthrough.actions[playthrough.actions.length - 1];\n      // After the second quit action is recorded, the first quit is removed\n      // using this method. This ensures that there are only two quit actions\n      // in the playthrough actions list at a time.\n      playthrough.actions = playthrough.actions.filter(function(action) {\n        return action.actionType !== ACTION_TYPE_EXPLORATION_QUIT;\n      });\n      playthrough.actions.push(quitAction);\n    };\n\n    var _determineIfPlayerIsInSamplePopulation = function(probability) {\n      return Math.random() < probability;\n    };\n\n    var createMultipleIncorrectIssueTracker = function(initStateName) {\n      if (misTracker) {\n        return;\n      }\n      multipleIncorrectStateName = {\n        state_name: initStateName,\n        num_times_incorrect: 0\n      };\n      misTracker = true;\n    };\n\n    var createCyclicIssueTracker = function(initStateName) {\n      if (cstTracker) {\n        return;\n      }\n      cycleIdentifier = {\n        cycle: \'\',\n        num_cycles: 0\n      };\n      visitedStates.unshift(initStateName);\n      cstTracker = true;\n    };\n\n    var incrementIncorrectAnswerInMultipleIncorrectIssueTracker = function() {\n      multipleIncorrectStateName.num_times_incorrect += 1;\n    };\n\n    var recordStateTransitionInMultipleIncorrectIssueTracker = function(\n        destStateName) {\n      if (multipleIncorrectStateName.num_times_incorrect <\n        NUM_INCORRECT_ANSWERS_THRESHOLD) {\n        multipleIncorrectStateName.state_name = destStateName;\n        multipleIncorrectStateName.num_times_incorrect = 0;\n      }\n    };\n\n    var recordStateTransitionInCyclicIssueTracker = function(destStateName) {\n      if (cycleIdentifier.num_cycles < NUM_REPEATED_CYCLES_THRESHOLD) {\n        if (visitedStates.indexOf(destStateName) !== -1) {\n          // Cycle identified.\n          var cycleStartIndex = visitedStates.indexOf(destStateName);\n          visitedStates.push(destStateName);\n          var cycleString =\n            visitedStates.slice(\n              cycleStartIndex, visitedStates.length).toString();\n          if (cycleIdentifier.cycle === cycleString) {\n            cycleIdentifier.num_cycles += 1;\n          } else {\n            cycleIdentifier.cycle = cycleString;\n            cycleIdentifier.num_cycles = 1;\n          }\n          visitedStates = [destStateName];\n        } else {\n          visitedStates.push(destStateName);\n        }\n      }\n    };\n\n    var isMultipleIncorrectSubmissionsIssue = function() {\n      return multipleIncorrectStateName.num_times_incorrect >=\n        NUM_INCORRECT_ANSWERS_THRESHOLD;\n    };\n\n    var isCyclicStateTransitionsIssue = function() {\n      return cycleIdentifier.num_cycles >= NUM_REPEATED_CYCLES_THRESHOLD;\n    };\n\n    var isEarlyQuitIssue = function(timeSpentInExpInSecs) {\n      return timeSpentInExpInSecs < EARLY_QUIT_THRESHOLD_IN_SECS;\n    };\n\n    var analyzePlaythrough = function() {\n      // The ordering of checks in this method is such that the priority of\n      // issues to be recorded in case of multiple issues is captured. This\n      // follows MultipleIncorrectSubmissionsIssue ->\n      // CyclicStateTransitionsIssue -> EarlyQuitIssue.\n      var timeSpentInExpInSecs = expStopwatch.getTimeInSecs();\n      if (isMultipleIncorrectSubmissionsIssue()) {\n        playthrough.issueType = ISSUE_TYPE_MULTIPLE_INCORRECT_SUBMISSIONS;\n        playthrough.issueCustomizationArgs = {\n          state_name: {\n            value: multipleIncorrectStateName.state_name\n          },\n          num_times_answered_incorrectly: {\n            value: multipleIncorrectStateName.num_times_incorrect\n          }\n        };\n        return;\n      }\n\n      if (isCyclicStateTransitionsIssue()) {\n        playthrough.issueType = ISSUE_TYPE_CYCLIC_STATE_TRANSITIONS;\n        playthrough.issueCustomizationArgs = {\n          state_names: {\n            value: cycleIdentifier.cycle.split(\',\')\n          }\n        };\n        return;\n      }\n\n      if (isEarlyQuitIssue(timeSpentInExpInSecs)) {\n        playthrough.issueType = ISSUE_TYPE_EARLY_QUIT;\n        playthrough.issueCustomizationArgs = {\n          state_name: {\n            value:\n              playthrough.actions[\n                playthrough.actions.length - 1].actionCustomizationArgs\n                .state_name.value\n          },\n          time_spent_in_exp_in_secs: {\n            value: timeSpentInExpInSecs\n          }\n        };\n        return;\n      }\n    };\n\n    var storePlaythrough = function(isNewPlaythrough) {\n      var playthroughId = isNewPlaythrough ? null : playthrough.playthroughId;\n      var promise = $http.post(getFullPlaythroughUrl(), {\n        playthrough_data: playthrough.toBackendDict(),\n        issue_schema_version: CURRENT_ISSUE_SCHEMA_VERSION,\n        playthrough_id: playthroughId\n      });\n      if (isNewPlaythrough) {\n        promise.then(function(response) {\n          if (response.data.playthrough_stored) {\n            // In cases where maximum number of playthroughs already exists, the\n            // above flag is not True and playthrough ID is not set.\n            playthrough.playthroughId = response.data.playthrough_id;\n          }\n        });\n      }\n    };\n\n    var getFullPlaythroughUrl = function() {\n      return UrlInterpolationService.interpolateUrl(\n        STORE_PLAYTHROUGH_URL, {\n          exploration_id: playthrough.expId\n        });\n    };\n\n    var isPlayerExcludedFromSamplePopulation = function() {\n      return !isPlayerInSamplePopulation;\n    };\n\n    var isExplorationWhitelisted = function() {\n      return whitelistedExpIds.indexOf(playthrough.expId) !== -1;\n    };\n\n    var isPlaythroughDiscarded = function() {\n      return (\n        isPlayerExcludedFromSamplePopulation() || !isExplorationWhitelisted());\n    };\n\n    return {\n      initSession: function(\n          explorationId, explorationVersion, playthroughProbability,\n          whitelistedExplorationIds) {\n        isPlayerInSamplePopulation = _determineIfPlayerIsInSamplePopulation(\n          playthroughProbability);\n        whitelistedExpIds = whitelistedExplorationIds;\n        playthrough = PlaythroughObjectFactory.createNew(\n          null, explorationId, explorationVersion, null, {}, []);\n        expStopwatch = StopwatchObjectFactory.create();\n      },\n      getPlaythrough: function() {\n        return playthrough;\n      },\n      recordExplorationStartAction: function(initStateName) {\n        if (isPlaythroughDiscarded()) {\n          return;\n        }\n        var expStartLearnerAction = LearnerActionObjectFactory.createNew(\n          ACTION_TYPE_EXPLORATION_START,\n          {\n            state_name: {\n              value: initStateName\n            }\n          },\n          CURRENT_ACTION_SCHEMA_VERSION);\n\n        playthrough.actions.unshift(expStartLearnerAction);\n\n        createMultipleIncorrectIssueTracker(initStateName);\n\n        createCyclicIssueTracker(initStateName);\n\n        expStopwatch.reset();\n      },\n      recordAnswerSubmitAction: function(\n          stateName, destStateName, interactionId, answer, feedback,\n          timeSpentInStateSecs) {\n        if (isPlaythroughDiscarded()) {\n          return;\n        }\n        if (!cstTracker) {\n          createCyclicIssueTracker(stateName);\n        }\n        if (!misTracker) {\n          createMultipleIncorrectIssueTracker(stateName);\n        }\n        playthrough.actions.push(LearnerActionObjectFactory.createNew(\n          ACTION_TYPE_ANSWER_SUBMIT,\n          {\n            state_name: {\n              value: stateName\n            },\n            dest_state_name: {\n              value: destStateName\n            },\n            interaction_id: {\n              value: interactionId\n            },\n            submitted_answer: {\n              value: answer\n            },\n            feedback: {\n              value: feedback\n            },\n            time_spent_state_in_msecs: {\n              value: timeSpentInStateSecs\n            }\n          },\n          CURRENT_ACTION_SCHEMA_VERSION\n        ));\n\n        var didNotMoveToNextState = (destStateName === stateName);\n        if (didNotMoveToNextState) {\n          incrementIncorrectAnswerInMultipleIncorrectIssueTracker();\n        } else {\n          recordStateTransitionInMultipleIncorrectIssueTracker(destStateName);\n\n          recordStateTransitionInCyclicIssueTracker(destStateName);\n        }\n      },\n      recordExplorationQuitAction: function(\n          stateName, timeSpentInStateSecs) {\n        if (isPlaythroughDiscarded()) {\n          return;\n        }\n        playthrough.actions.push(LearnerActionObjectFactory.createNew(\n          ACTION_TYPE_EXPLORATION_QUIT,\n          {\n            state_name: {\n              value: stateName\n            },\n            time_spent_in_state_in_msecs: {\n              value: timeSpentInStateSecs\n            }\n          },\n          CURRENT_ACTION_SCHEMA_VERSION\n        ));\n      },\n      recordPlaythrough: function(isExplorationComplete) {\n        if (isPlaythroughDiscarded()) {\n          return;\n        }\n        if (isExplorationComplete) {\n          // If the exploration is completed, do not check for issues.\n          return;\n        }\n        if (playthrough.playthroughId) {\n          // Playthrough ID exists, so issue has already been identified.\n          removeOldQuitAction();\n          if (playthrough.issueType === ISSUE_TYPE_EARLY_QUIT) {\n            // If the existing issue is of type early quit, and some other issue\n            // can be identified, update the issue since early quit has lower\n            // priority.\n            analyzePlaythrough();\n          }\n          storePlaythrough(false);\n        } else {\n          // Playthrough ID doesn\'t exist.\n          analyzePlaythrough();\n          if (playthrough.issueType) {\n            // Issue type exists, so an issue is identified after analyzing the\n            // playthrough, and the playthrough is stored.\n            storePlaythrough(true);\n          }\n        }\n      }\n    };\n  }]);'

blocks = {}
debug_info = ''
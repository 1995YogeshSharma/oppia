from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'domain/collection/CollectionRightsObjectFactory.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2016 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating and mutating instances of frontend\n * collection rights domain objects.\n */\n\noppia.factory(\'CollectionRightsObjectFactory\', [\n  function() {\n    var CollectionRights = function(collectionRightsObject) {\n      this._collectionId = collectionRightsObject.collection_id;\n      this._canEdit = collectionRightsObject.can_edit;\n      this._canUnpublish = collectionRightsObject.can_unpublish;\n      this._isPrivate = collectionRightsObject.is_private;\n      this._ownerNames = collectionRightsObject.owner_names;\n    };\n\n    // Instance methods\n\n    CollectionRights.prototype.getCollectionId = function() {\n      return this._collectionId;\n    };\n\n    // Returns true if the the user can edit the collection. This property is\n    // immutable.\n    CollectionRights.prototype.canEdit = function() {\n      return this._canEdit;\n    };\n\n    // Returns true if the user can unpublish the collection.\n    CollectionRights.prototype.canUnpublish = function() {\n      return this._canUnpublish;\n    };\n\n    // Returns true if the collection is private.\n    CollectionRights.prototype.isPrivate = function() {\n      return this._isPrivate;\n    };\n\n    // Returns true if the collection is public.\n    CollectionRights.prototype.isPublic = function() {\n      return !this._isPrivate;\n    };\n\n    // Sets isPrivate to false only if the user can edit the corresponding\n    // collection.\n    CollectionRights.prototype.setPublic = function() {\n      if (this.canEdit()) {\n        this._isPrivate = false;\n      } else {\n        throw new Error(\'User is not allowed to edit this collection.\');\n      }\n    };\n\n    // Sets isPrivate to true only if canUnpublish and canEdit are both true.\n    CollectionRights.prototype.setPrivate = function() {\n      if (this.canEdit() && this.canUnpublish()) {\n        this._isPrivate = true;\n      } else {\n        throw new Error(\'User is not allowed to unpublish this collection.\');\n      }\n    };\n\n    // Returns the owner names of the collection. This property is immutable.\n    CollectionRights.prototype.getOwnerNames = function() {\n      return angular.copy(this._ownerNames);\n    };\n\n    // Returns the reference to the internal ownerNames array; this function is\n    // only meant to be used for Angular bindings and should never be used in\n    // code. Please use getOwnerNames() and related functions, instead. Please\n    // also be aware this exposes internal state of the collection rights domain\n    // object, so changes to the array itself may internally break the domain\n    // object.\n    CollectionRights.prototype.getBindableOwnerNames = function() {\n      return this._ownerNames;\n    };\n\n    // Static class methods. Note that "this" is not available in static\n    // contexts. This function takes a JSON object which represents a backend\n    // collection python dict.\n    CollectionRights.create = function(collectionRightsBackendObject) {\n      return new CollectionRights(angular.copy(collectionRightsBackendObject));\n    };\n\n    // Reassigns all values within this collection to match the existing\n    // collection rights. This is performed as a deep copy such that none of the\n    // internal, bindable objects are changed within this collection rights.\n    // Note that the collection nodes within this collection will be completely\n    // redefined as copies from the specified collection rights\n    CollectionRights.prototype.copyFromCollectionRights = function(\n        otherCollectionRights) {\n      this._collectionId = otherCollectionRights.getCollectionId();\n      this._canEdit = otherCollectionRights.canEdit();\n      this._isPrivate = otherCollectionRights.isPrivate();\n      this._canUnpublish = otherCollectionRights.canUnpublish();\n      this._ownerNames = otherCollectionRights.getOwnerNames();\n    };\n\n    // Create a new, empty collection rights object. This is not guaranteed to\n    // pass validation tests.\n    CollectionRights.createEmptyCollectionRights = function() {\n      return new CollectionRights({\n        owner_names: []\n      });\n    };\n\n    return CollectionRights;\n  }\n]);'

blocks = {}
debug_info = ''
from __future__ import division
from jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace
name = 'components/StateGraphLayoutService.js'

def root(context, missing=missing):
    resolve = context.resolve_or_missing
    undefined = environment.undefined
    if 0: yield None
    pass
    yield u'// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS-IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directives for reusable data visualization components.\n */\n\n// Service for computing layout of state graph nodes.\noppia.factory(\'StateGraphLayoutService\', [\n  \'$log\', \'$filter\', \'MAX_NODES_PER_ROW\',\n  function($log, $filter, MAX_NODES_PER_ROW) {\n    var MAX_INDENTATION_LEVEL = 2.5;\n\n    // The last result of a call to computeLayout(). Used for determining the\n    // order in which to specify states in rules.\n    var lastComputedArrangement = null;\n\n    var getGraphAsAdjacencyLists = function(nodes, links) {\n      var adjacencyLists = {};\n\n      for (var nodeId in nodes) {\n        adjacencyLists[nodeId] = [];\n      }\n      for (var i = 0; i < links.length; i++) {\n        if (links[i].source !== links[i].target &&\n            adjacencyLists[links[i].source].indexOf(links[i].target) === -1) {\n          adjacencyLists[links[i].source].push(links[i].target);\n        }\n      }\n\n      return adjacencyLists;\n    };\n\n    var getIndentationLevels = function(adjacencyLists, trunkNodeIds) {\n      var indentationLevels = [];\n\n      // Recursively find and indent the longest shortcut for the segment of\n      // nodes ranging from trunkNodeIds[startInd] to trunkNodeIds[endInd]\n      // (inclusive). It\'s possible that this shortcut starts from a trunk\n      // node within this interval (A, say) and ends at a trunk node after\n      // this interval, in which case we indent all nodes from A + 1 onwards.\n      // NOTE: this mutates indentationLevels as a side-effect.\n      var indentLongestShortcut = function(startInd, endInd) {\n        if (startInd >= endInd ||\n            indentationLevels[startInd] >= MAX_INDENTATION_LEVEL) {\n          return;\n        }\n\n        var bestSourceInd = -1;\n        var bestTargetInd = -1;\n\n        for (var sourceInd = startInd; sourceInd < endInd; sourceInd++) {\n          var sourceNodeId = trunkNodeIds[sourceInd];\n          for (var i = 0; i < adjacencyLists[sourceNodeId].length; i++) {\n            var possibleTargetInd = trunkNodeIds.indexOf(\n              adjacencyLists[sourceNodeId][i]);\n            if (possibleTargetInd !== -1 && sourceInd < possibleTargetInd) {\n              targetInd = Math.min(possibleTargetInd, endInd + 1);\n              if (targetInd - sourceInd > bestTargetInd - bestSourceInd) {\n                bestSourceInd = sourceInd;\n                bestTargetInd = targetInd;\n              }\n            }\n          }\n        }\n\n        if (bestTargetInd - bestSourceInd > 1) {\n          // Indent nodes in [bestSourceInd + 1, bestTargetInd - 1].\n          for (var i = bestSourceInd + 1; i < bestTargetInd; i++) {\n            indentationLevels[i] += 0.5;\n          }\n\n          // Recursively attempt to indent nodes before, within and after this\n          // interval.\n          indentLongestShortcut(startInd, bestSourceInd);\n          indentLongestShortcut(bestSourceInd + 1, bestTargetInd - 1);\n          indentLongestShortcut(bestTargetInd, endInd);\n        }\n      };\n\n      for (var i = 0; i < trunkNodeIds.length; i++) {\n        indentationLevels.push(0);\n      }\n      indentLongestShortcut(0, trunkNodeIds.length - 1);\n      return indentationLevels;\n    };\n\n    return {\n      // Returns an object representing the nodes of the graph. The keys of the\n      // object are the node labels. The corresponding values are objects with\n      // the following keys:\n      //   - x0: the x-position of the top-left corner of the node, measured\n      //       as a fraction of the total width.\n      //   - y0: the y-position of the top-left corner of the node, measured\n      //       as a fraction of the total height.\n      //   - width: the width of the node, measured as a fraction of the total\n      //       width.\n      //   - height: the height of the node, measured as a fraction of the total\n      //       height.\n      //   - xLabel: the x-position of the middle of the box containing\n      //       the node label, measured as a fraction of the total width.\n      //       The node label is centered horizontally within this box.\n      //   - yLabel: the y-position of the middle of the box containing\n      //       the node label, measured as a fraction of the total height.\n      //       The node label is centered vertically within this box.\n      //   - reachable: whether there is a path from the start node to this\n      //       node.\n      //   - reachableFromEnd: whether there is a path from this node to the\n      //       END node.\n      //   - id: a unique id for the node.\n      //   - label: the full label of the node.\n      computeLayout: function(nodes, links, initNodeId, finalNodeIds) {\n        var adjacencyLists = getGraphAsAdjacencyLists(nodes, links);\n\n        // Find a long path through the graph from the initial state to a\n        // terminal state via simple backtracking. Limit the algorithm to a\n        // constant number of calls in order to ensure that the calculation\n        // does not take too long.\n        var MAX_BACKTRACKING_CALLS = 1000;\n        var numBacktrackingCalls = 0;\n        var bestPath = [initNodeId];\n        // Note that this is a \'global variable\' for the purposes of the\n        // backtracking computation.\n        var currentPath = [];\n\n        var backtrack = function(currentNodeId) {\n          currentPath.push(currentNodeId);\n\n          // If the current node leads to no other nodes, we consider it a\n          // \'terminal state\'.\n          if (adjacencyLists[currentNodeId].length === 0) {\n            if (currentPath.length > bestPath.length) {\n              bestPath = angular.copy(currentPath);\n            }\n          } else {\n            numBacktrackingCalls++;\n            if (numBacktrackingCalls <= MAX_BACKTRACKING_CALLS) {\n              for (var i = 0; i < adjacencyLists[currentNodeId].length; i++) {\n                if (currentPath.indexOf(\n                  adjacencyLists[currentNodeId][i]) === -1) {\n                  backtrack(adjacencyLists[currentNodeId][i]);\n                }\n              }\n            }\n          }\n\n          currentPath.pop();\n        };\n\n        backtrack(initNodeId);\n\n        // In this implementation, nodes are aligned with a rectangular grid.\n        // We calculate two additional internal variables for each node in\n        // nodeData:\n        //   - depth: its depth in the graph.\n        //   - offset: its horizontal offset in the graph.\n        // The depth and offset are measured in terms of grid squares.\n        //\n        // We first take the longest path through the graph (the \'trunk\') and\n        // find the longest possible shortcuts within that path, then indent\n        // the nodes within those shortcuts and assign depths/offsets to them.\n        // The indentation is done by only half a node width, so that the nodes\n        // still feel \'close\' together.\n        //\n        // After that, we traverse all remaining nodes via BFS and arrange them\n        // such that nodes that are immediate descendants of nodes in the trunk\n        // fall in the level just below their parent, and their children fall in\n        // the next level, etc. All these nodes are placed to the right of the\n        // trunk.\n        //\n        // NOTE: This algorithm does not work so well in clarifying articulation\n        // points and \'subclusters\' within a graph. For an illustration of this,\n        // see the \'Parameterized Adventure\' demo exploration.\n        var SENTINEL_DEPTH = -1;\n        var SENTINEL_OFFSET = -1;\n\n        var nodeData = {};\n        for (var nodeId in nodes) {\n          nodeData[nodeId] = {\n            depth: SENTINEL_DEPTH,\n            offset: SENTINEL_OFFSET,\n            reachable: false\n          };\n        }\n\n        var maxDepth = 0;\n        var maxOffsetInEachLevel = {\n          0: 0\n        };\n        var trunkNodesIndentationLevels = getIndentationLevels(\n          adjacencyLists, bestPath);\n\n        for (var i = 0; i < bestPath.length; i++) {\n          nodeData[bestPath[i]].depth = maxDepth;\n          nodeData[bestPath[i]].offset = trunkNodesIndentationLevels[i];\n          nodeData[bestPath[i]].reachable = true;\n          maxOffsetInEachLevel[maxDepth] = trunkNodesIndentationLevels[i];\n          maxDepth++;\n        }\n\n        // Do a breadth-first search to calculate the depths and offsets for\n        // other nodes.\n        var seenNodes = [initNodeId];\n        var queue = [initNodeId];\n\n        while (queue.length > 0) {\n          var currNodeId = queue[0];\n          queue.shift();\n\n          nodeData[currNodeId].reachable = true;\n\n          for (var i = 0; i < adjacencyLists[currNodeId].length; i++) {\n            var linkTarget = adjacencyLists[currNodeId][i];\n\n            // If the target node is a trunk node, but isn\'t at the correct\n            // depth to process now, we ignore it for now and stick it back in\n            // the queue to be processed later.\n            if (bestPath.indexOf(linkTarget) !== -1 &&\n                nodeData[linkTarget].depth !== nodeData[currNodeId].depth + 1) {\n              if (seenNodes.indexOf(linkTarget) === -1 &&\n                  queue.indexOf(linkTarget) === -1) {\n                queue.push(linkTarget);\n              }\n              continue;\n            }\n\n            // Assign depths and offsets to nodes only if we\'re processing them\n            // for the first time.\n            if (seenNodes.indexOf(linkTarget) === -1) {\n              seenNodes.push(linkTarget);\n\n              if (nodeData[linkTarget].depth === SENTINEL_DEPTH) {\n                nodeData[linkTarget].depth = nodeData[currNodeId].depth + 1;\n                nodeData[linkTarget].offset = (\n                  nodeData[linkTarget].depth in maxOffsetInEachLevel ?\n                  maxOffsetInEachLevel[nodeData[linkTarget].depth] + 1 : 0);\n\n                maxDepth = Math.max(maxDepth, nodeData[linkTarget].depth);\n                maxOffsetInEachLevel[nodeData[linkTarget].depth] = (\n                  nodeData[linkTarget].offset);\n              }\n\n              if (queue.indexOf(linkTarget) === -1) {\n                queue.push(linkTarget);\n              }\n            }\n          }\n        }\n\n        // Handle nodes that were not visited in the forward traversal.\n        maxOffsetInEachLevel[maxDepth + 1] = 0;\n        maxDepth += 1;\n        var orphanedNodesExist = false;\n        for (var nodeId in nodeData) {\n          if (nodeData[nodeId].depth === SENTINEL_DEPTH) {\n            orphanedNodesExist = true;\n            nodeData[nodeId].depth = maxDepth;\n            nodeData[nodeId].offset = maxOffsetInEachLevel[maxDepth];\n            maxOffsetInEachLevel[maxDepth] += 1;\n          }\n        }\n        if (orphanedNodesExist) {\n          maxDepth++;\n        }\n\n        // Build the \'inverse index\' -- for each row, store the (offset, nodeId)\n        // pairs in ascending order of offset.\n        var nodePositionsToIds = [];\n        for (var i = 0; i <= maxDepth; i++) {\n          nodePositionsToIds.push([]);\n        }\n        for (var nodeId in nodeData) {\n          if (nodeData[nodeId].depth !== SENTINEL_DEPTH) {\n            nodePositionsToIds[nodeData[nodeId].depth].push({\n              nodeId: nodeId,\n              offset: nodeData[nodeId].offset\n            });\n          }\n        }\n        for (var i = 0; i <= maxDepth; i++) {\n          nodePositionsToIds[i].sort(function(a, b) {\n            return a.offset - b.offset;\n          });\n        }\n\n        // Recalculate the node depths and offsets, taking into account\n        // MAX_NODES_PER_ROW. If there are too many nodes in a row, we overflow\n        // them into the next one.\n        var currentDepth = 0;\n        var currentLeftMargin = 0;\n        var currentLeftOffset = 0;\n        for (var i = 0; i <= maxDepth; i++) {\n          if (nodePositionsToIds[i].length > 0) {\n            // The offset of the leftmost node at this depth. If there are too\n            // many nodes in this depth, this variable is used to figure out\n            // which offset to start the continuation rows from.\n            currentLeftMargin = nodePositionsToIds[i][0].offset;\n            // The offset of the current node under consideration.\n            currentLeftOffset = currentLeftMargin;\n\n            for (var j = 0; j < nodePositionsToIds[i].length; j++) {\n              var computedOffset = currentLeftOffset;\n              if (computedOffset >= MAX_NODES_PER_ROW) {\n                currentDepth++;\n                computedOffset = currentLeftMargin + 1;\n                currentLeftOffset = computedOffset;\n              }\n\n              nodeData[nodePositionsToIds[i][j].nodeId].depth = currentDepth;\n              nodeData[nodePositionsToIds[i][j].nodeId].offset = (\n                currentLeftOffset);\n\n              currentLeftOffset += 1;\n            }\n            currentDepth++;\n          }\n        }\n\n        // Calculate the width and height of each grid rectangle.\n        var totalRows = currentDepth;\n        // Set totalColumns to be MAX_NODES_PER_ROW, so that the width of the\n        // graph visualization can be calculated based on a fixed constant,\n        // MAX_NODES_PER_ROW. Otherwise, the width of the individual nodes is\n        // dependent on the number of nodes in the longest row, and this makes\n        // the nodes too wide if, e.g., the overall graph is just a single\n        // column wide.\n        var totalColumns = MAX_NODES_PER_ROW;\n\n        // Horizontal padding between the graph and the edge of the graph\n        // visualization, measured as a fraction of the entire height.\n        var HORIZONTAL_EDGE_PADDING_FRACTION = 0.05;\n        // Vertical edge padding between the graph and the edge of the graph\n        // visualization, measured as a fraction of the entire height.\n        var VERTICAL_EDGE_PADDING_FRACTION = 0.1;\n\n        // The vertical padding, measured as a fraction of the height of a grid\n        // rectangle, between the top of the grid rectangle and the top of the\n        // node. An equivalent amount of padding will be used for the space\n        // between the bottom of the grid rectangle and the bottom of the node.\n        var GRID_NODE_Y_PADDING_FRACTION = 0.2;\n        // As above, but for the horizontal padding.\n        var GRID_NODE_X_PADDING_FRACTION = 0.1;\n        // The vertical padding, measured as a fraction of the height of a grid\n        // rectangle, between the top of the node and the top of the node label.\n        // An equivalent amount of padding will be used for the space between\n        // the bottom of the node and the bottom of the node label.\n        var NODE_LABEL_Y_PADDING_FRACTION = 0.15;\n        // As above, but for the horizontal padding.\n        var NODE_LABEL_X_PADDING_FRACTION = 0.05;\n\n        // Helper function that returns a horizontal position, in terms of a\n        // fraction of the total width, given a horizontal offset in terms of\n        // grid rectangles.\n        var getHorizontalPosition = function(offsetInGridRectangles) {\n          var fractionalGridWidth = (\n            (1.0 - HORIZONTAL_EDGE_PADDING_FRACTION * 2) / totalColumns);\n          return (\n            HORIZONTAL_EDGE_PADDING_FRACTION +\n            fractionalGridWidth * offsetInGridRectangles);\n        };\n\n        // Helper function that returns a vertical position, in terms of a\n        // fraction of the total height, given a vertical offset in terms of\n        // grid rectangles.\n        var getVerticalPosition = function(offsetInGridRectangles) {\n          var fractionalGridHeight = (\n            (1.0 - VERTICAL_EDGE_PADDING_FRACTION * 2) / totalRows);\n          return (\n            VERTICAL_EDGE_PADDING_FRACTION +\n            fractionalGridHeight * offsetInGridRectangles);\n        };\n\n        for (var nodeId in nodeData) {\n          nodeData[nodeId].y0 = getVerticalPosition(\n            nodeData[nodeId].depth + GRID_NODE_Y_PADDING_FRACTION);\n          nodeData[nodeId].x0 = getHorizontalPosition(\n            nodeData[nodeId].offset + GRID_NODE_X_PADDING_FRACTION);\n\n          nodeData[nodeId].yLabel = getVerticalPosition(\n            nodeData[nodeId].depth + 0.5);\n          nodeData[nodeId].xLabel = getHorizontalPosition(\n            nodeData[nodeId].offset + 0.5);\n\n          nodeData[nodeId].height = (\n            (1.0 - VERTICAL_EDGE_PADDING_FRACTION * 2) / totalRows\n          ) * (1.0 - GRID_NODE_Y_PADDING_FRACTION * 2);\n          nodeData[nodeId].width = (\n            (1.0 - HORIZONTAL_EDGE_PADDING_FRACTION * 2) / totalColumns\n          ) * (1.0 - GRID_NODE_X_PADDING_FRACTION * 2);\n        }\n\n        // Assign id and label to each node.\n        for (var nodeId in nodeData) {\n          nodeData[nodeId].id = nodeId;\n          nodeData[nodeId].label = nodes[nodeId];\n        }\n\n        // Mark nodes that are reachable from any end state via backward links.\n        queue = finalNodeIds;\n        for (var i = 0; i < finalNodeIds.length; i++) {\n          nodeData[finalNodeIds[i]].reachableFromEnd = true;\n        }\n        while (queue.length > 0) {\n          var currNodeId = queue[0];\n          queue.shift();\n\n          for (var i = 0; i < links.length; i++) {\n            if (links[i].target === currNodeId &&\n                !nodeData[links[i].source].reachableFromEnd) {\n              nodeData[links[i].source].reachableFromEnd = true;\n              queue.push(links[i].source);\n            }\n          }\n        }\n\n        lastComputedArrangement = angular.copy(nodeData);\n\n        return nodeData;\n      },\n      getLastComputedArrangement: function() {\n        return angular.copy(lastComputedArrangement);\n      },\n      getGraphBoundaries: function(nodeData) {\n        var INFINITY = 1e30;\n        var BORDER_PADDING = 5;\n\n        var leftEdge = INFINITY;\n        var topEdge = INFINITY;\n        var bottomEdge = -INFINITY;\n        var rightEdge = -INFINITY;\n\n        for (var nodeId in nodeData) {\n          leftEdge = Math.min(\n            nodeData[nodeId].x0 - BORDER_PADDING, leftEdge);\n          topEdge = Math.min(\n            nodeData[nodeId].y0 - BORDER_PADDING, topEdge);\n          rightEdge = Math.max(\n            nodeData[nodeId].x0 + BORDER_PADDING + nodeData[nodeId].width,\n            rightEdge);\n          bottomEdge = Math.max(\n            nodeData[nodeId].y0 + BORDER_PADDING + nodeData[nodeId].height,\n            bottomEdge);\n        }\n\n        return {\n          bottom: bottomEdge,\n          left: leftEdge,\n          right: rightEdge,\n          top: topEdge\n        };\n      },\n      getAugmentedLinks: function(nodeData, nodeLinks) {\n        var links = angular.copy(nodeLinks);\n        var augmentedLinks = links.map(function(link) {\n          return {\n            source: angular.copy(nodeData[link.source]),\n            target: angular.copy(nodeData[link.target])\n          };\n        });\n\n        for (var i = 0; i < augmentedLinks.length; i++) {\n          var link = augmentedLinks[i];\n          if (link.source.label !== link.target.label) {\n            var sourcex = link.source.xLabel;\n            var sourcey = link.source.yLabel;\n            var targetx = link.target.xLabel;\n            var targety = link.target.yLabel;\n\n            if (sourcex === targetx && sourcey === targety) {\n              // TODO(sll): Investigate why this happens.\n              return;\n            }\n\n            var sourceWidth = link.source.width;\n            var sourceHeight = link.source.height;\n            var targetWidth = link.target.width;\n            var targetHeight = link.target.height;\n\n            var dx = targetx - sourcex;\n            var dy = targety - sourcey;\n\n            /* Fractional amount of truncation to be applied to the end of\n               each link. */\n            var startCutoff = (sourceWidth / 2) / Math.abs(dx);\n            var endCutoff = (targetWidth / 2) / Math.abs(dx);\n            if (dx === 0 || dy !== 0) {\n              startCutoff = (\n                (dx === 0) ? (sourceHeight / 2) / Math.abs(dy) :\n                Math.min(startCutoff, (sourceHeight / 2) / Math.abs(dy)));\n              endCutoff = (\n                (dx === 0) ? (targetHeight / 2) / Math.abs(dy) :\n                Math.min(endCutoff, (targetHeight / 2) / Math.abs(dy)));\n            }\n\n            var dxperp = targety - sourcey;\n            var dyperp = sourcex - targetx;\n            var norm = Math.sqrt(dxperp * dxperp + dyperp * dyperp);\n            dxperp /= norm;\n            dyperp /= norm;\n\n            var midx = sourcex + dx / 2 + dxperp * (sourceHeight / 4);\n            var midy = sourcey + dy / 2 + dyperp * (targetHeight / 4);\n            var startx = sourcex + startCutoff * dx;\n            var starty = sourcey + startCutoff * dy;\n            var endx = targetx - endCutoff * dx;\n            var endy = targety - endCutoff * dy;\n\n            // Draw a quadratic bezier curve.\n            augmentedLinks[i].d = (\n              \'M\' + startx + \' \' + starty + \' Q \' + midx + \' \' + midy +\n              \' \' + endx + \' \' + endy);\n          }\n        }\n        return augmentedLinks;\n      },\n      modifyPositionValues: function(nodeData, graphWidth, graphHeight) {\n        var HORIZONTAL_NODE_PROPERTIES = [\'x0\', \'width\', \'xLabel\'];\n        var VERTICAL_NODE_PROPERTIES = [\'y0\', \'height\', \'yLabel\'];\n\n        // Change the position values in nodeData to use pixels.\n        for (var nodeId in nodeData) {\n          for (var i = 0; i < HORIZONTAL_NODE_PROPERTIES.length; i++) {\n            nodeData[nodeId][HORIZONTAL_NODE_PROPERTIES[i]] = (\n              graphWidth *\n              nodeData[nodeId][HORIZONTAL_NODE_PROPERTIES[i]]);\n            nodeData[nodeId][VERTICAL_NODE_PROPERTIES[i]] = (\n              graphHeight *\n              nodeData[nodeId][VERTICAL_NODE_PROPERTIES[i]]);\n          }\n        }\n        return nodeData;\n      },\n      getGraphWidth: function(maxNodesPerRow, maxNodeLabelLength) {\n        // A rough upper bound for the width of a single letter, in pixels,\n        // to use as a scaling factor to determine the width of graph nodes.\n        // This is not an entirely accurate description because it also takes\n        // into account the horizontal whitespace between graph nodes.\n        var letterWidthInPixels = 10.5;\n        return maxNodesPerRow * maxNodeLabelLength * letterWidthInPixels;\n      },\n      getGraphHeight: function(nodeData) {\n        var maxDepth = 0;\n        for (var nodeId in nodeData) {\n          maxDepth = Math.max(maxDepth, nodeData[nodeId].depth);\n        }\n        return 70.0 * (maxDepth + 1);\n      }\n    };\n  }\n]);'

blocks = {}
debug_info = ''